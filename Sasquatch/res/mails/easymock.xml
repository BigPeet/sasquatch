<?xml version="1.0" encoding="UTF-8"?>
<mails>
  <mail>
    <header>How to mock a method that uses call-by-reference ?</header>
    <body>Hi, I would like to mock a method that makes use of call-by-reference: "void myMethod(Object request, Object reply)". I've been reading the documentation of EasyMock, but I haven't found any description how this could be achieved. I would be glad if someone could help me with this issue :o) Regards, Stefan Lecho.</body>
  </mail>
  <mail>
    <header>Re: How to mock a method that uses call-by-reference ?</header>
    <body>Meaning that your method modifies the passed in params?  If so, it seems you have 2 options. 1) pass in non-mock params and assert values afterwards or 2) pass in mock objects that have the appropriate expectations setup and then call verify after your method call myMethod(Object request, Object reply)". I've been reading the documentation of EasyMock, but I haven't found any description how this could be achieved.</body>
  </mail>
  <mail>
    <header>203 - 468 US dollars each day</header>
    <body>easymock@yahoogroups.com, I'm merely writing you to tell you that I'm definitely not trying to avoid you.  I've just been seriously busy with side projects that have been bringing in insane amounts of extra money. It truly is crazy how incredibly easy it will be to make even more than I am in less than couple weeks.  If you don't make it happen, you might be kicking yourself within a week. want to take up too much of your spare time writing about how much cash I'm producing when you can just read the post to hear on your own how convenient it really is.  It can be extremely tempting to talk about the wealth with almost everyone you meet but try not to end up speaking about it a lot more than you're working on it.  The work only requires a few hours a couple days a week anyhow. You won't believe it before you check it out for yourself but remember, almost every check is larger than the last one. Don't forget who mentioned it first!</body>
  </mail>
  <mail>
    <header>FW: tmjxwqagf</header>
    <body>easymock@yahoogroups.com, I'm only writing this to you to let you know that I'm not trying to avoid you at all.  I've been seriously busy working on side projects that have been bringing in insane amounts of cash. It's insane how simple it will be to start making just as much as I am in less than couple of days. I've been tripling my own salary after using this less than a week from the house.  If you find out about this woman you are going to realise why I decided to use it out.  You're going to be making a great deal of cash with it. Try it out and get back to me as soon as you become comfortable showing off all your success. I really hope you try this out becauseI've never seen anything like this before and the dough keeps on flowing. You might appreciate me for this.</body>
  </mail>
  <mail>
    <header>nice mocks: verify a call does not happen</header>
    <body>I'm using easymock in a project, and for various reasons I'm using a nice mock in a particular test. However, I want to make sure that a particular call never happens. I tried calling: But easymock complained about this. The most succinct way I found of doing this is: Is there any easier way?</body>
  </mail>
  <mail>
    <header>SSL certificates setting - Easy Mock</header>
    <body>How to set SSL certificates using Easy Mock unit tests in the TestNG framework ?</body>
  </mail>
  <mail>
    <header>Misleading error message when matches are type promoted</header>
    <body>Hi. The following unit test: produces the following confusing error message: java.lang.AssertionError: org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:44\ ) org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:85) In case the formatting is screwed up, you can see it here:  Why is Interface.method(1) unexpected when the very next line says that it is expected? The reason is that eq() received an int, and the interface uses a long. Equals.equals returns false because Int and Long are of different classes. Can we change Equals.equals to be more forgiving around numeric type promotion, or else change ArgumentToString.appendArgument to print more precise literals, such as 1l instead of 1? Thanks.</body>
  </mail>
  <mail>
    <header>How to mock a message driven bean (MDB) ?</header>
    <body>Hi, In our application we're using a message driven bean (MDB) to get messages from a queue. In order to prevent the definition of this queue in an application server, I would like to mock the MDB. This would allow me to test the 'onMessage' method out of the container. Do you have any advice on how to mock a MDB ? Regards, Stefan Lecho.</body>
  </mail>
  <mail>
    <header>Re: How to mock a message driven bean (MDB) ?</header>
    <body>Hi, You should consider letting your MDB dispatch message handling to a "regular" POJO - and then mock the Message object that gets passed to the POJO - this will allow you to "short-circuit" the app server and test message handling logic outside of the container. Otherwise you'll be forced to mock all that nasty stuff the container is supposed to do. /rasmus from a queue. In order to prevent the definition of this queue in an application server, I would like to mock the MDB. This would allow me to test the 'onMessage' method out of the container.</body>
  </mail>
  <mail>
    <header>EasyMock 2.2 question</header>
    <body>Hi, Need help on the following case.   I need to test a service's API. public interface MyDao public class ServiceImpl implement Servce public class ServiceImplTest I know I have to implement an IArgumentMatcher to define the match rule of "mock.getModel(model)",  but the "mock.getModel(..)" is NOT using the input object "model" I created.  It just matches it. How can I make EasyMock to use the input object for the expected method call? Thanks, Luke</body>
  </mail>
  <mail>
    <header>Re: replay() doesn't act like I expect (and as described in the documentation)?</header>
    <body>Exact! I found out this morning while stepping through EasyMock's source code. +1 for open source! -1 for Java varargs. Thanks a lot, Henri. Dirk sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:43) org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java\ :44) org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:\ 15) org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:4\ 1) org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20\ ) org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.ja\ va:79) org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71\ ) org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49\ ) org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReferen\ ce.java:49) org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:467) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:683) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :390) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:197)</body>
  </mail>
  <mail>
    <header>Matchers in SUT method calls, reset, and test isolation</header>
    <body>Hello EasyMock users, I've just been hit by an issue which already occured in past, and I'm wondering if anything can be done in EasyMock to prevent this. A developer new to EasyMock in one unit test resets mocks, records expected behavior, replays mocks, and in call to SUT method(s) by mistake passes EasyMock.isA(..), as one of arguments. Verification and asserts pass for that test as test doesn't make any special use of passed argument - that argument is just passed to method of a service whose behavior has been mocked. Calling isA, although it doesn't affect test where it was called, it alters threadToArgumentMatcherStack since InstanceOf matcher is reported. Any other test (typically in different test class, with different SUT and mocks) which is executed in same thread, because of this shared thread local stack, fails when recording expected behavior (1 matchers expected, 2 recorded - 1 recored from isA call from previous test, 1 records in current test), even though that other test resets its mocks properly. Typically we're using TestNG + EasyMock for unit tests, Eclipse + TestNG plugin to implement and run tests, and Maven + Surefire to build and run tests. This behavior would not show up in Eclipse, but it would in Maven build with default Surefire forkMode (once), and EasyMock would report error in one test class, although actual error is in another. I guess there are no means to verify whether "isA" is passed when recording expected behavior or when exercising SUT. Except for educating devs new to EasyMock not to make mistakes like this, is there any way to prevent this unwanted behavior, or at least make it easier to debug? Regards, Stevo.</body>
  </mail>
  <mail>
    <header>Test of methode that instantiates a mocked class</header>
    <body>Hello everyone, I'm doing unit testing with JUnit and EasyMock, I met this difficulty that I can not get around : how to test a method of a class that instantiates a mocked class. thank you in advance</body>
  </mail>
  <mail>
    <header>Re: Test of methode that instantiates a mocked class</header>
    <body>Can you extract a method to wrap the instantiation of the mocked class, then subclass and override? Do you have a few lines of code to show us so we can better understand the question? -Matt-</body>
  </mail>
  <mail>
    <header>PowerMock(1.4.8) mock static question</header>
    <body>Hi, I am write a TestNG test using PowerMock 1.4.8 to mock a static method . @PrepareForTest(StaticMethodClass.class) public class TestClass public class StaticMethodClass But I got this exception: java.lang.IllegalArgumentException: StaticMethodClass is not an interface at org.easymock.internal.JavaProxyFactory.createProxy(JavaProxyFactory.java:13) at org.easymock.internal.MocksControl.createMock(MocksControl.java:40) at org.powermock.api.easymock.PowerMock.doCreateMock(PowerMock.java:2212) at org.powermock.api.easymock.PowerMock.doMock(PowerMock.java:2163) at org.powermock.api.easymock.PowerMock.mockStatic(PowerMock.java:287) It must be something wrong I configured.  Any idea? Thanks, Luke</body>
  </mail>
  <mail>
    <header>PODAM 2.3.0.RELEASE just released</header>
    <body>This is a major release which provides the @PodamStrageyValue annotation to declare a data provider strategy at the POJO attribute level. Additionally the same capability has been added to @PodamCollection for Collections, Maps and Arrays. The full documentation can be found on PODAM homepage at:</body>
  </mail>
  <mail>
    <header>PODAM 2.3.4.RELEASE just released</header>
    <body>This is a major release to which you should upgrade to. This release makes PODAM very fault-taulerant. PODAM will create a POJO no matter which constructor type you declared (public no-arg, private no-arg, public with args, non-public with args). The difference between 2.3.3 is that while before non-public, non- default constructors were not covered now they are; additionally while before in case of non JavaBean standard constuctors PODAM created an instance but did not populate its attributes, now it both creates an instance and populates its attributes. PODAM documentation can be found at: Regards, Marco</body>
  </mail>
  <mail>
    <header>Project Status?</header>
    <body>Hi all- I emailed Henri directly, but I'm just curious in general what the status of this project is, I completely understand as a developer how projects can sideline others, but there are a few big bugs that have patches posted in the bugtracker, and I'm wondering if there is any plan to at least do a maintenance release soon that includes them? Thanks, David</body>
  </mail>
  <mail>
    <header>Is verify necessary for writing unit tests?</header>
    <body>In most cases, I don't want my unit tests to know about the internals of my routines so I use expect to stub out values but I don't use verify.  From the point of view of best practices, is this considered an acceptable use of EasyMock?</body>
  </mail>
  <mail>
    <header>Re: Is verify necessary for writing unit tests?</header>
    <body>For what it's worth, I rarely use verify either.  I find the default behavior of EasyMock is quite strict.  If I have a truly mission critical class to test, I will use a strict mock in the unit test.  It can be time consuming to get the unit test running with a strict mock, but I get the sense that I really have the code nailed down if I can get it passing with a strict mock.</body>
  </mail>
  <mail>
    <header>Re: Is verify necessary for writing unit tests?</header>
    <body>Hi klbcolt, routines so I use expect to stub out values but I don't use verify. of EasyMock? That depends on the scenario you would like to test. The mock object should test exactly the behavior you expect your code to use  no more, no less. - If you care about the order of calls, use a strict mock. If you don't care about the order, use a default mock. - If you care about the expected calls to happen, call verify(). If you don't care, don't call verify(). Two examples: - Let's say you have an object under test which writes log messages to an object of type ILogger. If you want to test that the log messages are written in the correct order, use a strict mock (for order checking), feed in the expected calls, and call verify() in the end. If your test does test another aspect of the object under test and you don't care about the logger at all, but need one to get the stuff running, use a nice mock for the logger, don't feed in any calls, and don't call verify() in the end. - Let's say you have an object under test which reads data from an interface IListSource. IListSource has two methods numberOfItems() and itemAt(int index). If your object under test renders all items, your mock object should expect at least one call to numberOfItems() and at least one call for each index to itemAt(index), and you should call verify() in the end to ensure that you haven't skipped an item. Hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>Partial mocks with generics</header>
    <body>Hello, I'm trying to create a partial mock of a generic class and don't quite understand the behavior I'm seeing. As an example, I've used a mock builder to create a partial mock with no mocked methods (for the sake of brevity, I've omitted adding any mocked methods). I've noticed that when my non-mock method a() is called directly everything works as expected. However, when called indirectly via indirectA(), a mock version of a() is (undesirably) used. Could anyone explain this behavior, and suggest the correct solution? Thanks! call a(42)"</body>
  </mail>
  <mail>
    <header>method chaining</header>
    <body>Is there any way to make it easier to mock chained method calls: Assuming this is application code: and this is the test: ... Can you add feature to EasyMock framework to make something like this possible:</body>
  </mail>
  <mail>
    <header>Downloading easymock</header>
    <body>The zip file that I get seems to be reports from Clover, not source code. Rich</body>
  </mail>
  <mail>
    <header>Re: Downloading easymock</header>
    <body>Hello Rich, in , the sources can be found in easymock-3.0-sources.jar. If you have trouble uncompressing it, just rename it to easymock-3.0-sources.zip. Hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>Re: method chaining</header>
    <body>I agree that this would be a very useful feature. possible:</body>
  </mail>
  <mail>
    <header>Re: Save mocks to xml</header>
    <body>Is there any interest to persisting mock recordings to XML? My use has tended to be in the area of functional testing, while EasyMock has historically played in the realm of unit testing, but maybe there could be value in pushing EasyMock into new places without compromising the core of what makes EasyMock great. I would really like to contribute this to EasyMock, and if people don't think this particular idea is useful, I would still like to contribute in other areas of EasyMock. Please let me know what you think.</body>
  </mail>
  <mail>
    <header>Re: Complex EasyMock Use case - for me! - need help</header>
    <body>Hi, [] call? the local implementation of answer(), correct? A capture should do what you would like: expect(commonDAO.createEntity(capture(operationCapture))).andAnswer(new //  replay etc. // assertions using capturedOperation You could also consider returning another operation (or even nil) when createEntity() is called to simplify your test. Your test checks whether createEntity is called and whether the  argument (the operation) is built correctly, and not more. But as I don't have the full source code, I can't tell whether returning nil would be fine or not: //  replay etc. // assertions using capturedOperation Hope that helps, Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: Complex EasyMock Use case - for me! - need help</header>
    <body>Fantastic, it works great! In my case, I need to validate the content of the created Operation, but it's good to know you can return nil as well. Thanks A LOT Tammo call? in the local implementation of answer(), correct? createEntity() is called to simplify your test. Your test checks whether createEntity is called and whether the  argument (the operation) is built correctly, and not more. But as I don't have the full source code, I can't tell whether returning nil would be fine or not:</body>
  </mail>
  <mail>
    <header>Problem with Netty (jboss)</header>
    <body>I am using EasyMock to build junit tests for an application based on the jboss Netty project. There are several classes in the application that extend the SimpleChannelHandler class, implementing messageReceived() and writeRequested() methods as shown below. My problem with this is twofold. First, how do I test for a successful readBytes(), which is a void method that fills the byte array passed to it? Second, how do I create a MessageEvent with the input for the transformation. I'm still new to Java, and this is my first attempt at writing junit tests, but even the two experts here did not have any suggestions on how to do this. Is there a way to test this code with EasyMock without rewriting major sections of this application? Thank you, Bob McConnell CODE: e) do my transformation here. END:</body>
  </mail>
  <mail>
    <header>RE: Problem with Netty (jboss)</header>
    <body>Hi Henri, The code I included is from a method I am trying to test. I have five methods with this sequence scattered over three classes, where only the transformation varies between them. The problem is that I don't know how to write this test. There don't appear to be any descriptions or examples of using EasyMock to test a void method that modifies a variable or a member of the class. It looks to me like I need to build a real message event object, inserting my test data into it before I can call messageReceived(). But I don't know if I have to build that event from scratch, or can EasyMock build it for me so I only have to insert the source array? If I use a Mock event, can I insert specific data into the array that readBytes() will extract, or can I insert data into buf in that call instead of capturing it? Is there any way to look at the content of msg after the call to readBytes(), or do I have to wait and capture the transformed array in the writeBytes() call? Yeah, I'm new at this. I'm much more comfortable writing and testing in Assembler. Thank you, Bob McConnell -----Original Message----- From: Henri Tremblay Sent: Tuesday, December 07, 2010 7:35 PM Hi, I'm not sure what is tested and what is mocked  here. If the call to readBytes() is mocked, you can use a capture to get the byte content and assert it. And the MessageEvent will probably be mocked and recorded according to your needs. But a test example will help to provide a better answer I am using EasyMock to build junit tests for an application based on the jboss Netty project. There are several classes in the application that extend the SimpleChannelHandler class, implementing messageReceived() and writeRequested() methods as shown below. My problem with this is twofold. First, how do I test for a successful readBytes(), which is a void method that fills the byte array passed to it? Second, how do I create a MessageEvent with the input for the transformation. I'm still new to Java, and this is my first attempt at writing junit tests, but even the two experts here did not have any suggestions on how to do this. Is there a way to test this code with EasyMock without rewriting major sections of this application? Thank you, Bob McConnell CODE: // Incoming traffic moves upstream. @Override public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) do my transformation here. END:</body>
  </mail>
  <mail>
    <header>RE: Problem with Netty (jboss)</header>
    <body>This has been bugging me all week, even though I have been working on other projects. But I have an idea about this issue, I just don't know enough about Java or EasyMock to know if it will work. Is it possible to write an inverse to Capture() that will inject specific data into a variable? In the case of this specific Netty class, could it do something like this: -----8&amp;lt;--------------------------------------------------- buffer // --&amp;gt;&amp;gt;   The Inject here is the inverse of capture. -----8&amp;lt;--------------------------------------------------- Is this even feasible? Bob McConnell -----Original Message----- From: Bob McConnell Sent: Wednesday, December 08, 2010 8:32 AM To: easymock@yahoogroups.com Subject: RE: [easymock] Problem with Netty (jboss) Hi Henri, The code I included is from a method I am trying to test. I have five methods with this sequence scattered over three classes, where only the transformation varies between them. The problem is that I don't know how to write this test. There don't appear to be any descriptions or examples of using EasyMock to test a void method that modifies a variable or a member of the class. It looks to me like I need to build a real message event object, inserting my test data into it before I can call messageReceived(). But I don't know if I have to build that event from scratch, or can EasyMock build it for me so I only have to insert the source array? If I use a Mock event, can I insert specific data into the array that readBytes() will extract, or can I insert data into buf in that call instead of capturing it? Is there any way to look at the content of msg after the call to readBytes(), or do I have to wait and capture the transformed array in the writeBytes() call? Yeah, I'm new at this. I'm much more comfortable writing and testing in Assembler. Thank you, Bob McConnell -----Original Message----- From: Henri Tremblay Sent: Tuesday, December 07, 2010 7:35 PM Hi, I'm not sure what is tested and what is mocked here. If the call to readBytes() is mocked, you can use a capture to get the byte content and assert it. And the MessageEvent will probably be mocked and recorded according to your needs. But a test example will help to provide a better answer On Mon, Dec 6, 2010 at 3:45 PM, Bob McConnell &amp;lt;rvm@... I am using EasyMock to build junit tests for an application based on the jboss Netty project. There are several classes in the application that extend the SimpleChannelHandler class, implementing messageReceived() and writeRequested() methods as shown below. My problem with this is twofold. First, how do I test for a successful readBytes(), which is a void method that fills the byte array passed to it? Second, how do I create a MessageEvent with the input for the transformation. I'm still new to Java, and this is my first attempt at writing junit tests, but even the two experts here did not have any suggestions on how to do this. Is there a way to test this code with EasyMock without rewriting major sections of this application? Thank you, Bob McConnell CODE: // Incoming traffic moves upstream. @Override public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) do my transformation here. END:</body>
  </mail>
  <mail>
    <header>RE: Problem with Netty (jboss)</header>
    <body>Henri, I still don't understand how this would work. I don't believe I can use expect because readBytes() is a null method. It just copies bytes from itself into the array passed to it in the first parameter using the second and third parameters as the starting offset (in the destination array) and the number of bytes to copy, adjusting internal pointers accordingly. Bob McConnell From: Henri Tremblay know to the how But EasyMock in in and</body>
  </mail>
  <mail>
    <header>RE: Problem with Netty (jboss)</header>
    <body>Henri, Ok, I'll plug that in and see if it works. But I have no clue what it does nor how you came up with it. As I said, I am new to Java and OOP. I am particularly confused by the third line which appears to me to be an inline definition of a class without calling it a class. I see the same coding style for Netty ChannelFutureListener, and can't see what it accomplishes there either. Thank you, Bob McConnell From: Henri Tremblay</body>
  </mail>
  <mail>
    <header>Re: Trigger wanted (or alternative suggestion)</header>
    <body>ah, ok. Now i have test code like this: This works fine but has two minor nuisances: -the returning null business -this code actually doesn't answer anything, it triggers a side effect How about adding a public static void andTriggerSideEffect( ISideEffect s ) method to IExpectation? (with ISideEffect defining a public void sideEffect() method)</body>
  </mail>
  <mail>
    <header>Re: Trigger wanted (or alternative suggestion)</header>
    <body>Hi, yeah, that's not so nice... I found a good solution though: I wrote a new abstract helper class so now i can write which looks ok for me. Do you want to add this class to EasyMock? :-) (You may rename the class to ISideEffect, thats ok :-) Cheers, Stephan</body>
  </mail>
  <mail>
    <header>Misleading "unexpected method call" error report</header>
    <body>A collegue developer by mistake has put EasyMock.isA(Stirng.class) call as parameter to actual method under test. This broke different test method in same test class which also makes use of same mock object. It was hard to debug what the actual error was since EasyMock reported "unexpected method call" on second test method even though it was ok. EasyMock.reset is called before every test method on a mock object that these two methods share, but some state it seems doesn't get reset causing this misleading error message. EasyMock 3.0 is being used. Hopefully something can be done to better handle this scenario. Regards, Stevo.</body>
  </mail>
  <mail>
    <header>OSGI tests failing on trunk Maven build</header>
    <body>I've been building trunk to get around the cglib-requirement bug in 3.0, and found that a few of the OSGI integration tests fail for me, with some Spring/log4j resource-related errors: Tests in error: ------------------------------------------------------------------------------- Test set: org.easymock.itests.InterfaceOnlyTest ------------------------------------------------------------------------------- FAILURE! ERROR! java.io.FileNotFoundException: C:\Users\brandall\.m2\repository\org\springframework\osgi\log4j.osgi\1.2.15-SNAP\ SHOT\log4j.osgi-1.2.15-SNAPSHOT.jar (The system cannot find the path specified) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.&amp;lt;init&amp;gt;(FileInputStream.java:106) at org.springframework.core.io.FileSystemResource.getInputStream(FileSystemResource\ .java:108) at org.springframework.osgi.test.AbstractOsgiTests.installBundle(AbstractOsgiTests.\ java:323) at org.springframework.osgi.test.AbstractOsgiTests.startup(AbstractOsgiTests.java:2\ 53) at org.springframework.osgi.test.AbstractOsgiTests.prepareTestExecution(AbstractOsg\ iTests.java:374) at org.springframework.osgi.test.AbstractOsgiTests.runBare(AbstractOsgiTests.java:2\ 03) at org.springframework.osgi.test.AbstractOsgiTests$1.protect(AbstractOsgiTests.java\ :184) at junit.framework.TestResult.runProtected(TestResult.java:124) at org.springframework.osgi.test.AbstractOsgiTests.run(AbstractOsgiTests.java:181) at junit.framework.TestSuite.runTest(TestSuite.java:230) at junit.framework.TestSuite.run(TestSuite.java:225) at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83) at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:115) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:140) at org.apache.maven.surefire.Surefire.run(Surefire.java:109) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:290) at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1017) testCanUseMatchers(org.easymock.itests.InterfaceOnlyTest)  Time elapsed: 0.001 sec  &amp;lt;&amp;lt;&amp;lt; ERROR! java.lang.NullPointerException at org.springframework.osgi.test.AbstractOsgiTests.invokeOSGiTestExecution(Abstract\ OsgiTests.java:395) at org.springframework.osgi.test.AbstractOsgiTests.runBare(AbstractOsgiTests.java:2\ 06) at org.springframework.osgi.test.AbstractOsgiTests$1.protect(AbstractOsgiTests.java\ :184) at junit.framework.TestResult.runProtected(TestResult.java:124) at org.springframework.osgi.test.AbstractOsgiTests.run(AbstractOsgiTests.java:181) at junit.framework.TestSuite.runTest(TestSuite.java:230) at junit.framework.TestSuite.run(TestSuite.java:225) at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83) at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:115) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:140) at org.apache.maven.surefire.Surefire.run(Surefire.java:109) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:290) at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1017) Any idea what is going on there?  Of course I can skip-tests ...</body>
  </mail>
  <mail>
    <header>SVN:r196 Tests fail</header>
    <body>I got the SVN trunk (r196) and tried to get it installed in my local maven repository, but there are some open issues. Can someone confirm that and what can be done to fix them? Greetings, Raphael java version "1.6.0_21" Java(TM) SE Runtime Environment (build 1.6.0_21-b06) Java HotSpot(TM) Server VM (build 17.0-b16, mixed mode) Failed tests: Tests in error: ------------------------------------------------------------------------------- Test set: org.easymock.tests2.CaptureTest ------------------------------------------------------------------------------- FAILURE! ERROR! java.lang.NullPointerException at org.easymock.tests2.CaptureTest.testCaptureType(CaptureTest.java:57) at org.easymock.tests2.CaptureTest.testCaptureFirst(CaptureTest.java:76) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java\ :44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:\ 15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:4\ 1) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20\ ) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76\ ) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50\ ) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184) at org.junit.runners.ParentRunner.run(ParentRunner.java:236) at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:115) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:102) at org.apache.maven.surefire.Surefire.run(Surefire.java:180) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:350) at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021) ERROR! java.lang.IllegalStateException: 1 matchers expected, 2 recorded. This exception usually occurs when matchers are mixed with raw values when recording a method: foo(5, eq(6)); // wrong You need to use no matcher at all or a matcher for every single param: foo(eq(5), eq(6)); // right foo(5, 6); // also right at org.easymock.internal.ExpectedInvocation.createMissingMatchers(ExpectedInvocatio\ n.java:48) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:41) at org.easymock.internal.RecordState.invoke(RecordState.java:79) at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:41\ ) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73) at $Proxy5.oneArg(Unknown Source) at org.easymock.tests2.CaptureTest.testCaptureType(CaptureTest.java:54) at org.easymock.tests2.CaptureTest.testCaptureLast(CaptureTest.java:82) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java\ :44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:\ 15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:4\ 1) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20\ ) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76\ ) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50\ ) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184) at org.junit.runners.ParentRunner.run(ParentRunner.java:236) at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:115) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:102) at org.apache.maven.surefire.Surefire.run(Surefire.java:180) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:350) at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021) ERROR! java.lang.NullPointerException at org.easymock.tests2.CaptureTest.testCaptureType(CaptureTest.java:57) at org.easymock.tests2.CaptureTest.testCaptureAll(CaptureTest.java:88) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java\ :44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:\ 15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:4\ 1) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20\ ) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76\ ) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50\ ) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184) at org.junit.runners.ParentRunner.run(ParentRunner.java:236) at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:115) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:102) at org.apache.maven.surefire.Surefire.run(Surefire.java:180) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:350) at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021) ERROR! java.lang.IllegalStateException: 1 matchers expected, 2 recorded. This exception usually occurs when matchers are mixed with raw values when recording a method: foo(5, eq(6)); // wrong You need to use no matcher at all or a matcher for every single param: foo(eq(5), eq(6)); // right foo(5, 6); // also right at org.easymock.internal.ExpectedInvocation.createMissingMatchers(ExpectedInvocatio\ n.java:48) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:41) at org.easymock.internal.RecordState.invoke(RecordState.java:79) at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:41\ ) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73) at $Proxy5.oneArg(Unknown Source) at org.easymock.tests2.CaptureTest.testCaptureType(CaptureTest.java:54) at org.easymock.tests2.CaptureTest.testCaptureNone(CaptureTest.java:94) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java\ :44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:\ 15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:4\ 1) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20\ ) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76\ ) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50\ ) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184) at org.junit.runners.ParentRunner.run(ParentRunner.java:236) at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:115) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:102) at org.apache.maven.surefire.Surefire.run(Surefire.java:180) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:350) at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021) testPrimitiveVsObject(org.easymock.tests2.CaptureTest)  Time elapsed: 0.001 sec java.lang.AssertionError: at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45\ ) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73) at $Proxy5.oneArg(Unknown Source) at org.easymock.tests2.CaptureTest.testPrimitiveVsObject(CaptureTest.java:130) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java\ :44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:\ 15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:4\ 1) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20\ ) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76\ ) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50\ ) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184) at org.junit.runners.ParentRunner.run(ParentRunner.java:236) at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:115) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:102) at org.apache.maven.surefire.Surefire.run(Surefire.java:180) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:350) at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021) FAILURE! java.lang.AssertionError: at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:45\ ) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:73) at $Proxy5.oneArg(Unknown Source) at org.easymock.tests2.CaptureTest.testPrimitive(CaptureTest.java:176) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java\ :44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:\ 15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:4\ 1) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20\ ) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76\ ) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50\ ) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184) at org.junit.runners.ParentRunner.run(ParentRunner.java:236) at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:115) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:102) at org.apache.maven.surefire.Surefire.run(Surefire.java:180) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:592) at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:350) at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021)</body>
  </mail>
  <mail>
    <header>Re: SVN:r196 Tests fail</header>
    <body>Hi Henri, my previous email contains the output of the surfire directory related to that faild test case. I've applied the following patch in order to get EasyMock compiled with J6SE. Could you please review this patch? Maybe it's one source of my failed test case. Greetings, Raphael ---8&amp;lt;---8&amp;lt;---8&amp;lt;---8&amp;lt;---8&amp;lt;---8&amp;lt;---8&amp;lt;---8&amp;lt;---8&amp;lt;---8&amp;lt;--- diff -r 4178009e3823 -r 0c423c506c41 src/main/java/org/easymock/EasyMock.java --- a/src/main/java/org/easymock/EasyMock.java Wed Sep 08 12:30:57 2010 +0200 +++ b/src/main/java/org/easymock/EasyMock.java Thu Sep 09 08:07:04 2010 +0200 @@ -1875,90 +1875,6 @@ -     * Expect any boolean but captures it for later use. -     * -     * @param captured -     *            Where the parameter is captured -     */ - -    /** -     * Expect any int but captures it for later use. -     * -     * @param captured -     *            Where the parameter is captured -     */ - -    /** -     * Expect any long but captures it for later use. -     * -     * @param captured -     *            Where the parameter is captured -     */ - -    /** -     * Expect any float but captures it for later use. -     * -     * @param captured -     *            Where the parameter is captured -     */ - -    /** -     * Expect any double but captures it for later use. -     * -     * @param captured -     *            Where the parameter is captured -     */ - -    /** -     * Expect any byte but captures it for later use. -     * -     * @param captured -     *            Where the parameter is captured -     */ - -    /** -     * Expect any char but captures it for later use. -     * -     * @param captured -     *            Where the parameter is captured -     */ - -    /** ---&amp;gt;8---&amp;gt;8---&amp;gt;8---&amp;gt;8---&amp;gt;8---&amp;gt;8---&amp;gt;8---&amp;gt;8---&amp;gt;8---&amp;gt;8---</body>
  </mail>
  <mail>
    <header>Save mocks to xml</header>
    <body>I have created a little tool that has many of the same features of EasyMock, and I was wondering if others would find it beneficial to contribute it to EasyMock. It could fit in nicely. In short, it allows you to save your mocks as an xml file. Once the mock is saved as xml and put in the test class path, you can simply load it. You could end up using it like this: Basically, this would have the recording phase already done in the xml, and all you have to do is use it. The benefits are for things where you just need stubs. The best use that I have gotten from this tool is mocking external service calls in running applications using some Spring AOP interceptors. This gives me control over these external services when running my Selenium tests. Without this, my Selenium tests could break unexpectedly when data from an external service changed. But because it works off of interfaces, you could use it to stub out anything. Does this sound like something that would be worth contributing to EasyMock, or do people think that it should live as its own open source project?</body>
  </mail>
  <mail>
    <header>Mock objects executing in a seperate thread</header>
    <body>We're trying to use easymock to unit test some multi-threaded code, and I'm seeing a problem catching certain types of errors. I'm wondering whether there are any best practices to deal with this or whether there is something that could be added to the package to help address these. Basically, our tests look something like the following: Thread A: createMock() specify expected behavior replay(mock) queue test wait verify(mock) check results Thread B: dequeue work and execute All the operations that the mock object is validating happen in Thread B as work is dequeued. The problem I'm seeing is that when unexpected behavior occurs, such as unexpected function calls, there is no way for verify() and the checking code in Thread A to get notice of the failure. I know that the Mock object will throw an exception when unexpected functions are called, and in single threaded test cases, this can be caught by JUnit and used to fail the test. But in the multithreaded case, there is no way for the thread (A) driving the test case to be notified of the failure. Instead, an exception is thrown in Thread B, propagates up, and ends up being printed to the Console. I don't mind that the exception is thrown in Thread B. Obviously, if an unexpected call is made to the mock object, there is no way for it to predictably respond, either to that call or any subsequent call, so throwing an exception is really the only option. But I really need a way to be notified of the exception in my driving thread as well. Ideally, calling verify() would thrown the same exception, but that doesn't seem to be happening. Any ideas on the best way to handle this in our test cases? We don't really want to change our threading mechanism, and changing the application code to install additional exception handlers just so the JUnit test cases work seems to be counter to non-intrusive testing. Any help would be appreciated, Will</body>
  </mail>
  <mail>
    <header>Re: Re: Mock objects executing in a seperate thread</header>
    <body>Your code does have to have a design that is testable, so there is no such thing as "non-intrusive" testing. For mock object testing, that means that you have to be able to inject a thread, or be able to control how the thread is made. Experience has taught me that almost all of the time, properly written/modular code is testable, and making untestable code testable improves its design in ways that expand beyond making it simply work in the test. That means either the queue that starts up reading is either a Runnable or if it makes threads, it takes a factory to make threads. If it is a Runnable, then you might be able to just run it directly, in which case your test is now single threaded. If it really must be in a thread, then you can make a wrapper around it to catch exceptions, cache them and return. If you have something that takes a thread factory, then make a thread with an appropriate UncaughtExceptionHandler, which would let you capture and cache the EasyMock exception to return when you "join" that thread. I'm sure any of the above techniques can be encapsulated into testing-code-only utility methods/classes to reuse them. Why there isn't any in JUnit I don't know. My personal preference is to run code that normally runs in threads but run it in a single thread if possible, because controlling things in a multi-threaded test is much harder and annoying. That eliminates the need to "capture" the exceptions in thread B to rethrow in A, and all of the boilerplate I described above. You might say "well it doesn't test for race conditions" or "the environment's not like the real one". Well you certainly can't guarantee that with multiple threads; a quad core will run it differently than a 2ghz dual core or differently on a continuous integration server running 5 builds at once. A better way might be to control the sequence of events, instead, but that can be hard based on the design. Jason objects to test an existing API. The idea is to be able to test an existing interface without changing the interface. The goal of using Mock objects in the unit testing is so that the existing interface could be validated, not to change the interface to accomidate the testing tool.</body>
  </mail>
  <mail>
    <header>Re: Re: Mock objects executing in a seperate thread</header>
    <body>If B isn't a Runnable or a Thread then he has to change the API. In order to do mock testing you have to have seams, which is places to inject mocks or other testing functionality. If the code is new B().processMessages(), then there's no way to get at those exceptions if it starts a thread that throws away all of the exceptions. but that's super hacky and changing global variables, and that would start a whole new thread about global JDK state that pollutes other tests unless you are really, really good about setUp/tearDown (referring to JUnit here). Although my suggestion still is if he has "start B; wait for B to be done" then I suggest making B a runnable and calling B.run() right in the test to eliminate threads and also the Runnable wrapper entirely. Jason</body>
  </mail>
  <mail>
    <header>Re: easyMock Question</header>
    <body>No, you can't a static method with EasyMock, at least not that I know of. I believe PowerMock can do it but I've never used it. You need to introduce a "seam" into the code. I'm presuming that the call to create AntennaMount is hidden inside of your unit under test. That is the problem -- you really should pass in an AntennaMount to that class (or a factory for one), and mock that. Don't mock the second level dependencies of a class, or you're really doing an integration test (unless that's what you want) and just making it harder on yourself. If AntennaMount is actually the class under test, then I don't get your question, because you would just pass mockANT to the constructor rather than call getDefault. Jason</body>
  </mail>
  <mail>
    <header>Re: easyMock Question</header>
    <body>Wow I feel dumb. I must be off today, for some reason I read that like AntennaType.getDefault(), thinking getDefault was like the common "getInstance" pattern. Wow, sorry about that, so disregard my message then. But in the code, the method is used before replay. It should be recorded and given a behavior first. But I don't think we know entirely what he is trying to do here? Jason I to than</body>
  </mail>
  <mail>
    <header>RE: easyMock Question</header>
    <body>Problem solved... I just stubbed things out. -----Original Message----- From: easymock@yahoogroups.com [mailto:easymock@yahoogroups.com] On Behalf Of Jason Winnebeck Sent: Thursday, October 07, 2010 1:34 PM To: easymock@yahoogroups.com Subject: Re: [easymock] easyMock Question Wow I feel dumb. I must be off today, for some reason I read that like AntennaType.getDefault(), thinking getDefault was like the common "getInstance" pattern. Wow, sorry about that, so disregard my message then. But in the code, the method is used before replay. It should be recorded and given a behavior first. But I don't think we know entirely what he is trying to do here? Jason I to than ------------------------------------ Yahoo! Groups Links</body>
  </mail>
  <mail>
    <header>Re: Replacements for setDefaultVoidCallable and expectAndDefaultReturn?</header>
    <body>I've tried some of the suggestions to no avail so let me ask this question differently with some pseduo code. So I have a Spring Controller method: public ModelAndView controllerMethod(HttpServletRequest request, ... ... ... ... //Inside of the method is a call to a void method The void method is: .. Now when I try to mock all of this up in my unit test the old way we did this was: When we update to 2.5.2 I replaced this with: expectLastCall(); //I've tried it with and without this expect call The problem with what I changed it to for 2.5.2 is that when I run the controller.controllerMethod(request, response) call followed by a verify(mock) So I debugged the code and it looks like when I call the controller's method and it hits the void method call it just walks right over it.  So I commented out the mock.voidMethod and replay(mock) calls and reran my test case and it passed just fine. Is this something new in 2.5.2 that I don't need to mock up the void method calls inside of the controller that I'm testing?  And if so, is this the replacement to having to use the deprecated setDefaultVoidCallble method that the older version of EasyMock had to call? 2.5.2.  I've been updating all of our deprecated code but recently I've come across two method calls that I can't figure out how to recreate with the updated version. methods.  I create my mock object and instead of running an expect around it I just run it normally like mock.method(value);  then I do a replay(mock); after it.  The problem is that when I run the actually controller I keep getting an AssertionError of expected: 1, actual 0 for my object.  This is before the verify(mock) method is even called. recreate it with a basic expect and .andReturn method but I get the same AssertionError of expect: 1, actual 0. Tom</body>
  </mail>
  <mail>
    <header>IMocksControl and JUnit Rule for automatic verify</header>
    <body>I tried out the new JUnit @Rule feature to setup an IMocksControl to automatically verify my mocks at the end of a test. It turns out that it works pretty well. The syntax ends up looking like this: There are a couple of interesting things to notice. If the object that you are testing allows the mocks to be provided through the constructor (i.e. constructor injection), then you can do away with the @Before method entirely. This will automatically call mocks.verify() at the end of your test. How often have you forgotten to verify your mocks? Well, now you don't have to. Additionally, it has to implicitly do mocks.reset() before the test. If you need more control over which IMocksControl to use, just add another constructor to EasyMockJUnitRule so you can do this: @Rule public Another nice point is that EasyMockJUnitRule runs before and after the @Before and @After methods. This way you can put things in @Before and @After to, for example, stub some of the mocked methods. I thought that this would be a nice addition to EasyMock. All you have to do is have EasyMockJUnitRule implement IMocksControl and org.junit.rules.MethodRule. To make it so EasyMock doesn't require JUnit on the classpath, just have it mark the JUnit dependency in the pom.xml as an optional dependency. As long as nobody tries to instantiate that class, they can still use TestNG, for example, just as they do today. The only other thing that this EasyMockJUnitRule object needs to be aware of is if it is in record mode. This way if a particular test doesn't every do mocks.replay(), it won't fail the test because. But this was handled by a simple boolean variable. So, what do people think?</body>
  </mail>
  <mail>
    <header>Re: IMocksControl and JUnit Rule for automatic verify</header>
    <body>The problem I've had with putting verify in the @After/teardown is when a test fails, it still runs the teardown method. This often causes the verify to fail because the test did not run to completion. So the error reported by JUnit is that the "verify" failed, and it masks the original error. Does this still happen with the @Rule? Jason automatically verify my mocks at the end of a test.</body>
  </mail>
  <mail>
    <header>Re: IMocksControl and JUnit Rule for automatic verify</header>
    <body>I have tried the exact same thing that you just described. The method that I describe here does not suffer from this problem. If any assertion fails, or any other exception occurs, the verify does not occur. This way you don't lose the original exception or assertion failure. It just works. automatically verify my mocks at the end of a test.</body>
  </mail>
  <mail>
    <header>Re: IMocksControl and JUnit Rule for automatic verify</header>
    <body>Judging from the lack of responses, this must not be very useful. If it ever becomes important, just let me know. I would like to submit it as an enhancement.</body>
  </mail>
  <mail>
    <header>Trying to EasyMock BufferedReader to produce IOException</header>
    <body>All, The code below, in two classes, seems like most of the answer to mocking the BufferedReader to produce an IOException.  When executed  as a JUnit test, it reports: java.lang.IllegalStateException: no last call on a mock available at org.easymock.EasyMock.getControlForLastCall(EasyMock.java:202) ... Please give it a run and let me know what I'm doing wrong. Thanks, Ray</body>
  </mail>
  <mail>
    <header>Re: Trying to EasyMock BufferedReader to produce IOException</header>
    <body>Thanks for your help Henri!</body>
  </mail>
  <mail>
    <header>Easier argument matchers</header>
    <body>I've always found it to be a pain to write EasyMock IArgumentMatcher classes. Then I noticed easymock-propertyutils, and it gave me an idea. What if there was an easier way writer matchers, and have them survive refactorings. I have to admit, with the addition of the Capture objects, I don't usually need argument matchers, but there are times when they are still necessary. Wouldn't it be nice if I could write this: MyParameter param = createArgumentMatcher(MyParameter.class); // new API expect(some.methodCall(eq(param, param.getString(), expect(some.methodCall(eq(param, param.getString(), What this would do is create a matcher that matches param when param.toString() equals "hi". Another matcher is created to match when param.toString() equals "there". Notice how param is a matcher that is a proxy object (just like mocks themselves) used for recording what method the matcher needs to call, and what the expected value is. You could even put multiple tests on the matcher like this: expect(some.methodCall(and(eq(param, param.getString(), "hi"), eq(param, This creates a matcher for param that matches when param.getString() equals "hi" and param.getInt() equals 1. You could even take this a step further so that you could dig into sub-properties: expect(some.methodCall(eq(param, param.getParent().getId(), Notice how this is going multiple levels deep to match param.getParent().getId(). While we're at it, why not add a new static method called argThat which takes Hamcrest matchers: expect(some.methodCall(argThat(param, param.getString(), Of course, this would require some additions to EasyMock. For one, that createArgumentMatcher(Class&amp;lt;?&amp;gt; classToMatch) method, as well as additional versions of all the static methods that create matchers today, like eq, lt, ... The things I like is that I don't have to write any matcher classes, and it will survive some types of refactoring. I don't think that this would have to change the core of EasyMock in any way. I don't have anything like this written yet, but I was wondering if others thought that this would be useful.</body>
  </mail>
  <mail>
    <header>How to "expect" call on Constructor i.e. How to test if constructor is called</header>
    <body>Hi All, I am very new to easymock and I have a very small query. I want to write a test which calls a method whose sole purpose is create an instance of a given class given a certain condition i.e. the method under test calls the constructor of a given class. However, I am not too sure how to go about telling my mock to expect a call on a constructor. At the moment, I am doing something akin to what is demonstrated below but I keep getting the exception "java.lang.IllegalStateException: no last call on a mock available". I was wondering if one you will be kind enough to point me in the right direction what I want to know is, how do I tell my mock to "expect" a method call on its concrete class's constructor? The scenario is as follows: [code] //**** At this point, how do I tell my mock(myObjMock) to expect a call on its concrete class's (MyObjectImpl) Constructor? //**** the  code below is incorrect and throws the "java.lang.IllegalStateException: no last call on a mock available" //*** At the moment, I dont know how to tell the mock to expect a call on the constructor // createMyObject just calls the Constructor of MyObjectImpl // and returns an instance of IMyObjectImpl see code below [/code] In ClassUnderTest [code] ... //Somewhere in ClassUnderTest // Assume that createMyObject(int id) is a member of the IMyObject interface // ***** At this point, how how do I tell my mock from the test method above // **** to expect a call on the contructor of MyObjectImpl? if (some_condition_is_met ) else ... [/code] I hope its clear as to what I am trying to achieve. Please let me know if you need more clarification. Regards quophyie</body>
  </mail>
  <mail>
    <header>Re: Create mock object using a constructor with parameters</header>
    <body>Hi Tim I have come across this thread as I am having problems trying to mock a call to a constructor . I see you did say that you have written certain methods that allow you to achieve this. Albeit an old thread, you did attach the code to the thread but it seems that it is no longer available. I was wondering whether you'll be able to provide me with that code if that was at all possible?. regards George puter+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+\ computer+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=zb3sFxhi-tmca0EDuSrdbg tware&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer+monitoring+\ software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=I7EBHfo5x5ryPp_cfIwsbg omputer+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Fre\ e+computer+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=oV1vUZqKIG_WNHYmy3y9mA 1=Computer+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=\ Free+computer+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=RishPPW2ja69fF9T9jDp4g easymock-unsubscribe@yahoogroups.com&amp;lt;easymock-unsubscribe@yahoogroups.com?subjec\</body>
  </mail>
  <mail>
    <header>Re: Trigger wanted (or alternative suggestion)</header>
    <body>Use expectLastCall with methods returning void. Anything you could use with expect works with expectLastCall. Jason &amp;gt; The underlying problem seems to be that flush() having no return value &amp;gt; and no parameter gives me no opportunity to execute code! &amp;gt; summary: &amp;gt; -in methods with parameters you can execute code by using/extending Capture &amp;gt; -in methods with a return value you can execute code by using/extending &amp;gt; IAnswer &amp;gt; -in methods without paramter and a return value, you can't execute code &amp;gt; mimicing functionalty not present because you use a mock at this point &amp;gt; (or am i mistaken here???)</body>
  </mail>
  <mail>
    <header>Does EasyMock have a test-isolation problem?</header>
    <body>Hi, I just started working with EasyMock on a big development project and I am very impressed. I do, however, have some difficulties when I integrate my mock-tests into our test suite. It seems that the different tests affect each other. If the first easymock test, A, (located in one class) fails then a separate easymock test, B, (located in another class) will also fail. The error message in test B is something like: "...2 matchers expected, 0 recorded.." When debugging, I can see that test B is looking for the two matchers that were defined in test A. In the source code for test B, there are, however, no matchers expected. It seems that even though I'm using different mock controls to create my mocks, the matchers are somehow carried on to the next easymock test. In a test suite with 1000+ tests, that is really a show-stopper, so I hope someone here has experienced a similar problem and can provide me with a solution. -- Anders PS. I'm using v. 2.5.2 and the test suite runs in a Eclipse-Plugin environment.</body>
  </mail>
  <mail>
    <header>Usage of Capture</header>
    <body>From 2.4, EasyMock introduced Capture I have used it. I introduce two samples of using Capture: 1. Enable simple getter/setter for mock object, using capture and IAnswer together. 2. Enable accept a visitor on mock object</body>
  </mail>
  <mail>
    <header>Capture the boolean primitive</header>
    <body>There are capture methods for primitive arguments in EasyMock class. public static int capture(Capture&amp;lt;Integer&amp;gt; captured) public static long capture(Capture&amp;lt;Long&amp;gt; captured) ...and so on... But why EasyMock doesn't have the capture method for boolean primitive type? smth like: public static boolean capture(Capture&amp;lt;Boolean&amp;gt; captured) What is the correct way for boolean argument capturing?</body>
  </mail>
  <mail>
    <header>Re: Capture the boolean primitive</header>
    <body>I need it when method has several arguments and one of them is boolean primitive. Then I have to capture all. It seems, it is not allowed to capture one argument and do not capture another argument. Am I right?</body>
  </mail>
  <mail>
    <header>Re: Capture the boolean primitive</header>
    <body>here's an example long catcher @Override // TODO make sure they pass in a long, ok? @Override // never get here, it's the error case</body>
  </mail>
  <mail>
    <header>suggestion: disallow returning null for a method that returns a boolean</header>
    <body>Currently if you &amp;lt;cough&amp;gt; accidentally write something like expect(a.foo()).andReturn(null); // foo is typed to return a boolean you run into a seemingly surprising error message where a NullPointerException is thrown when the method is called, later, despite nothing *looking* like it's null. (i.e. this line, later: boolean b = a.foo(); // throws a NullPointerException, despite a not being null This causes some confusion and frustration. Proposal: disallow returning null if a boolean/long/int is the return type (if that's even possible). Thanks for easymock! -r</body>
  </mail>
  <mail>
    <header>Re: suggestion: disallow returning null for a method that returns a boolean</header>
    <body>Thanks for your help there. -r</body>
  </mail>
  <mail>
    <header>Error attempting to create a mock using classextension</header>
    <body>I'm trying to use EasyMock class extension 2.5.2 and cglib 2.2 within JDeveloper 11g. On trying to create a mock, I get the following exception: java.lang.NoClassDefFoundError: org/objenesis/ObjenesisHelper org.easymock.classextension.internal.ObjenesisClassInstantiator.newInstance(Obje\ nesisClassInstantiator.java:23) org.easymock.classextension.internal.ClassProxyFactory.createProxy(ClassProxyFac\ tory.java:229) com.symmetry.dashboard.panels.view.debtors.backing.DebtorsTest.testProcessClickO\ nPie(DebtorsTest.java:26) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java\ :44) org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:\ 15) org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:4\ 1) org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20\ ) org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:73\ ) org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:46\ ) Caused by: java.lang.ClassNotFoundException: org.objenesis.ObjenesisHelper It looks like initialisation of some static field within ObjenesisHelper is failing, causing a ClassNotFoundException. Any ideas on what the problem might be? Thanks, Joe</body>
  </mail>
  <mail>
    <header>sniff...not enough matchers...sniff</header>
    <body>Question. Currently I sometimes get messages like... Testcase: withDaxAndMigrationTapesItShouldFinish(org.familysearch.digitalarchive.tapeinges\ treader.TapeReaderPollerTest):        Caused an ERROR 8 matchers expected, 7 recorded. for example when I accidentally put in a null instead of an eq(null) Would it perhaps be possible to avoid this error by assuming the eq(whatever) matcher for items passed in that aren't matchers?  Just wondering out loud. Thanks. -r</body>
  </mail>
  <mail>
    <header>Re: sniff...not enough matchers...sniff</header>
    <body>If you want to find a matcher can match any value, I think Capture is what you want. withDaxAndMigrationTapesItShouldFinish(org.familysearch.digitalarchive.tapeinges\ treader.TapeReaderPollerTest):</body>
  </mail>
  <mail>
    <header>Missing dependency from EasyMock CE documentation</header>
    <body>Hi Henri, I've just noticed that the EasyMock CE documentation at  includes dependency information in the Requirements section. However, this hasn't been updated since EasyMock CE stopped bundling Objenesis, and this dependency isn't mentioned on that page (it's implied much further down the page). Am I right in thinking that it depends on Objenesis 1.2? Many thanks, Neil.</body>
  </mail>
  <mail>
    <header>Mocking 'toString' methods.</header>
    <body>I find myself mocking the 3rd party library Apache XmlBeans and in particular the interface XmlObject. A main method on XmlObject is 'toString', which prettyprints the XML the object represents. Currently I can't mock 'toString' with EasyMock: it is treated like a 'final' method, as from what I've read on this list, 'toString' is used to get information out of the proxy class whent he proxy is in an error state. Is it a potentiallity that, in future versions of EasyMock, 'toString' be mockable on interfaces, and that perhaps it's behavior changes dependent on wether the proxy is in an error state or not? When not in an error state, the expected value is returned, when in an error state, proxy state information returned? Thanks for the great software! Martin</body>
  </mail>
  <mail>
    <header>Re: Mocking methods that use generics for strong typing</header>
    <body>Again Henri, thank you very much for your informative reply! Your response caused me to look again at the available information on Java generics and on the ability to use generic wildcards (my initial design) and generic methods (your first suggestion). Refactoring my code to use a generic methods works fine and also agrees with EasyMock too. This was also a new way of approachng the problem for me - very illuminating. Thank you, Martin</body>
  </mail>
  <mail>
    <header>Replacements for setDefaultVoidCallable and expectAndDefaultReturn?</header>
    <body>So we've been using an older version of EasyMock and recently upgraded to 2.5.2. I've been updating all of our deprecated code but recently I've come across two method calls that I can't figure out how to recreate with the updated version. 1.  setDefaultVoidCallable - We have spring controllers that access void methods.  I create my mock object and instead of running an expect around it I just run it normally like mock.method(value);  then I do a replay(mock); after it.  The problem is that when I run the actually controller I keep getting an AssertionError of expected: 1, actual 0 for my object.  This is before the verify(mock) method is even called. 2. expectAndDefaultReturn - The old method is deprecated and I've tried to recreate it with a basic expect and .andReturn method but I get the same AssertionError of expect: 1, actual 0. Any ideas or information on what I'm doing wrong would be great.  Thanks. - Tom</body>
  </mail>
  <mail>
    <header>Re: Replacements for setDefaultVoidCallable and expectAndDefaultReturn?</header>
    <body>I'm not a user of EasyMock for long enough to remember the expectAndDefaultReturn -- but is this the same as expect( ).andStubReturn? What does setDefaultVoidCallable do? Your description of just calling the void method directly to record it does work in current EasyMock: verify( mock ); //pass, we did get a single call... Jason 2.5.2.  I've been updating all of our deprecated code but recently I've come across two method calls that I can't figure out how to recreate with the updated version. methods.  I create my mock object and instead of running an expect around it I just run it normally like mock.method(value);  then I do a replay(mock); after it.  The problem is that when I run the actually controller I keep getting an AssertionError of expected: 1, actual 0 for my object.  This is before the verify(mock) method is even called. recreate it with a basic expect and .andReturn method but I get the same AssertionError of expect: 1, actual 0. Tom</body>
  </mail>
  <mail>
    <header>Re: Question about IMocksControl.verify()</header>
    <body>Ok, thanks for the feedback. I should probably ignore finalize calls.</body>
  </mail>
  <mail>
    <header>EasyMock 2.5.2 was just released</header>
    <body>Hi, Basically a maintenance release with the following changes: However, the second one is a new feature. A lots of people were asking about a way to replay/verify all mocks in one shot. This class meant to help you do that. Have a look to the SupportTest in the samples to know how to use it. I'm looking forward for your feedback. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: EasyMock 2.5.2 was just released</header>
    <body>Dear Henri, Can EasyMock 2.4 Class Extension (2008-08-30) be used in combination with EasyMock 2.5.2? Its release notes only specify EasyMock 2.4 as a dependency. Kind regards, Martin</body>
  </mail>
  <mail>
    <header>EasyMock 2.5.2 feedback, varargs</header>
    <body>I'm having a problem with mocking a method which uses varargs: The trouble is that the varargs are not required to be in a specific order.  So, these two calls are equivalent: My problem is that even if I create my own argument matcher (which matches the varargs Array) like this: then EasyMock will throw an exception like: It seems to do this because the method is (internally) called as indicated above, ie. with 2 separate arguments, instead of just an array.  Both of which are valid for vararg-style methods. Is there any solution for this kind of problem?  We'd prefer not to have to adjust production code to play nicely with tests like this. Best Regards, John Hendrikx</body>
  </mail>
  <mail>
    <header>Re: EasyMock 2.5.2 feedback, varargs</header>
    <body>Really what you are trying to pass is a Set, then. You could make your own argument matcher that takes all of the elements in the array, puts them into a Set, then compares the sets for equality. Attention will be needed to what the requirement is that you want to enforce if you have two of the same lunch items (duplicates). Jason</body>
  </mail>
  <mail>
    <header>Re: EasyMock 2.5.2 feedback, varargs</header>
    <body>Yes, I created my own argument matcher as I said in my post, however it gives me the following exception when two LunchItems are passed: This is because in the expect call I'm only giving one parameter (my argument matcher which matches against the array you get from a varargs argument).  However, it seems that each LunchItem passed is counted as an argument.  So passing 15 LunchItems would give me: The expect call I'm using looks like this: where aryContentEq will check for the existance of the items without enforcing a certain order. Varargs constructs like this are used fairly commonly to pass options to methods as well, like for example in the new NIO framework, where copyTo() and moveTo() are defined like: Where CopyOption is an enum, allowing you to pass 0 or more options. The order of these is irrelevant.  It is I think not possible to write a correct expect for this with EasyMock at this time. I hope this clarifies it a bit further. --John</body>
  </mail>
  <mail>
    <header>Re: EasyMock 2.5.2 feedback, varargs</header>
    <body>Thank you, using a Capture works for me.  Although I'm not 100% sure it is allowed to capture multiple values with a Capture, but it seems to Use it like this: Thanks for the help :) Regards, John Hendrikx</body>
  </mail>
  <mail>
    <header>Re: EasyMock 2.5.1</header>
    <body>Will EasyMock Class Extension follow the move to Apache 2 license? Regards, Stevo.</body>
  </mail>
  <mail>
    <header>Matcher &amp;amp; multiple calls</header>
    <body>Below is a test I have knocked up that uses its own matcher. I know in this case I could use a standard matcher but in my real code I need a more complicated one. The test passes - tick VG. The issue is that there appears to be an extra call to IArgumentMatcher.matches() method that returns false, and yet the test passes. Tried with  2.4 and 2.5.1 The logger output I get is:   30-09-2009 16:12:23 [main] ERROR - MATCH - expected[aa], actual[aa]   30-09-2009 16:12:23 [main] ERROR - MISMATCH - expected[aa], actual[bb]   30-09-2009 16:12:23 [main] ERROR - MATCH - expected[bb], actual[bb] So the question is why am I getting the MISMATCH line, and have I done something incorrectly ? The test code is: /**  *  */ //test method @Override @Override /** * @see org.easymock.IArgumentMatcher#matches(java.lang.Object) */        mLogger.error("MATCH - expected[" + mExpected + "], actual[" +      mLogger.error("MISMATCH - expected[" + mExpected + "], actual[" + /**     * @see org.easymock.IArgumentMatcher#appendTo(java.lang.StringBuffer)     */ -- Regards Bill Comer blog:</body>
  </mail>
  <mail>
    <header>An idea to simplify EasyMock usage that I've used in my own work</header>
    <body>Hi, I've used EasyMock quite extensively in my development.  To make it easier for me to use EasyMock, I created one simple class (which acts as a superclass for my tests) that has significantly reduced the amount of code I have to write to use EasyMock. I'd like to share my ideas with you - and will share my code, too, if you think it's worthwhile. Here's a quick before-and-after creating my new class: Before, I'd repeat these familiar EasyMock steps: - Then, in each test method: Now (After), I no longer write step 0.  That's all done within the superclass. Step 3 is now a single method invocation in each of my tests (and it's the same method in every test class).  I no longer write step 5 anymore, either - that's done by the superclass, too. And, the code understands interfaces vs class mock types and uses the EasyMock or classextension implementations as appropriate. I have some ideas on how to make it even simpler than I have so far but haven't needed those features yet. If you think you might be interested, please let me know and I'd be glad to discuss it further with you. Regards, Al</body>
  </mail>
  <mail>
    <header>EasyMockSupport for EasyMock CE</header>
    <body>Hi, I'm a big fan of my own EasyMockSupport class but was suffering from the lack of class extension support. So, while waiting for EasyMock CE to be delivered, I've put an implementation with class support in the file section ( It's roughly tested but should meet your needs. It sure meets mines. Cheers, Henri</body>
  </mail>
  <mail>
    <header>How to mock the objects which are created by "new" statement in the testing method?</header>
    <body>hi all, I'm a freshman on EasyMock.  There is a question about how to use EasyMock in our test. First, please look at the example source: /*-----------------------------------------------------------------*/ /*---------------------------------------------------------------*/ Question is: in this case, how can I use EasyMock to mock the class B's object in the A.ma()? ¡ùI'm using EasyMock 1.2, EasyMock 1.2 ClassExtension, J2SE1.4.2_19, JUnit3.8.2 Best regards. Guo</body>
  </mail>
  <mail>
    <header>Re: How to mock the objects which are created by "new" statement in the testing method?</header>
    <body>2009/11/12 Guo Tianchong &amp;lt;guotc@...&amp;gt;: our test. A.ma()? JUnit3.8.2 Hi Guo, In this case, you can't use any mocking framework to create a mock of class B (as far as I know). The easiest way to do it is to add a parameter of type B to the method A.ma, so the code becomes something like this: ... Then in the production code, you can call and in the test code, you can call something like Of course, mocking a void method doesn't really demonstrate the power of using a mocking framework, but hopefully this will give you a start. HTH, Neil.</body>
  </mail>
  <mail>
    <header>How can I solve this problem about "super" &amp;amp; "this" keywords?</header>
    <body>hi all, Please look at my case first: /*---------------------------¢­¢­¢­¢­¢­¢­¢­¢­-----------------------------\ ----*/ /*---------------------------¢¬¢¬¢¬¢¬¢¬¢¬¢¬¢¬-----------------------------\ ----*/ Then, I isolated the "invoke()" &amp;amp; "setTarget()" to test "execute()" like this: /*---------------------------¢­¢­¢­¢­¢­¢­¢­¢­-----------------------------\ ----*/ /*---------------------------¢¬¢¬¢¬¢¬¢¬¢¬¢¬¢¬-----------------------------\ ----*/ When I run this testcase, the following error occured: junit.framework.AssertionFailedError Unexpected method call invoke(): ...... ...... ...... But when I deleted the "super" &amp;amp; "this" keywords in execute() method, then this testcase passed. If I can't delete the "super" &amp;amp; "this" keywords, does anybody know how can I solve this problem? Best Regards. Guo</body>
  </mail>
  <mail>
    <header>Re: Cannot throw an IOException on last method called?</header>
    <body>In this case I don't agree on the call for refactoring. If order to test the refactored method I should add its signature to the interface, but this would be a typical private (or protected) method. This would seem to me refactoring for the sake of testing...While testing is useful writing code explicitly for testing sometimes isn't. You are absolutely right about the check on the writer. Thanks, I added it. The clearDocumentsIndexCache is related to this method since this method writes the content of the cache to disk and when it's done, the cache is cleared from memory. I do agree though that probably its best place would be in the "normal use case scenario", however this is a business decision. Nothing would restrict this method from being in the finally clause. Its outcomes are just to deep clean a Map and therefore I can't see how this could throw an exception, and even if it did, I'd prefer an exception to be thrown on this activity and leave the writer open than ensuring the writer to close. And in fact the approach that I've always seen in code is just to log a warning when the closure of an input/output stream fails, not to throw an exception. This sounds interesting and exactly what I'd need. Thanks.</body>
  </mail>
  <mail>
    <header>Getting started - documentation</header>
    <body>I am deciding beween a few mock frameworks and Easymock is one of them.  However the documentation is really confusing me.  Is there any better example code to look at instead of Collaborator and listener.  Myabe use something simple like a Person class or something realistic like an action class and service?  Seriously my head hurts from looking at all that. Thx</body>
  </mail>
  <mail>
    <header>Newbie Question: Mocking setter methods</header>
    <body>I've run into an interesting issue that I can't seem to find an answer for.  I have a method I am trying to test that contains a set method (myObject.setVariable(variable)).  myObject is a mock created in my test. Easymock seems to blow up when I use the mock at the point of the setter being called. Is there a way to indicate to the mock object to accept an input variable when a call is made to a mocked method? Thanks in advance. MiKey</body>
  </mail>
  <mail>
    <header>Re: Newbie Question: Mocking setter methods</header>
    <body>Thanks.  I knew I was missing it somehow.  I get the idea now.  Appreciate the wakeup call :)</body>
  </mail>
  <mail>
    <header>Re: AssertionError: Unexpected method call happening in thread?</header>
    <body>I think I answered my own question... I understand that once a mocked object is in the "replay" state that any unexpected method call results in an AssertionError.  What I think I can do to work around this is have my Runnable trap the Exception and then allow my test to later use it to assert if any exceptions did in fact occur. I guess it would be cool if EasyMock had a way of "delaying" so to speak AssertionErrors so and then act on any encountered exceptions when you are ready to deal with them.</body>
  </mail>
  <mail>
    <header>Re: HowTo: Record getters, setters in Easymock 1.2</header>
    <body>This sounds like the basic EasyMock operation? Are you asking about just mocking get methods of an interface? //run your code -- inf.getSomething() will return 5 the first time it is //called. //If you want to ensure the get was called:</body>
  </mail>
  <mail>
    <header>Re: HowTo: Record getters, setters in Easymock 1.2</header>
    <body>2009/8/14 Jason Winnebeck &amp;lt;addr2@...&amp;gt;: //called. You can't do this in 1.2. It doesn't support generics, so the syntax is very different. Rahul, is there any reason you can't update to a more recent version of EasyMock? If you can't update, look at   still using a Java version earlier than Java 5. Also, posting the code that you currently have and including the detailed stack trace of any exception will help us to help you much quicker. Without this, we're taking a stab in the dark... Cofion/Regards, Neil.</body>
  </mail>
  <mail>
    <header>Re: Strange behavior mocking restlet. [2 Attachments]</header>
    <body>Wow, that was tricky. - Client extends Uniform - Uniform implement handle(Request request) as a final method - Final methods can't be mocked. Their normal behavior is called - Uniform.handle calls handle(Request request, Response response) - So it's handle(Request request, Response response) that is recorder and it takes 2 parameters - Thus the error since you only pass one matcher You can workaround this by - Using class instrumentation removing the final. - Calling the method with two parameters directly - Mock the method with two params instead (but keep calling the one with one params) Personally, I'll pick the last solution. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Testing anonymous classes</header>
    <body>Hi I am using EasyMock for testing some GWT code (google web toolkit). GWT is mostly an asynchronous programming environment for UI.  It has lots of things like ClickHandlers, etc. for buttons, and these are most often setup as anonymous classes. Consider the following snippet: I'm having a hard time figuring out how to test something like this. That is where I'm stuck - it passes an anonymous class as the parameter.  I could make it not be an anonymous class, and instead use a getter method: But this does not work in the test case, b/c I call #getHandler() in the mock before the Presenter ctor is called: so, this means I'd have to make the handler a static reference, and make the #getHandler() method static, but this causes some possible ugly side-effects in my handler implementations. Is there a good way around this problem?</body>
  </mail>
  <mail>
    <header>Re: Testing anonymous classes</header>
    <body>Hi, Here it seems your goal is just to make sure a ClickHandler is added. You don't really care which one since it's an inner class and so it's part of the inner implementation of the class. So I think I would just do something like: or // if addClickHandler isn't type to take a ClickHandler in parameter. If you really want to have a look at the final ClickHandler, you can use a capture matcher to get it. Cheers, Henri</body>
  </mail>
  <mail>
    <header>IllegalStateException : no last call on a mock available - why?</header>
    <body>The mocked class here is  This promptly throws: java.lang.IllegalStateException: no last call on a mock available at org.easymock.EasyMock.getControlForLastCall(EasyMock.java:202) at org.easymock.EasyMock.expect(EasyMock.java:183) Why?</body>
  </mail>
  <mail>
    <header>Re: IllegalStateException : no last call on a mock available - why?</header>
    <body>You're absolutly right. On Thu, Aug 27, 2009 at 11:50 PM, Stephen Duncan</body>
  </mail>
  <mail>
    <header>IllegalStateException when using easymock and maven surefire plugin</header>
    <body>My tests all run from within eclipse and from Ant, but I am trying to migrate to Maven and I have a confusing problem. For any test that uses the org.easymock.classextension classes, I get the following stack trace (or similar): java.lang.IllegalStateException: Unknown callback class org.easymock.classextension.internal.ClassProxyFactory$1 at net.sf.cglib.proxy.CallbackUtils.getGenerator(CallbackUtils.java:102) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:314) at net.sf.cglib.proxy.Enhancer.createClass(Enhancer.java:278) at org.easymock.classextension.internal.ClassProxyFactory.createProxy(ClassProxyFac\ tory.java:107) at org.easymock.internal.MocksControl.createMock(MocksControl.java:51) at org.easymock.classextension.EasyMock.createMock(EasyMock.java:46) at com.dbo2.pipeline.model.safety.inspections.UpdateInspectionTypeAssociationsTest.\ setUp(UpdateInspectionTypeAssociationsTest.java:53) at junit.framework.TestCase.runBare(TestCase.java:128) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:120) at junit.framework.TestSuite.runTest(TestSuite.java:230) at junit.framework.TestSuite.run(TestSuite.java:225) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:585) at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:140) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:127) at org.apache.maven.surefire.Surefire.run(Surefire.java:177) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:585) at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:345) at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009) Since the ClassProxyFactory is in the stack trace itself, I don't know how it could be missing.  Is the $1 the problem and if so, what can I do about it?</body>
  </mail>
  <mail>
    <header>Re: IllegalStateException when using easymock and maven surefire plugin</header>
    <body>That's weird. My guess would be that you are not using the right version of cglib (version 1 might be in the classpath, try mvn dependency:tree to know what you are using). Otherwise, can you tell me the EasyMock version you are using and maybe provide a test case and a pom? Thanks, Henri org.easymock.classextension.internal.ClassProxyFactory.createProxy(ClassProxyFac\ tory.java:107) com.dbo2.pipeline.model.safety.inspections.UpdateInspectionTypeAssociationsTest.\ setUp(UpdateInspectionTypeAssociationsTest.java:53) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:140) org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:127) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:345)</body>
  </mail>
  <mail>
    <header>Re: IllegalStateException when using easymock and maven surefire plugin</header>
    <body>Yes. Use cglib 2.1_3. Having both can really mess the things up. org.easymock.classextension.internal.ClassProxyFactory.createProxy(ClassProxyFac\ tory.java:107) com.dbo2.pipeline.model.safety.inspections.UpdateInspectionTypeAssociationsTest.\ setUp(UpdateInspectionTypeAssociationsTest.java:53) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(Abstra\ ctDirectoryTestSuite.java:140) org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirec\ toryTestSuite.java:127) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBoote\ r.java:345) org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)</body>
  </mail>
  <mail>
    <header>Re: Question about IMocksControl.verify()</header>
    <body>Hi, It is impossible for EasyMock to expect a method that isn't recorded. So it must be. One possibility is that it's hidden in a final or private method that can't be mocked. Another which is that there's some multithreading taking place. I suggest to upgrade to EasyMock 2.5.x which will give you a better error message and/or result. If it still not working, I'll need a test case to have a look. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: Question about IMocksControl.verify()</header>
    <body>I should have told you. Naming mocks can be really useful. However, this can't be caused by not recording anything. It could be that finalize is recorded because the object is recycled during recording phase... When the mock control is verified it might occurs. But that's quite unlikely since the mock should be referenced in some way be the mock controls. Still, finalize needs to be implemented somewhere.</body>
  </mail>
  <mail>
    <header>Re: Question about IMocksControl.verify()</header>
    <body>Good to know. There's no WeakReference from as far as I remember. Since you solved your issue, I'll keep this as a mystery for now. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: Easy Mock on Java EE Application Server</header>
    <body>I uploaded the Example Application on the Files-area. "EasymockEjb.zip". Check out the Javadoc for "EasymockEjbTest\src\easymocktest\EasyMockTest.java". It contains the prerequisites for how to deploy the EAR and runt the TestCase. Erik com.sun.corba.ee.impl.logging.ORBUtilSystemException.valuehandlerReadException(O\ RBUtilSystemException.java:8428) com.sun.corba.ee.impl.encoding.CDRInputStream_1_0.readRMIIIOPValueType(CDRInputS\ tream_1_0.java:973) com.sun.corba.ee.impl.encoding.CDRInputStream_1_0.read_value(CDRInputStream_1_0.\ java:1052) com.sun.corba.ee.impl.encoding.CDRInputStream.read_value(CDRInputStream.java:475\ ) com.sun.corba.ee.impl.io.IIOPInputStream.inputObjectField(IIOPInputStream.java:1\ 974) com.sun.corba.ee.impl.io.IIOPInputStream.inputClassFields(IIOPInputStream.java:2\ 199) com.sun.corba.ee.impl.io.IIOPInputStream.inputObject(IIOPInputStream.java:1211) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25)</body>
  </mail>
  <mail>
    <header>Re: Easy Mock on Java EE Application Server</header>
    <body>Thank you Henri, Lots of valuable information. Fun to see that you made it work on WebLogic. We tried it on the new JDK (update 14) but the problem remains. We have initiated contact with people on Sun to see if we can track the problem together. I'll update this thread with any further information. What do you think about our usage of easymock? Do you beleive that EJB support is something to add? As a first step one could include deployment of the delegator and upload/download of mock objects as part of the framework. /Erik com.sun.corba.ee.impl.logging.ORBUtilSystemException.valuehandlerReadException(O\ RBUtilSystemException.java:8428) com.sun.corba.ee.impl.encoding.CDRInputStream_1_0.readRMIIIOPValueType(CDRInputS\ tream_1_0.java:973) com.sun.corba.ee.impl.encoding.CDRInputStream_1_0.read_value(CDRInputStream_1_0.\ java:1052) com.sun.corba.ee.impl.encoding.CDRInputStream.read_value(CDRInputStream.java:475\ ) com.sun.corba.ee.impl.io.IIOPInputStream.inputObjectField(IIOPInputStream.java:1\ 974) com.sun.corba.ee.impl.io.IIOPInputStream.inputClassFields(IIOPInputStream.java:2\ 199) com.sun.corba.ee.impl.io.IIOPInputStream.inputObject(IIOPInputStream.java:1211) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25)</body>
  </mail>
  <mail>
    <header>Re: EasyMock 2.5</header>
    <body>Hi Henri, I submitted a patch to improve partial mocking some time ago, well over a year now. It allows methods to have expectations set on them whilst in record mode simply by calling the method. The patch should still be accessible in the files area. Will you accept this patch for 2.5? Regards Ben -- *Ben Hutchison Senior Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 534 |</body>
  </mail>
  <mail>
    <header>Re: Easy Mock on Java EE Application Server</header>
    <body>On the way trying to track the problem with the Sun-guys you could maybe help us with some information. We have a ClassCastException between following classes: - org.easymock.internal.ObjectMethodsFilter - org.easymock.internal.MethodSerializationWrapper Are the classes related in some way? If they are we maybe are facing a ClassLoader problem. /Erik com.sun.corba.ee.impl.logging.ORBUtilSystemException.valuehandlerReadException(O\ RBUtilSystemException.java:8428) com.sun.corba.ee.impl.encoding.CDRInputStream_1_0.readRMIIIOPValueType(CDRInputS\ tream_1_0.java:973) com.sun.corba.ee.impl.encoding.CDRInputStream_1_0.read_value(CDRInputStream_1_0.\ java:1052) com.sun.corba.ee.impl.encoding.CDRInputStream.read_value(CDRInputStream.java:475\ ) com.sun.corba.ee.impl.io.IIOPInputStream.inputObjectField(IIOPInputStream.java:1\ 974) com.sun.corba.ee.impl.io.IIOPInputStream.inputClassFields(IIOPInputStream.java:2\ 199) com.sun.corba.ee.impl.io.IIOPInputStream.inputObject(IIOPInputStream.java:1211) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25)</body>
  </mail>
  <mail>
    <header>Re: Array comparison weirdness</header>
    <body>Hello Stefan, This should not work! The problem here is that arr1 and arr2 are equal. If you use expectLastCall().atLeastOnce() on the first expectation, the second expectation would never been used, as the first one will always match for this parameter. So EasyMock would always fail, as the expectations are used up in the order of definition. To prevent this from happening, EasyMock fails with an exception with the (maybe too cryptic message) 'last method called on mock already has a non-fixed count set'. Hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>Re: Array comparison weirdness</header>
    <body>Hello Stefan, it may make sense overriding equals(), while hashCode() from the superclass should be fine (it throws an exception ;)). But I find it hard to think of a failing test in this scenario which is driven by a requirement. Thanks for your feedback, Tammo</body>
  </mail>
  <mail>
    <header>Mocking Super Methods</header>
    <body>I'm trying to test a class.  One of the class's methods makes a call to the "super" version of the same method.  Actually, another person details a perfect example here:  I have been unable to figure out how to mock this super call.  I also share the same concerns as the person who has posted in the comments in that we're simply moving the testing gap to another location and not actually testing expectated behavior (I'm trying to get to 100% coverage). Does EasyMock provide a facility to get around this? Thanks! Leo</body>
  </mail>
  <mail>
    <header>Re: Mocking Super Methods</header>
    <body>Ummm...I guess I could use composition.  Another (framework) class is expecting a class that inherits from the super class. I suppose I could inherit from that super class and then inject the same super class, but that feels very hack-ish to me. Don't get me wrong:  I'm all about composition and injection vs inheritance, but this inheritance is being pushed upon us in this case.  I was just hoping there was some fancy EasyMock partial mock I could create. I've tried mocking the method with a ThisClass.class.getSuperclass().getMethod("methodName"), but the super.methodName method isn't recognized during execution.</body>
  </mail>
  <mail>
    <header>Re: Mocking Super Methods</header>
    <body>Assuming I'm using the classextensions library, would I be able to then? Doesn't that latter approach just move the gap in coverage to another location? I still can't test the behavior in innerFoo().</body>
  </mail>
  <mail>
    <header>Re: Mocking Super Methods</header>
    <body>Ive been in your situation before. My sympathies. Powermock is a good option for you. Its built over Easymock. -Ben "super" version of the same method.  Actually, another person details a perfect example here: the same concerns as the person who has posted in the comments in that we're simply moving the testing gap to another location and not actually testing expectated behavior (I'm trying to get to 100% coverage). -- *Ben Hutchison Senior Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 534 |</body>
  </mail>
  <mail>
    <header>Re: Mocking Super Methods</header>
    <body>This looks like it might do the trick.  I'll give it a look.  Thanks! "super" version of the same method.  Actually, another person details a perfect example here: the same concerns as the person who has posted in the comments in that we're simply moving the testing gap to another location and not actually testing expectated behavior (I'm trying to get to 100% coverage).</body>
  </mail>
  <mail>
    <header>EasyMock 2.5</header>
    <body>Hello everyone, I'm extremely proud to announce that EasyMock 2.5 was just delivered. It contains a lots of features and improvements. Mostly requested by you. I also did the version 2.4 post mortem and decided that it has been a really bad idea to check thread-safety by default. So it's not anymore. However, mocks are now thread-safe by default. But adding a property system, I made sure you can change the default easily in case your tests are expecting on different set of defaults. I'm really looking forward to get your feedback (good or bad) on this one. Especially about thread-safety and deadlocking. But also Capture and error messages. I should be available in the maven central repository after the next rsync. Also, EasyMock jar is now an OSGi bundle. Below, the release notes and change log. For details on the new features, see the documentation. Regards, Henri --------------------------------------------------------------------------------\ ------------------------- Notes: This release is meant to provide backward compatibility with version 2.3 and 2.4. However the default behavior is in the middle - No thread-safety check by default (like in 2.3) - Thread-safe (like in 2.4) You can change these two by setting properties to change the default or calling specific methods for a given mock (checkIsUsedInOneThread and makeThreadSafe). The capture was also greatly improves to be more user-friendly and to have new possibilities. The default behavior is quite close to the one in 2.4 but still might break some of your tests if you worked-around some 2.4 issues. Error messages were improved from user suggestions. A new refactoring safe way to use getCurrentArgument called andDelegateTo was added. And finally, the jar is now an OSGi bundle. See documentation for details on all these features. --------------------------------------------------------------------------------\ -------------------- Changes: easymock.enableThreadSafetyCheckByDefault properties provide backward compatibility (2169027) delegated answer to help debugging tests (2771518)</body>
  </mail>
  <mail>
    <header>Roadmap</header>
    <body>One last thing For those who wonder, the next steps are: - Move EasyMock from MIT to Apache license (for complex legal reasons). So version 2.5.1 will be under Apache - EasyMock CE 2.5 (later this year probably). Mostly to include all your requests. - EasyMock CE will also go under Apache (and as a matter of fact, Objenesis too) ... and of course, quick maintenance releases if needed... Cheers, Henri</body>
  </mail>
  <mail>
    <header>Cannot throw an IOException on last method called?</header>
    <body>Hi all, I've got the following method which I want to test for failures: [code] writer = new BufferedWriter(new FileWriter(new File(indexHelper NavigableMap&amp;lt;Long, IIndexedDocument&amp;gt; documentIndex = new ConcurrentSkipListMap&amp;lt;Long, IIndexedDocument&amp;gt;( [/code] And the following test: [code] @Test (expected = FidoIndexerError.class) EasyMock.expect(indexHelperMock.getDocumentIndexCachePath()).andThrow( [/code] I mocked the indexHelper and I instructed it to throw an IOException, so that the catch block gets invoked and a new FidoIndexerError exception is called. However when running this test I get the following: [stackTrace] java.lang.IllegalArgumentException: last method called on mock cannot throw java.io.IOException at org.easymock.internal.MocksControl.andThrow(MocksControl.java:98) at uk.co.jemos.fido.unit.model.TopKRepositoryTest.testDrainDocumentIndexCacheToDisk\ WithNonExistentFile(TopKRepositoryTest.java:101) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.junit.internal.runners.TestMethod.invoke(TestMethod.java:59) at org.junit.internal.runners.MethodRoadie.runTestMethod(MethodRoadie.java:98) at org.junit.internal.runners.MethodRoadie$2.run(MethodRoadie.java:79) at org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadi\ e.java:87) at org.junit.internal.runners.MethodRoadie.runTest(MethodRoadie.java:77) at org.junit.internal.runners.MethodRoadie.run(MethodRoadie.java:42) at org.junit.internal.runners.JUnit4ClassRunner.invokeTestMethod(JUnit4ClassRunner.\ java:88) at org.junit.internal.runners.JUnit4ClassRunner.runMethods(JUnit4ClassRunner.java:5\ 1) at org.junit.internal.runners.JUnit4ClassRunner$1.run(JUnit4ClassRunner.java:44) at org.junit.internal.runners.ClassRoadie.runUnprotected(ClassRoadie.java:27) at org.junit.internal.runners.ClassRoadie.runProtected(ClassRoadie.java:37) at org.junit.internal.runners.JUnit4ClassRunner.run(JUnit4ClassRunner.java:42) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReferen\ ce.java:45) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:196) [/stackTrace] Is there a reason why I shouldn't be able to instruct the mocker to throw an IOException if this is the only thing done by the test? Regards, M.</body>
  </mail>
  <mail>
    <header>Re: Cannot throw an IOException on last method called?</header>
    <body>Ok, but in this case how could I simulate an IOException from within the method the write operation may generate an IOException. I'd like to simulate that, but BufferedWriter does not implement an interface. So what should I do?</body>
  </mail>
  <mail>
    <header>Capture and Answer</header>
    <body>I'm pleased to see that the recent easymock included a Capture option for parameters.  Sometimes I'm lazy in a way that makes this quite useful.  I have a very similar class that I implemented for 2.3. There are few differences, but some of these might be worth considering. Major differences: - I do type checking at runtime in the matcher, so instantiation requires passing a Class&amp;lt;? extends T&amp;gt;.  This is mainly for providing a nice toString(), but it also allows for more stringent checks. - I see no need for the static method EasyMock.capture().  I put this method on the actual capture object. - The argument matcher can be used multiple times, but each time after the first it asserts that the same object has been passed to it. - Have the Capture class implement IAnswer&amp;lt;T&amp;gt;, which lets you provide a response without actually running the test code.  I found this useful and even necessary in one or two places (such as cases like below). This gives code like: BTW, the toString() of Capture&amp;lt;T&amp;gt; uses: String.valueOf(value) might be a better choice. Regards, Martin</body>
  </mail>
  <mail>
    <header>Re: Complete mocking of interface</header>
    <body>You need to create mocks for ICar and IWheels and IEngine: If you are doing this often, or have to go down more than one level (since ICar is a factory), then you are probably violating "Law of Demeter" which basically says don't pass A to B, when the only thing B does is give A to C. If you are finding you have to mock too many levels, you are probably confusing the responsibility of business logic with the responsibility of object creation in your code. Instead of your code taking ICar just to get IWheels, consider having it take IWheels instead. Jason</body>
  </mail>
  <mail>
    <header>Re: Complete mocking of interface</header>
    <body>Hi Jason, Thanks a lot for your response. 1. I can do what you have mentioned in the code. This is normal way of mocking. But i don't want to do that, but i am asking if there is a easy way to provide the mock for all the method that return an interface. In my case for the wheels and Engine since they interface themselves I understand the law of demeter, unfortunately i depend on an external api and don't have a control over it and we have to live with  it. Said that we cannot go without unit testing our code. The problem with above example is i have to create mock for the engine and the wheel and set it as an expectation on the mock car. There are many such instances where i want all the mock to be got one shot, else it is too much of effort to get it done. Is there a better way of doing this other than doing this with reflection where i identify each of the interface and set the mock of these in the main interface say here the ICar mock. My question is, has anyone faced such situation and have come up with a better solution to this? Thanks, Vijay Venkataraman</body>
  </mail>
  <mail>
    <header>Re: Re: Complete mocking of interface</header>
    <body>Hi, There was some work on this. To create mocks using reflection. You can have a look on the archive of this mailing list. One was about using a @Mock annotation on methods to create a mock. But I'm still not sure I like it. It puts a test annotation on business code. Cheers, Henri On Sat, Mar 14, 2009 at 6:01 AM, vijay.venkataraman</body>
  </mail>
  <mail>
    <header>Re: Re: Complete mocking of interface</header>
    <body>mocking. But i don't want to do that, but i am asking if there is a easy way to provide the mock for all the method that return an interface. In my case for the wheels and Engine since they interface themselves don't have a control over it and we have to live with  it. Said that we cannot go without unit testing our code. wheel and set it as an expectation on the mock car. There are many such instances where i want all the mock to be got one shot, else it is too much of effort to get it done. where i identify each of the interface and set the mock of these in the main interface say here the ICar mock. solution to this? The way I posted is the only way I know of in EasyMock. I'm not sure another solution is even possible without using reflection. I imagine that EasyMock is using reflection under the hood anyway with proxy interfaces. I'm sure you could make a utility method createDeepMocks( Whatever.class ) such that you make a mock for all interfaces using reflection. You're faced with this hard problem but eliminated all of the tools that can be used to solve this. If the API is bad, another common approach is to write something around it to "refactor" the bad API. For example if you have an API that is untestable because it forces you to use globals (I've heard old-style JSP is this way), you minimize the "untestable" code and write a class that does the absolute minimum amount of work with the bad API (singletons/globals) and delegates it to testable code, and use techniques such as code review and system tests to address the "untestable" code. Jason</body>
  </mail>
  <mail>
    <header>mock legacy class?</header>
    <body>Hi! I am working on EMF/CDO and I test a custom component we have in our transport framework (net4j). I therefore tried to mock ByteBuffer (java.nio) without luck for now. What I get for the moment is a cglib instrumented class (I see that in the toString() ouput), but none of the methods are mocked - all calls just get to the original implementation. I guess cglib does not mock that class correctly. Do I miss something? I'd appreciate any hints a lot! Thanks in advance. Cheers André</body>
  </mail>
  <mail>
    <header>Re: mock legacy class?</header>
    <body>Hi, The problem comes from methods in the Buffer class. Some are final. EasyMock can't mock final methods since it can't override them. The solution is to remove the final with class instrumentation but I'm not sure it can be done on java.* packages. But it's probably easier to use a real ByeBuffer no? Cheers, Henri On Sun, Mar 15, 2009 at 11:48 PM, andre.dietisheim</body>
  </mail>
  <mail>
    <header>Re: mock legacy class?</header>
    <body>Hi Henri thanks for your ultrafast reply! ;-) Yep, I thought that this might be the reason (for ex. position()). I would have used the original ByteBuffer in normal circumstances. The Test I write wants to ensure that the ByteBuffer user code does the right calls in the right moment (multi-threading). That's the main motivation behind this test and the main reason for not having viable alternatives (I could rewrite the user code to use a delegate, but that's not really a good choice). I guess I'll have to additionally take something like JMockit for those cases. Thanks + Cheers André</body>
  </mail>
  <mail>
    <header>Re: Testing the order of execution of mock objects</header>
    <body>Use the IMocksControl. See the section "Checking Method Call Order Between Mocks" in the documentation:  However, if you are really using EasyMock 1.1, that is far older than I've ever seen so maybe it doesn't have the IMocksControl. In fact, 1.1 isn't even listed on the site. I don't see this section in the 1.2 docs (the oldest listed), so maybe you might need to upgrade to use that feature. Jason</body>
  </mail>
  <mail>
    <header>Birthday Please</header>
    <body>Hello Click on the link below and please enter your birthday for me.  It will take less than one minute.  Thank You, Pankaj</body>
  </mail>
  <mail>
    <header>Re: Nice Mocks - but not too nice</header>
    <body>You can achieve this by using "andStubReturn" or "asStub" on the mock:  expectLastCall().asStub(); //call 0 or more times, like nice mock The main (only?) difference between nice mock and standard mock is that by default every method is like "asStubReturn"/"asStub" by default no a nice mock, and on standard mock the default is that any calls mean an error. To set which methods you care about (and how you care about them) you use the normal record and replay functionality. Note that the standard mock is not the same as a "strict" mock, which additionally checks for the order of the calls. Jason</body>
  </mail>
  <mail>
    <header>IllegalStateException: missing behaviour error- but have expect and replay setup</header>
    <body>G'day all. I am getting a "missing behavior definition for the preceeding method call getDataServerName()" exception on some of my tests - and I am tearing my hair out trying to solve it...  I suspect it is classpath related, but cannot nail it.  Working under eclipse (Run-As), but not under ant (commandline). Using Eclipse Europa - tests work. Using commandline ant test target - tests fail. Using ivy to manage dependances. Java 1.5 (cannot upgrade as companion product does not support 1.6 yet), ant 1.7.0 and jUnit 4.1 Was using 2.3 with 2.2.2 Class Extensions - but have upgraded this morning to eliminate that. Have added the EasyMock jars into the ant libs dir too - jic. An edited version of some of the classpath is at the end. Test Case details (pieces).... @Test Stacktrace getDataServerName() preceeding method call getDataServerName() org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:30\ ) org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:61) org.easymock.classextension.internal.ClassProxyFactory$1.intercept(ClassProxyFac\ tory.java:79) com.calypso.tk.service.DSConnection$$EnhancerByCGLIB$$f3fce13.getRemoteBO(&amp;lt;gener\ ated&amp;gt;) au.com.nabCapital.tk.bo.document.MQSeriesGatewayFaxPDFDocumentSender.handleError\ (MQSeriesGatewayFaxPDFDocumentSender.java:342) au.com.nabCapital.tk.bo.document.MQSeriesGatewayFaxPDFDocumentSender.&amp;lt;init&amp;gt;(MQSe\ riesGatewayFaxPDFDocumentSender.java:120) au.com.nabCapital.tk.bo.document.MQSeriesGatewayFaxPDFDocumentSenderTest.testMQS\ eriesGatewayFaxPDFDocumentSender(MQSeriesGatewayFaxPDFDocumentSenderTest.java:18\ 7) The call to the method in question is within the constructor where initialisation is taking place. When there is a failure (this particular test case) it logs the problem for intervension, disables the facility within the application then completes. Have also tried expect(mockDS.getDataServerName()).andReturn("test"); and expect(mockDS.getDataServerName()).andReturn("test").anyTimes(); without success. mockDS is using the classExtensions, while mockBO is using the Interface mechanism.  The stack is thrown at the call where mockBO is used. Almost like it is not picking up the first expect() call. This normally just works which is why this is so frustrating!!! ANY help would be greatly appreciated...Thanks...Andrew Classpath extract. ;\other\Tidy\Tidy-jTidy.r7.jar ;\other\core-renderer\core-renderer-8.pre2.jar ;\other\itext-paulo\itext-paulo-155.jar ;\other\jaxen\jaxen-1.1.1.jar ;\other\jdom\jdom-1.1.jar ;\other\jms\com.ibm.mq-6.jar ;\other\jms\com.ibm.mqjms-6.jar ;\other\jms\commonservices-6.jar ;\other\jms\dhbcore-6.jar ;\other\jms\jms-1.1.jar ;\other\jms\jta-6.jar ;\other\jms\tibcrypt-4.4.2.jar ;\other\jms\tibjms-4.4.2.jar ;\other\xalan\xalan-2.6.0.jar ;\other\xml-apis\xml-apis-2.6.0.jar ;\internal\cib-database\cib-database-1.5.3.jar ;\internal\cib-exception\cib-exception-1.0.1.jar ;\internal\cib-jms\cib-jms-1.4.9.jar ;\internal\cib-message\cib-message-1.3.2.jar ;\internal\helpers\helpers-2.1.1.33.jar ;\internal\market_data\market_data-2.1.2.16.jar ;\apache\commons-beanutils-core\commons-beanutils-core.jar ;\apache\commons-collections\commons-collections-3.2.1.jar ;\apache\commons-configuration\commons-configuration-1.5.jar ;\apache\commons-dbcp\commons-dbcp-1.2.1.jar ;\apache\commons-digester\commons-digester-1.8.jar ;\apache\commons-lang\commons-lang-2.4.jar ;\apache\commons-logging\commons-logging-1.1.1.jar ;\apache\commons-pool\commons-pool-1.2.jar ;\apache\log4j\log4j-1.2.8.jar ;\escc\dbcommand\dbcommand-1.0.3a.jar ;\internal\test_helpers\test_helpers-2.1.1.3.jar ;\sun\connector-api\connector-api-1.5.jar ;\sybase\jconn2\jconn2-5.5.0.jar ;\testing\cglib-nodep\cglib-nodep-2.1_2.jar ;\testing\easymock\easymock-2.4.jar ;\testing\easymockclassextension\easymockclassextension-2.4.jar ;\testing\jmockit\hibernate3emul-jmockit-0.85.jar ;\testing\jmockit\jmockit-0.85.jar ;\testing\jmockit\jmockit-asm2-0.85.jar ;...</body>
  </mail>
  <mail>
    <header>Re: IllegalStateException: missing behaviour error- but have expect and replay setup</header>
    <body>Henri Thanks for your response. Trying to put together something to send you and stumbled on the answer. When I tried to run just the single test class that was failing, it showed as passing...  But failed when run with the other test classes. Investigated a little more and for some reason (person who set our original ant project has moved on), they have the ant / jUnit standard for fork.mode to perBatch.  Changed this to perTest inline with your comment about threading and now everything is passing. Strangely, only this particular test class is acting this way - works fine in other areas of our code with perBatch. Again, thanks for your assistance....Andrew</body>
  </mail>
  <mail>
    <header>Easy Mock on Java EE Application Server</header>
    <body>Hi, We are trying to utilize the Serialization benefits of version 2.4 but we fail. We have written JUnit tests in eclipse towards a remote EJB component on a Java EE Application Server (GlassFish). We wish to put expectations on the EJB component's dependencies using EasyMock. After setting expectations and replaying the EasyMock object we upload it to the Java EE server (using Remote EJB). Then we invoke the test method and let it process the request towards the uploaded EasyMock object. Then we download the EasyMock object again and finally we verify it. We fail deserializing the object due to a ClassCastException (during upload). We don't get this exception if we don't add any expectations to the object before uploading it. javax.ejb.EJBException: nested exception is: java.rmi.MarshalException: CORBA MARSHAL 1398079699 Maybe; nested exception is: org.omg.CORBA.MARSHAL:   vmcid: SUN  minor code: 211 completed: Maybe com.sun.corba.ee.impl.logging.ORBUtilSystemException.valuehandlerReadException(O\ RBUtilSystemException.java:8428) com.sun.corba.ee.impl.encoding.CDRInputStream_1_0.readRMIIIOPValueType(CDRInputS\ tream_1_0.java:973) com.sun.corba.ee.impl.encoding.CDRInputStream_1_0.read_value(CDRInputStream_1_0.\ java:1052) com.sun.corba.ee.impl.encoding.CDRInputStream.read_value(CDRInputStream.java:475\ ) com.sun.corba.ee.impl.io.IIOPInputStream.inputObjectField(IIOPInputStream.java:1\ 974) com.sun.corba.ee.impl.io.IIOPInputStream.inputClassFields(IIOPInputStream.java:2\ 199) com.sun.corba.ee.impl.io.IIOPInputStream.inputObject(IIOPInputStream.java:1211) ................ Caused by: java.lang.ClassCastException: org.easymock.internal.ObjectMethodsFilter cannot be cast to org.easymock.internal.MethodSerializationWrapper sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) I have a couple questions. - Do anyone have an idea of what are causing my problem? - Have anyone considered (or maybe tried) this way of using of EasyMock? - Is it in the roadmap to enable EasyMock support for Remote EJB interfaces on a Java EE server?</body>
  </mail>
  <mail>
    <header>Re: Easy Mock on Java EE Application Server</header>
    <body>Hi Henry, First I want you to know that I have tried serialize/deserialize to/from file and that seams to work well. It sounds strange to me that deserializing the object on an App Server leads to ClassCastException while deserializing in a Java Client env works fine. However, that seams to be the case here... Here is my test case: Note that all interface ending with "Remote" is remote interfaces refering to EJBs on an App Server. We run our EJBs on GlassFish. If you want me to send my example application (ear, ejb &amp;amp; client jar) as well, let me know how I can do that. Thanks, /Erik com.sun.corba.ee.impl.logging.ORBUtilSystemException.valuehandlerReadException(O\ RBUtilSystemException.java:8428) com.sun.corba.ee.impl.encoding.CDRInputStream_1_0.readRMIIIOPValueType(CDRInputS\ tream_1_0.java:973) com.sun.corba.ee.impl.encoding.CDRInputStream_1_0.read_value(CDRInputStream_1_0.\ java:1052) com.sun.corba.ee.impl.encoding.CDRInputStream.read_value(CDRInputStream.java:475\ ) com.sun.corba.ee.impl.io.IIOPInputStream.inputObjectField(IIOPInputStream.java:1\ 974) com.sun.corba.ee.impl.io.IIOPInputStream.inputClassFields(IIOPInputStream.java:2\ 199) com.sun.corba.ee.impl.io.IIOPInputStream.inputObject(IIOPInputStream.java:1211) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25)</body>
  </mail>
  <mail>
    <header>Re: Expect record behaviour</header>
    <body>Well it depends on what these methods do here. I'm going to make a few assumptions here and let me know if they are right: 1) UserDao.loadByUsernameAndPassword is supposed to return a User object if the username and password are valid and null otherwise 2) LoginServiceImpl.login is supposed to call UserDao.loadByUsernameAndPassword 3) LoginServiceImpl.login checks the return value of UserDao.loadByUsernameAndPassword and if it's non-null returns true (success), otherwise false If those assumptions are correct, then this testcase will pass because the expect call states that UserDao.loadByUsernameAndPassword is expected to be called with the specified username and password and then that method should return results. -- Jon Schewe | If you see an attachment named signature.asc, this is my digital signature. See For I am convinced that neither death nor life, neither angels nor demons, neither the present nor the future, nor any powers, neither height nor depth, nor anything else in all creation, will be able to separate us from the love of God that is in Christ Jesus our Lord. - Romans 8:38-39</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock ClassExtension + Groovy</header>
    <body>Hum... weird... I'll have a look. Which version of Groovy are you using? org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:77\ 8) org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAd\ apter.java:170) org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethod0(ScriptBytecodeAd\ apter.java:198) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:43) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:43) org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:\ 804) org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:\ 83) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:43)</body>
  </mail>
  <mail>
    <header>Re: Expect record behaviour</header>
    <body>Hi, I'll suggest 3 things. 1- Read the EasyMock online documentation 2- Have a look at the samples bundled with the EasyMock release 3- Read "JUnit in Action" by Vincent Massol (it uses EasyMock 1 and JUnit 3 syntax but explains quite well the unit test and mock principles) That should get you started. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: EasyMock ClassExtension + Groovy</header>
    <body>I believe that was 1.5.4 . Thanks, Haw-Bin org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:77\ 8) org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:758) org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAd\ apter.java:170) org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethod0(ScriptBytecodeAd\ apter.java:198) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:43) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:43) org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:86) groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1105) org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:\ 804) org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:\ 83) groovy.lang.GroovyShell.runMainOrTestOrRunnable(GroovyShell.java:252) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:43) org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:101) org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130) signature org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecod org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(Script sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.j sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccess sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.j sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccess org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:8 groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1094) org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHe org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHe groovy.lang.GroovyShell.runMainOrTestOrRunnable(GroovyShell.java:252) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.j sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccess org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java: org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130) produced</body>
  </mail>
  <mail>
    <header>How to get DAO while we're relying on a context object (that isbeing passed in)</header>
    <body>Hi, I'm trying to get DAO that is relying on the context object as per the example of But I'm not getting. Kindly anybody tell me how to do this. Thanks in advance... My code goes like this..... --------------------------------- //org.springframework.context.ApplicationContext ctx = new // FileSystemXmlApplicationContext( "D:\\...\\Web ApplicationContext mockContext = EasyMock.createMock ---------------------- applicationContext.xml ---------------------- .... .... .... ....</body>
  </mail>
  <mail>
    <header>Capture Bug Report</header>
    <body>I haven't been able to figure out where EasyMock keeps its bugs, so pardon the bug report to this list. The way that EasyMock 2.4 verifies whether an expectation is matched is by first checking the arguments and then checking to see if there is a response value available.  Unfortunately for that algorithm, Captures have the side-effect of capturing whatever they were given and then claiming that the argument matched.  This means that if the same method is called twice with two different Capture objects, both Capture objects will end up with the value from the final call.  E.g. EasyMock.expect(mockedString.replace(EasyMock.capture(replaceRegex1), EasyMock.expect(mockedString.replace(EasyMock.capture(replaceRegex2), Fails with both normal mocks and strict mocks (strict mocks actually try to match the first capture twice). A general fix for the problem can be done in the Captures class, though I doubt it is the "correct" fix.  Basically, if you change to it works as long as the Capture expects are declared and matched in order.  The "correct" fix probably has to do with separating the matching of argument objects from the side-effect inducing calls to those objects...</body>
  </mail>
  <mail>
    <header>Re: Capture Bug Report</header>
    <body>Hi, The bug tracker is on Source Forge (but it's true it's not mentionned on the website, I'll change that). Your issue already exists with the exact same fix in fact. Obviously, I can't change the EasyMock behavior on matching. For the capture, you're solution won't work in some cases (I don't remember exactly what but it's explained in the tracker). But you're right that's something that can be useful. I'll find a way to make it work. Thanks, Henri</body>
  </mail>
  <mail>
    <header>Re: EasyMock Spring integration</header>
    <body>Hi, From my point of view, there's no need to bind a mock with Spring. I always use an extremely classic setter to do so. Even if part of a tested class needs to be injected, I still create the mock with straight java code. You need to do the recording anyway. Why do you think it could be useful? Cheers, Henri</body>
  </mail>
  <mail>
    <header>Translation submission place?</header>
    <body>I finish a Chinese version translation of EasyMock 2.4. Where should I send the file?</body>
  </mail>
  <mail>
    <header>Re: EasyMock Spring integration</header>
    <body>Frédéric I agree that it is difficult to inject Easymock objects into Spring-created object graphs. Ive struggled with this myself. However, I think the problem is with Spring, not Easymock. Spring doesn't let you easily combine object instances you provide yourself (eg a trained mock) into objects it creates from the context spec. Why make this operation so difficult? Ive asked about this on Spring user lists and raised JIRA issues, but have yet to see any decent solution. eg -Ben -- *Ben Hutchison Senior Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 534 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Translation submission place?</header>
    <body>Hi, You can add a file to the Yahoo group or add a feature request to SourceForge. Then I'll see what I can do. The problem being that since I don't speak chinese (which chinese by the way?) it would be hard to synchronise / validate. Regards, Henri</body>
  </mail>
  <mail>
    <header>Possible bug when creating a partial mock and a invoking constructor</header>
    <body>Hi, We received a message on the PowerMock mailing-list suspecting a bug in PowerMock when it comes to creating partial mocks and invoking a constructor. However when I begun to investigate the cause of this I suspect that it's actually a bug in EasyMock classextensions. This happens when you have a class this: What the user would like to do is to create a partial mock of this class mocking only the touch method. The user would also like to invoke the constructor to initialize the class. This is where the problem occurs. EasyMock seem to ignore that the original initialize method should be invoked when the constructor is invoked. Instead the call to initialize gets caught and thus recorded by the proxy. As far as I can see the problem is that the mockedMethods Set in the org.easymock.classextension.internal.ClassProxyFactory class is null by the time the constructor is invoked. The mockedMethods Set is populated after the constructor has been executed in org.easymock.classextension.internal.MocksClassControl#createMock(..) when the getInterceptor(mock).setMockedMethods(mockedMethods) statement is executed. This is too late in this situation however. Please have a look at the following example:  /samples/partialmocking/PartialMockingWithConstructor.java mock/junit4-test/src/test/java/samples/junit4/partialmocking/PartialMockingWithC\ onstructorUsingEasyMockTest.java</body>
  </mail>
  <mail>
    <header>Re: EasyMock Spring integration</header>
    <body>Hi, The EasyMock bean is created dynamically, so I'm not quite sure  how JavaConfig can be used. What do you had in mind? That made me think however (but I haven't put a lot of thought on this either), it might be possible to use a spring factory to create the mock. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Generics fail to compile after upgrade to 2.4</header>
    <body>It seems that IExpectationSetters&amp;lt;T&amp;gt; methods such as "andStubReturn" now take T instead of Object. This caused about 50 or so compilation errors in our project when we upgraded. Some were easy to fix, but I never could find a solution for the generics. Here is an example that I can find no way to compile without nasty generics-breaking casts: @Test I'm not sure what to do because we have generics like this all over the place (with wildcards). Am I missing something here? Is using wildcards in the get methods bad style? (If so, then it doesn't let me return a List&amp;lt;Derived&amp;gt;?) It compiles if I cast everything to (List), but then that doesn't seem like the "right" solution, plus it will look like a bug (or at least a code smell) in peer reviews from other developers, as well as issue unchecked warnings. Jason Winnebeck</body>
  </mail>
  <mail>
    <header>Re: Generics fail to compile after upgrade to 2.4</header>
    <body>Hi, As usual, you gotta love generics :-) First, never return a wildcard. The compile will consider the return type to be a capture (capture#1). So even this won't compile. Returning a wildcard is like saying "I want to return an unknown but specific type that extends Base". That's pointless. Just return List&amp;lt;Base&amp;gt;. Second, never type a variable with wildcards. For the same reason. In data is now of type List&amp;lt;capture#1&amp;gt;, capture#1 extends Base but since it's not a real existing type, you won't be able to pass data anywhere. List&amp;lt;Base&amp;gt; is fine. And it does exactly what you want. Being able to add classes extending Base to the list. Finally, expect( mock.getData() ).andReturn( derivedData ); is like doing This is forbidden. getData returns a List&amp;lt;Base&amp;gt; so that can't be cast into a Derived since the List&amp;lt;Base&amp;gt; could contain something else extending Base. I hope my explanations are clear... It's kinda hard to explain. Underneath, the fixed test case. Cheers, Henri --------------------------------------------------------------------------------\ --------------- --------------------------------------------------------------------------------\ ---------------</body>
  </mail>
  <mail>
    <header>Re: Generics fail to compile after upgrade to 2.4</header>
    <body>Yeah, they are easy to get into and hard to master. Perhaps if my issues are with generics this is slightly off-topic of Easymock, so thanks for the discussion. Your argument, in isolation, makes sense. In fact the APIs for my project used to be like that, then I changed them. I might have missed something (example coming later). -- because List&amp;lt;Base&amp;gt;.add( Base ) is not a valid method on List&amp;lt;Derived&amp;gt;. It follows, that List&amp;lt;? extends Base&amp;gt; is effectively read-only because you don't know the concrete type. Wildcard generics are useful as method parameters when you never care to add. Originally I never used any wildcards and got into problems. Agreed. I did that just as an example to show that I tried to make the type exactly "the same" in my call. I guess Java didn't consider the two compatible -- maybe because the two ? could be different. Yeah, generics are hard to explain. Fortunately I get most of it already, but still must be missing a small part. I know and see why the "fixed" test case works. What I don't get is how to transform my code to look like that (again). Here is my issue. I have an API that is entirely based on interfaces. Let's say there is some kind of alternate world JDBC that lets clients get a list of tables: Now, I implement: Now what? I can't return tables, because you can't assign List&amp;lt;MyTable&amp;gt; to List&amp;lt;Table&amp;gt; (for reasons I understand). Well, I don't want Database.tables to be List&amp;lt;Table&amp;gt; since it wants MyTables internally, and the whole point of generics is to avoid casting in this case. I could cast tables to List (no generic), but then you get an unchecked warning. Using Iterable or Iterator won't work here either. Creating a proxy class that List&amp;lt;MyTable&amp;gt; doesn't seem like a good solution since I'd have to write that code, but it would work. Maybe you could implement a generic class X&amp;lt;T, S extends T&amp;gt; implements List&amp;lt;T&amp;gt; or something, which would occur some runtime overhead to get around the generics. So, that's one reason why I had the interface return (my example's equivalent) list. But, I must be missing something. Jason</body>
  </mail>
  <mail>
    <header>Re: Generics fail to compile after upgrade to 2.4</header>
    <body>Sadly, I'm not a total expert in generics either but I'm trying for years now. To replace the wildcard I use you put a restriction on the type of the List but without wildcards. Then, I don't know how to prevent having a suppress warning. The nicest way is to do this: @SuppressWarnings("unchecked") That way getTables is nicely typed but unfortunately, a SuppressWarnings is required. At least the scope is limited... To only way I know (which is probably the best way) is to make that class generic. You then get the following which is I guess the recommanded way. --------------------------------------------------------------------------------\ ------- -------------------------------------------------------------------------------</body>
  </mail>
  <mail>
    <header>Re: Generics fail to compile after upgrade to 2.4</header>
    <body>Actually, I found an interesting solution (at least for List) when playing around with trying to compile my example: I knew about Collections.unmodifiableList. What I didn't know is its full signature: public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; unmodifiableList(List&amp;lt;? extends T&amp;gt; list) Notice that the parameter takes a wildcard, and not just T. So: doesn't quite work -- but almost. Another thing I've seen so rarely I couldn't figure out how to use it right away is how to specify a method generic parameter: This works and compiles. It is also "safer" compared to non-generic form because it doesn't allow tables to be modified by the caller, which ultimately the generics system exposes. However, this means you need a new object every time you make the call (performance issue), unless you cache it (added code/memory requirement), and a small runtime overhead to delegate the calls -- I don't know if the JIT optimizer can "inline" those calls. Your solution with the generic interface is interesting as well. Perhaps that would be useful, but I am thinking almost all of the time I returned the &amp;lt;? extends X&amp;gt; from an interface method, it is with a collection and never some other kind of "custom" object, so that would solve most cases without having to make the interface generic. The cool part about your solution is it does allow the implementor to provide more information about what you get out of getTables. The drawback is the same thing -- it breaks encapsulation (a bit) because it kind of ties MyDatabase to always use MyTable, whereas if the user never even knew of the library-internal class MyTable, we could refactor more. Thanks for the discussion, Jason --------------------------------------------------------------------------------\ -------</body>
  </mail>
  <mail>
    <header>Re: Generics fail to compile after upgrade to 2.4</header>
    <body>2009/1/24 Jason Winnebeck &amp;lt;addr2@...&amp;gt;: This seems like premature optimisation to me. As Wurth said (paraphrased), don't do it! Write the code, run it through a profiler. If garbage collection or the "extra" method call is creating a bottle-neck, it'll be a miracle and you should optimise it then. The slow-performing code is almost never where you think it will be, because of JIT and other compiler tricks (code reordering, etc.). Your priority should first be to make the code correct. Sorry if I'm preaching to the choir on this point, but it seemed to me like your concern was misplaced. Cofion/Regards, Neil.</body>
  </mail>
  <mail>
    <header>Re: Generics fail to compile after upgrade to 2.4</header>
    <body>Normally, I'd agree with you. Except, this is adding runtime overhead just to satisfy the compiler in regards to generics, which was designed in Java to be purely a compile-time concept, so as to not break backwards compatibility with VMs. You could argue that the code is more "correct" because it doesn't allow the unsafe adding of objects to the List. Of course, that starts its own debate on whether every aspect of a method's contract should be double-checked at runtime. I'll probably use the unmodifiableList and be OK with it, even though I do Java development for "embedded" environments, it's still pretty low overhead. Jason</body>
  </mail>
  <mail>
    <header>Re: Typo in EasyMock error message</header>
    <body>Thanks. Now fixed. (but I've kept behavior :-)</body>
  </mail>
  <mail>
    <header>How to fill expectations not hardcoded, but from a variable</header>
    <body>Hi, I'm catching calls from a particular class or package with aspects, put package-class-method call and parameters) into an object and save them in a stream. When the system "captured" is not available, I would like to mock it. I got all the information together, but now when I want to write the mock, I see, that I cannot as before hardcode the methodname, parameters and returnvalues. I'm thinking about using reflection, however, I don't think that is the right way to do, because I just don't want (or even cannot e.g. if the target object has a private constructor) create the target object, and I don't want to invoke a method either, I just want to add it to the mock expectations like in the following code snippet: catched calls Does anybody has an idea how to do this? Might there be a function in EasyMock allowing to set e.g. methods, params etc through a String or object? Could this be done with another Mock-framework? Or would anybody know another strategy how to solve this issue? Thanks for help Mark</body>
  </mail>
  <mail>
    <header>Re: How to fill expectations not hardcoded, but from a variable</header>
    <body>Hi, The whole point of EasyMock is to provide static typing. So you can't do this. Frameworks like JMock used to. Some frameworks based on EasyMock are also providing these frameworks (sadly, I should but don't remember their names). Anyway, I had this need. For instance to mock a server behavior from outside. I do something along these lines: Cheers, Henri</body>
  </mail>
  <mail>
    <header>EasyMock 3 enhancements suggestion</header>
    <body>Hello Folks! I've been using EasyMock for quite some time and have some suggestions about new features it could have: source code. Many time the messages are not really helpful. When I'm ready with them, I will post them so it can join EasyMock 2.5 ;-) interfaces, one publishing the andReturn(), andAnswer()... methods and the other publishing times(), once(), atLeastOnce()... same would be true for times(). record phase would be much more readable as every behaviour recording would be surrounded with either EasyMock.expect() or EasyMock.expectVoid(). without any distinction to the real calls looks weird at a glance at a unit test. objects known to EasyMock that hasn't been verified so far. EasyMock.replayAll() could be similar, if replay wasn't going to be redundant (see point 5) :-) forgotten to replay at least one mock object (having for example 6 objects I easily miss one to replay) and then the object does not tell a reasonable error message but behaves very very strangely. Indeed, from the current API, there is no way to know (at the time of the call on the mock object) whether or not the call is a record-time call or replay-time call. That is because the call comes first and only after that the expect() comes. So the expect() is far too late if we wanted the method call to throw an exception when trying to replay the beahviour not recorded yet. There is a solution to this problem: Reversing the order of andReturn() and Expect() gives us the info that a recording is being done: Regards Dr. Kamil Sevecek --------------------------------------------------------------------------------\ --------------------------------------------------------------------------------\ -------- Look at an example:</body>
  </mail>
  <mail>
    <header>Modifying an object in a mocked method that returns void</header>
    <body>I am trying to figure out a way to modify an object in a mocked method that has no return value.  Specifically, I have a situation that can be represented by the following code: public class FooManagerImpl implements FooManager public interface FooDao public class Foo Notice that in the code above (a much simplified version of what is actually happening), the method being tested creates the object that is being saved and is then returned.  The method being tested passed the object that has been created into another method that returns void. I have seen the post ( recommends trying to use IAnswer, but I haven't been able to figure out how to do this on a method that returns void.  Otherwise, this would be an ideal solution. I have also attempted to use the EasyMock class extensions, and have been getting an error: java.lang.IllegalStateException: matcher calls were used outside expectations Class extensions, if I could get them to work, would be my second choice as I actually want the entire object mocked and only want to "implement" one actual method. Thanks for any help, Jay</body>
  </mail>
  <mail>
    <header>Re: EasyMock 3 enhancements suggestion</header>
    <body>2008/10/24 Kamil ©eveèek &amp;lt;kamil@...&amp;gt;: I don't think this is desirable. That would mean I couldn't write the following, if I understand you correctly: where the first call to bar() will get "baz" as the return value and the second "foobar". It's also useful sometimes to write: or something similar. Cofion, Neil.</body>
  </mail>
  <mail>
    <header>Re: EasyMock 3 enhancements suggestion</header>
    <body>Well, the question is whether mutli-call to andReturn() is readable enough. If you think so, then OK. Actually I don't mind chaining the andReturn multiple times (I even thought it is illegal) so if there are people using it, let's forget about that point. Dr. Kamil Sevecek 2008/10/24 Neil Greenwood &amp;lt;neil.greenwood.lists@...&amp;gt;:</body>
  </mail>
  <mail>
    <header>Re: EasyMock 3 enhancements suggestion</header>
    <body>Hi, Let's see. As usual, I need to think more deeply about it but my first thoughts. 1. The messages are normally meaningful, especially when named mocks are used. However I agree they could be more readable so there's place to improvement. I'm happy to get any help about it. The best is to create request on SourceForce tracker. 2. Some kind of split might be possible. However, as Neil point out, it must not remove any chaining feature. 3. You call always call expectLastCall() below a void method call. I do it all the time just for the reasons you told. Makes the code more readable. I'm not sure a expectVoid(mock).voidMethod is necessary. 4. That point was raised and even developed by an EasyMock user (whose name is in the tracker but not currently on the top of my head. Sorry about that). I think it's definitly a must have and a great idea. 5. You're right. But that would be a big change. Also I think that it feels more logical in the current order. But you're right we then get recording errors during replaying. If 4 fix that, great :-) I'll add another point of my own. I noticed that when there's an issue on replay, it's quite hard to no which mock passed in argument to replay() cause problem. That will be adressed too. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: Modifying an object in a mocked method that returns void</header>
    <body>Hi, You can use expectLastCall() on a void method to specify IAnswer. It works even on void. Here's a example below. About the class extension, it should work the exact same way. If you have a test case, I can tell you what's wrong. Thanks, Henri --------------------------------------------------------------------------------\ --------------- --------------------------------------------------------------------------------\ ---------------</body>
  </mail>
  <mail>
    <header>Re: EasyMock 3 enhancements suggestion</header>
    <body>As for point 3: Yes, you can use the expectLastCall() syntax but the point is that the expectation for void methods looks uterly different to the syntax for methods returning a value. My proposal was to move significantly closer to the usual expect() syntax. Another proof of the fact that expectLastCall() is not intuitive is the email from Jay Gelman asking about changing the DTO object ID which came most recently. As for 4: When can we expect the feature to be added? Kamil 2008/10/24 Henri Tremblay &amp;lt;henri.tremblay@...&amp;gt;: thoughts.</body>
  </mail>
  <mail>
    <header>Re: EasyMock 3 enhancements suggestion</header>
    <body>Sadly, I don't know when the next version will be delivered. It depends on my free time. So Christmas seems to be the possible sooner. Beginning of the year the later. About Jay, he's problem was more that it's not that obvious that you can use IAnswer on a void method. But I'll think about your proposal. - Henri</body>
  </mail>
  <mail>
    <header>Re: Modifying an object in a mocked method that returns void</header>
    <body>Thanks Henri.  This is exactly what I wanted.  I came up with an alternate solution before reading your post which was to use a custom IArgumentMatcher which modified the passed in argument.  However, there was a limitation in that it was not possible to use any of the existing IArgumentMatchers.  Using expectLastCall(), I can now do argument matching and argument modification separately. I removed my code for using class extension when I came up with the IArgumentMatcher solution (which I have now replaced with expectLastCall ), but if I can recreate the problem, I will post the code. Thanks again, Jay --------------------------------------------------------------------------------\ --------------- --------------------------------------------------------------------------------\ --------------- void.</body>
  </mail>
  <mail>
    <header>Re: Static initializers and class extensions</header>
    <body>It's not possible directly with EasyMock. It required class instrumentation. The latest hope (but I couldn't try yet) was this:</body>
  </mail>
  <mail>
    <header>Re: Static initializers and class extensions</header>
    <body>PowerMock should be able to help you just as Henri points out. Look for the "SuppressStaticInitializationFor" annotation. initializers from like to happy right sorts of etc. YUCK. running?</body>
  </mail>
  <mail>
    <header>Invoking multiple NiceMock methods</header>
    <body>EasyMockers, I'm creating a niceMock to use as a dummy. I want that any method called on the object returns junk. (null, 0 or false). But as per the test below, it seems nice mocks support only 1 method total being called: The error I'm getting is: java.lang.IllegalStateException: missing behavior definition for the preceeding method call getDate() org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:30\ ) org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:61) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestR\ eference.java:130) org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:460) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:673) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :386) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:196) Has anybody experienced this?</body>
  </mail>
  <mail>
    <header>Re: Invoking multiple NiceMock methods</header>
    <body>Hi, As for any mocks, you need to call expect().andReturn() during the recording phase (see documentation). If you want these methods to return their default (null, 0, 1), just call replay without any recording. Regards, Henri org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:30\ ) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestR\ eference.java:130) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:460) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:673) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :386) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:196)</body>
  </mail>
  <mail>
    <header>Thread-safe mocks</header>
    <body>Hi all, I'm currently doing some concurrency testing and this one test creates a few threads and each of them construct their own mock objects. The mocks are then passed to a shared object which manipulates them. Even though my mocks are not shared, I'm getting this error: java.lang.AssertionError: at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:32\ ) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:61) Any ideas? How does EasyMock.expect() call works? Will EasyMock understand that each thread has its own 'expecting' calls or will it mix the expecting calls from all threads? Thanks, Andre</body>
  </mail>
  <mail>
    <header>Re: Thread-safe mocks</header>
    <body>Hello Andre, you should be able to switch thread safety on with EasyMock.makeThreadSafe(mock, true). Hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>Re: EasyMock 3 enhancements suggestion</header>
    <body>Hello Kamil, your suggestion to remove replay() makes a lot of sense to me. As EasyMock uses the same object to define expectations and return values, there are different approaches to get rid of replay(). Unfortunately, most of them still require a special handling for void, or they do look strange, since the return value/behaviour has to be specified before the expectation. Internal DSLs are not that easy in Java because of the syntax and some limitations of the language. I don't know yet whether there will be a different syntax in EasyMock 3, or how it will look, but getting rid of replay() is on top of my list. Having said that, I am currently not working on EasyMock, so Henri will decide what will be done. Thanks for your help, Tammo Freese PS Oh, it would be so simple without void. PPS Oh, it would be so simple with closures.</body>
  </mail>
  <mail>
    <header>Re: EasyMock 3 enhancements suggestion</header>
    <body>Thank you, Tammo. I absolutely agree with you.</body>
  </mail>
  <mail>
    <header>EasyMock ClassExtension + Groovy</header>
    <body>I've used core easymock with Groovy thus far with no problems. However, when I tried using the classextension to mock out concrete classes today, I ran into all sorts of difficulties - from NPE's to an error claiming I can't replay an object that was clearly produced by createMock(). Googling for "easymock classextension groovy", I saw that others have experienced similar problems. Is there any plan to look at interoperability with Groovy in the next release? Haw-Bin</body>
  </mail>
  <mail>
    <header>Re: EasyMock ClassExtension + Groovy</header>
    <body>No since I wasn't aware of any issue. However, now that I know, I'll look into it. Can you give me a TestCase showing your problem? Thanks, Henri</body>
  </mail>
  <mail>
    <header>Re: EasyMock ClassExtension + Groovy</header>
    <body>Hi Henri, Here is a sample test: import static org.easymock.classextension.EasyMock.* import static org.easymock.EasyMock.* It fails with the following output: $ groovy MockTest.groovy .E Time: 0.156 There was 1 error: 1) testMock(MockTest)groovy.lang.MissingMethodException: No signature of method: org.easymock.classextension.internal.MocksClassControl.replay() is applicable for argument types: org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecod eAdapter.java:54) org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(Script BytecodeAdapter.java:169) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.j ava:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccess orImpl.java:25) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.j ava:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccess orImpl.java:25) org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:8 6) groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1094) org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHe lper.java:800) org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHe lper.java:82) groovy.lang.GroovyShell.runMainOrTestOrRunnable(GroovyShell.java:252) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.j ava:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccess orImpl.java:25) org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java: 101) org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130) FAILURES!!! Tests run: 1,  Failures: 0,  Errors: 1 Thanks, Haw-Bin concrete to an by have</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock ClassExtension + Groovy</header>
    <body>Hi, I was quite surprised why it wouldn't work. But this example won't work (compile) in Java either.  The replay and verify method on IMocksControl doesn't take any parameter. Try mc.replay() or replay(mockNode) A complete example will be: import static org.easymock.classextension.EasyMock.* import static org.easymock.EasyMock.* Cheers, Henri P.S.: I didn't try the example, I don't have Groovy installed. But I must be close from a working code.</body>
  </mail>
  <mail>
    <header>Re: no last call on a mock available</header>
    <body>Hi Kamil ,Thanks for your reply In the setUp() , //For accessing Hibernate // For creating mock I need to access both one, could you tell me the solution ? the</body>
  </mail>
  <mail>
    <header>Re: easymock.org down?</header>
    <body>Hi Jon, Am 03.10.2008 um 16:53 schrieb Jon Schewe: Sourceforge has changed some IP addresses, and I changed EasyMock's DNS entry too late. It is fixed now, however you may need to flush your DNS entries to see it working immediately. Thanks for the issue report, Tammo Freese</body>
  </mail>
  <mail>
    <header>How to mock ldap</header>
    <body>hi, How do you mock LdapContext interface or InitialLdapContext class? This is what Ive tried: My app binds to objects in ldap store. In order to mock this behavior, I create a mock ldap object &amp;amp; pre-set some values in the mock and then my app will query/bind the mock ldap as usual. Step #1 mock = createMock(LdapContext or InitialLdapContext class) Step #2 Now I want to set some values in the ldap store, so I call mock.addToEnvironment(env name, env property), but the call fails with an exception. Could you post a simple test case to query/bind mock LdapContext ? Thanks in advance.</body>
  </mail>
  <mail>
    <header>Re: How to mock ldap</header>
    <body>I highly recommand you to read the documentation on  and then look out the samples in the EasyMock download bundle ( Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>I'm pretty sure this test case demonstrates what I think is a defect.</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>I'm getting lost. I did the test case below and it worked perfectly fine. A NPE was thrown an the test was successful. I'm using: JDK 1.5.0_15, cglib-nodep-2.1_3 and both EasyMock 2.4. All this on JUnit 4. What did you get? --------------------------------------------------------------------------------\ --------------------</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>The test should have failed.  With mockCAS.close() commented out, the fixture was not told to expect close() to be called, and it was called.  Phrased another way, the test behaves the same way regardless of if mocCAS.close(); is commented out, and it should not. --------------------------------------------------------------------------------\ --------------------</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>Ok, I looked a little more at the code. close() is called and as it should, throws an AssertionError since it shouldn't be called. However since close() is surrounded with a catch(Throwable e), as mentioned in the comment, it is swallowed. Thete's not much I can do about it... EasyMock is behaving correctly but just swallow a Throwable which is rarely if ever a good idea. However, I recently had the requirement to verify failed calls afterwards. It is useful for multithreaded and asynchronous testing. Ben, I haven't had the time to look at your code yet but I promise I will. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>That's interesting.  To me that implies that verification is done as soon as replay() is called, and not when verify() is called.  When verify() is called, shouldn't it have what methods were called and what ones were not?  Because when verify() is called, it's not in the try/catch around close().</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>2008/10/6 Timothy Reaves &amp;lt;treaves@...&amp;gt;: Hi Timothy, This is because you are using a 'strict' mock (created by calling createStrictMock, as you have done) in your test. This will fail the test immediately for a missing expectation. The other types of mocks (normal and 'nice') will, if I recall correctly, not fail the test until the verify() method is called. Hope this helps. Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>EasyMock will return an exception as soon as an unexpected call is done. Obviously, for a nice mock it never occurs since the mock will always nicely return null. For a strict mock it occurs when a call is not the next expected call. For a normal mock, when no call match the list of recorded calls. When an unexpected call occurs, the exception message will show the unexpected call and dump the list of still expected ones. The verify method on the other hand makes sure all expected calls where done. If not, it throws an exception dumping all expected calls that where never called. This seems quite logical and intuitive to me. On Mon, Oct 6, 2008 at 8:46 PM, Neil Greenwood</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>Hi Tim, Sure, I'll make a patch against Easymock Class Extension 2.4 and put it into the Files area over the next couple of days. -Ben -- *Ben Hutchison Senior Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 534 |</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>Hi Tim, Thanks for the defect report. I'll look into whether non-public classes can be supported in the reflection API. With createPartialMock(), remember its invoking an /actual constructor/ of the class with real arguments, as opposed to using the Objenesis library which "magically" create instances that might normally be impossible to instantiate. Therefore, usual the Java access rules will apply. -Ben -- *Ben Hutchison Senior Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 534 |</body>
  </mail>
  <mail>
    <header>Can Easymock mock super.aMethod() ?</header>
    <body>Im wondering if Easymock can mock the version of a method defined in a superclass, but not the subclasses version, eg: Can I interaction test Subclass.aMethod() using Easymock at the moment by mocking the super call? (I dont myself know a way). Ive run across this problem twice in the last week. If not supported, I might look into implementing this feature. I like the idea that Easymock should be able to handle _any_ situation that arises, no matter how ugly/convoluted the code you have need to test. That goal is getting pretty close now. -Ben -- *Ben Hutchison Senior Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 534 |</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>2008/10/7 Ben Hutchison &amp;lt;benh@...&amp;gt;: Hi Ben, With reflection, you can access non-public items by calling setAccessible(true) on the reflected item. A security manager can prevent this call from succeeding. That would work for calling a non-public constructor. You should be able to use Class.forName(...) or use the ClassLoader to load a non-public class's Class instance. HTH. Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Re: Can Easymock mock super.aMethod() ?</header>
    <body>Hi, I agree it's definitly a useful feature and would like to have EasyMock handling every situation too. Unfortunatly, mocking the super can't be done without class instrumentation at class loading from as far as I know. However, it might be possible to do something clean using class instrumentation. I never had time to look into it. It's a quite complex topic. Henri</body>
  </mail>
  <mail>
    <header>Re: Can Easymock mock super.aMethod() ?</header>
    <body>I guess I had a basic implementation plan when I raised the idea, based on reflective dispatch, here's a sketch: expectSuperCall(aMock.aMethod())  is intercepted specially. Using Class.getDeclaredMethods() we can determine the set of methods declared at each level of the inheritance tree. Thus, we can write an algorithm that determines the superclass Method object for the invoked method [ie the target of super.aMethod()] and mocks it. Theres a bit of "plumbing" to get behavior this into Easymock's structure, but from a brief look it seems feasible. -Ben -- *Ben Hutchison Senior Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 534 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Can Easymock mock super.aMethod() ?</header>
    <body>Re: the article, Im a big fan of partial mocking for the reasons it outlines. It presents a good workaround when you are testing code you can change. Unfortunately, sometimes you need to test legacy code or you cannot change the code because of impacts on other developers, components etc. -Ben  l -- *Ben Hutchison Senior Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 534 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Can Easymock mock super.aMethod() ?</header>
    <body>Hum. I won't be able to intercept the call to super. You have A a mocked class and B it's parent. When I mock A there's a proxy created that will invoke any call to A. Then the proxy has 2 choices, call the real A method or do something else. As soon as A is called, the real code will executed. If this code calls super.something(), that won't be intercepted by my proxy. It's a direct call to the base class. The only solution I can see is something like having the proxy getting the bytecode from the mocked method and execute it but by calling something else than super (your expectSuperCall recording). It's a long shot but might be possible.</body>
  </mail>
  <mail>
    <header>Re: Can Easymock mock super.aMethod() ?</header>
    <body>Yes, on consideration I can see you're correct. Yes, I now agree that bytecode manipulation will be needed to redirect super calls to a proxy. Ill investigate that route. -Ben -- *Ben Hutchison Senior Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 534 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>Hi Tim, Ive just uploaded my Partial Mocking Enhancements to Easymock in patch format against v2.4 (as output by Eclipse) to the files area. Let me know if you have any problems using it. Non-public classes not yet tackled. -Ben</body>
  </mail>
  <mail>
    <header>Re: How to mock ldap</header>
    <body>hi, Just like the example in documentation, Im trying to mock ldapcontext interface (aim is to mock Ldap store). But it doesnt work for me.. where am I going wrong? // TODO Auto-generated catch block // TODO Auto-generated catch block Exception I get: java.lang.IllegalStateException: missing behavior definition for the preceeding method call addToEnvironment("arg0", "arg1") at org.easymock.internal.MocksControl.replay(MocksControl.java:91) at org.easymock.EasyMock.replay(EasyMock.java:1502) at org.easymock.samples.ExampleTest1.addDocument(ExampleTest1.java:37) Thanks in advance.</body>
  </mail>
  <mail>
    <header>Re: How to mock ldap</header>
    <body>You're calling classUnderTest.add twice. Once in setup and once in addDocument. -- Jon Schewe | If you see an attachment named signature.asc, this is my digital signature. See For I am convinced that neither death nor life, neither angels nor demons, neither the present nor the future, nor any powers, neither height nor depth, nor anything else in all creation, will be able to separate us from the love of God that is in Christ Jesus our Lord. - Romans 8:38-39</body>
  </mail>
  <mail>
    <header>Re: How to mock ldap</header>
    <body>Since addToEnvironment is not returning void, you need to provide a return value. That's why EasyMock complains (I agree that the message can be improved). You should do something like:</body>
  </mail>
  <mail>
    <header>Re: mocking native ?</header>
    <body>Hello, In fact I never tried explicitly but couldn't why not. Since native method can be overloaded they can be mocked. I just tried and I've add a test about it. It works perfectly :-) Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: Maven repository</header>
    <body>Henri, Thanks for creating EasyMock.  It's a huge help in my unit testing. I've noticed that the maven2 central repository does not have any EasyMock version since 2.0.  Based on your message below, that doesn't sound like what you were intending.  Would you consider getting the latest release(s) uploaded into the Central Repository? Thanks, Jim</body>
  </mail>
  <mail>
    <header>Re: Re: Maven repository</header>
    <body>Ah, never mind.  I see that easymock moved to org/easymock:  Jim</body>
  </mail>
  <mail>
    <header>Re: Re: Maven repository</header>
    <body>For the records. Tammo Freese has created EasyMock. I'm only the happy current maintainer and the class extension creator (more or less... we are rarely alone these days). But thanks :-)</body>
  </mail>
  <mail>
    <header>Re: Feedback anyone???</header>
    <body>Hello Henry, Am 24.07.2008 um 03:17 schrieb Carlus Henry: if you typically have situations where you would like to use more than one mock, you may use an IMocksControl: Then, will switch all the mocks to replay mode, and will verify them all. Hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>EasyMock Class Extension 2.4</header>
    <body>Hello everyone, I've just delivered EasyMock Class Extension 2.4. It is the version compliant with the latest features included in EasyMock 2.4. Only one thing is missing: The serialization. It is not yet possible to serialize a class mock. BTW, I will be interested in knowing if someone wants the feature. This new version is available to download as usual at www.easymock.org and will be available in the maven central repository when the new synchronization occurs (twice a day I think). The release notes: Enjoy! Henri P.S.: To do the maven build, I used the maven shade plugin to embed Objenesis. It worked perfectly on the second attempt. I must say I was happily surprised so congratulation to the plugin developers. Why on the second attempt? Objenesis was flagged as provided. It seems the shade plugin is only able to include dependencies in compile scope. But it takes care of changing the scope to provided before installing the scope.</body>
  </mail>
  <mail>
    <header>Partial mocking enhancement patch posted in Files area of the YahooGroup site</header>
    <body>Hi Easymockers (esp. partial mockers) I have posted my Partial Mock enhancement patch-build in the Files area. Built against EasyMock Class Extension 2.3, this patch is similar to the one I posted about in March this year. It adds 2 powerful features for working with Partial Mocks; auto-mocking, and constructor-args matching. I would like this feature/patch be considered for the next release of Easymock Class Extension (Someone approached my privately about 2 weeks ago requesting a copy of this code. Sorry for the delay, Ive been ill. Enjoy.) Regards Ben Feature Explanation ================================================ The features are accessed via the new method: EasyMock.createPartialMock(Class toMock, Object.. constructorParameters) The above creates a partial mock by invoking the first constructor it finds of class "toMock" that matches the types of "constructorParameters". The constructorParameters can be empty of course, which invokes a no-arg constructor. Initially, the created mock has no methods mocked. During the record phase, any method that has behavior recorded on it is automatically mocked, on-demand. /Example: //invokes a constructor accepting 2 args of type String, Integer //these invocations automatically register those methods to be mocked //testing that doTask() delegates to doSubtask1() and doSubtask2() Note that in the presence of overloading, there may be multiple constructors that match the arguments, and the one chosen may not be the same one chosen by the compile-time Java syntax rules (which work on declared, not runtime, type). But in the vast majority of cases it works as expected.</body>
  </mail>
  <mail>
    <header>Re: Partial mocking enhancement patch posted in Files area of the YahooGroup site</header>
    <body>Thanks a lot for this feature. I'll surely have a look at it even if I sadly can't tell when. To make sure I won't forget, can you fill a feature request at  Thanks again, Henri</body>
  </mail>
  <mail>
    <header>Re: EasyMock Class Extension 2.4</header>
    <body>Hi, I'm sorry, can you provide me a complete test? The problem comes probably from generic and inheritance issues, not from EasyMock. I'll need a complete test to provide the answer. expectLastCall works because it doesn't need to accept in the andXXX the same type as what is returned by getPermissionAssignments like expect() does. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: EasyMock Class Extension 2.4</header>
    <body>It's an erasure issue. Since a wildcard is returned by getClazz, the compiler can't convert it to String.class. See this group archives for more details and links about capture and erasure (which I quite agree far from being an obvious concept). If the Foo class can't be change, the only solution I know is to do this: By erasing the type, will get a check warning but it will work. And since erasure are really obvious, I must confess I don't know what will be the clean way to fix it (I'm not quite sure there is a solution in fact) If somebody has an idea, I'll be really glad to know.</body>
  </mail>
  <mail>
    <header>Unacceptable coupling between test code and code under test with mocks</header>
    <body>I'm fairly new to the mock object thing, and have realized a few benefits from it.  Certainly I might've designed my code a bit differently had I known about this in the first place.  But it leads me to a problem: I have a REST back-end and my implementation was created via tests of the entire service, running in-container with a database.  This was easy to set up in my environment.  I'm now realizing it would be nice to test this code out of container via Mock Objects. My code operates on HttpServletRequest and HttpServletResponse.  If I mock these two classes, it is incredibly difficult to get any tests to pass, as I have to "expect" a large number of calls on these classes. Further, the calls that are made are highly dependent on the test data, so there is substantial logic required in creating these objects; essentially I have to just re-state the code under test in my test cases. This is of little value; if I refactor the code to behave the same, but change aspects of how HttpServletRequest/Response are used, my tests break. Since I didn't use mocks from the beginning, am I going to get any value after the fact? Dave</body>
  </mail>
  <mail>
    <header>Re: Unacceptable coupling between test code and code under test with mocks</header>
    <body>I think I would go for hand written stubs/mocks. One of the reasons is readability. Given the architecture of your app it seems HttpServletRequest and HttpServletResponse belong to your core domain and you're gonna have loads of tests that use them. With hand stubs/mocks you could do: HttpServletRequest r = new RequestStub(" HttpServletRequest r = new RequestBuilder() Drawback is that you have to write those stubs. Some libraries, like Spring offer something similar out of the box:  /web/MockHttpServletRequest.html but you probably don't want pull in all this spring stuff :) Cheers, Szczepan Faber</body>
  </mail>
  <mail>
    <header>Re: Unacceptable coupling between test code and code under test with mocks</header>
    <body>Subject to the caution about only reworking code that is "active"... it sounds like you're missing an abstraction level. In my world, I try to limit the HttpServlet implementations to just translating to/from strings into some domain objects (Single Responsibility Principle). Those domain objects should have cleaner interfaces and be easier to unit test. We wrote up some ideas at  S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>Re: Unacceptable coupling between test code and code under test with mocks</header>
    <body>I initially considered doing that, however my code potentially needed access to a lot of the information in HttpServletRequest, and I didn't want to create a useless proxy object.  That being said, there is code that bridges between the servlet call and the business implementations that probably could've stood a layer in between (for just this purpose). Dave</body>
  </mail>
  <mail>
    <header>Re: Unacceptable coupling between test code and code under test with mocks</header>
    <body>If you're using ObjectMother pattern, you only have to write this scaffolding once and then instrument it. For state-based testing (which you are kinda stuck with because of how you did your original test implementation), this is actually not too bad. I have used this on large systems with great success. But the real problem is your original implementation requires full in-container testing, which I would consider unacceptable on a large system. These types of tests are typically maintenance nightmares to begin with, typically don't hold up under refactoring, not to mention because they are end-to-end (not unit) tests. Don't get me wrong: you need some end-to-end integration tests, too. But what happens when you have 15,000 tests / 90,000 assertions  (which I have personally experienced on large systems), all of them requiring your full stack to be in place? Frameworks like Easy Mock with their Fluent Interface pattern implementation are a boon to such situations. In the final analysis, you're not testing the Servlet container, right? That should be considered a safe high-level substrate: you _should_ mock that wherever you aren't testing the actual wiring of your code to the container. Cheers, Nick</body>
  </mail>
  <mail>
    <header>Re: Unacceptable coupling between test code and code under test with mocks</header>
    <body>Well, I don't think out-of-container tests would've gotten me much in this case; My task was essentially to create a REST interface to existing business logic. I could have mocked out the data layer, but, in the end, that's not any better than establishing test data in the database and using it for in-container tests (except I can manipulate the test data in SQL if I need to change it; Java or XML are both pretty sucky as data storage languages for relational data). I grant, this may not be possible for all systems, but the in-container tests have worked out incredibly well.  They have stood up to significant refactoring and feature changes, and identified numerous quirks in Tomcat and MySQL that would've gone unnoticed if tested out of the container. I think *some* bits of the main engine could be effectively tested out of container, had my design been a bit different.  The problem with mocking the servlet container, as I mentioned in OP, is that I end up having to have intimate knowledge of how the code under test is using the Servlet specification, so that my mock objects respond to the calls they receive (and not the the ones they don't).  THAT kind of test code is unmaintainable. Dave</body>
  </mail>
  <mail>
    <header>Issue with partial mocks &amp;amp; expectations</header>
    <body>Hi people. I have an issue with partial mocks and expectations.  I have this code: MyClass mockMyClass = createStrictMock(MyClass.class, // Set the mocks expectations // Test the code. I am mocking out the public method close, and the protected method open. This works. Now, I want to insure the test works, so I comment out: and run the test, and as expected, I get an exception about a call being made to open that wasn't expected.  So, I uncomment that, and comment out: and my test still passes. This appears to be a defect.  Any ideas?</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>Hi, I did this: Using EasyMock CE 2.4. The test fails as expected. Can you give me your failing test case? Thanks, Henri On Tue, Sep 30, 2008 at 1:22 AM, Timothy Reaves</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>Off topic, but note that your test is exactly what my patch(*) addresses, by allowing you to replace the cumbersome: MyClass mockMyClass = createStrictMock(MyClass.class, with: ..and leave the rest of your test code as is, by auto-mocking each method as expectations are recorded. Further, it allows you to pass constructor arguments to createPartialMock(), should that be important to setup your part-mocked object correctly. -Ben * posted in files area Aug 30 and hopefully one day part of Easymock. -- *Ben Hutchison Senior Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 534 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>Hi Ben.  I'd really like to give your code a try, but am not sure how, as you didn't seem to create a patch.   Yes, I see that you've posted to the files section, but there is no ideation of how to use the jar ("Binary class extension files only." - so that needs to be in the classpath along with everything else?), and the .src (which should be .zip I think) builds what exactly? I hate to bother you, but could you create an actual diff, so that one can apply that diff to a checked out source tree?  That way, I can build in the traditionally way, without fear of doing it incorrectly. I'd think that would also make it easier to get into the code base eventually.</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>O.K., my sample code is below. I simply created that in Eclipse, added 2.4 of EasyMock and the class extension.  I set a breakpoint to insure close() is being called.  The test passes regardless of mockCAS.close(); being commented out or not.  With it commented out, it should fail, as close() is called and the mock was not told to expect it. I hope that I'm the bug, and am using it incorrectly.  That's much easier to fix! :) Thanks.</body>
  </mail>
  <mail>
    <header>Re: Issue with partial mocks &amp;amp; expectations</header>
    <body>2008/10/2 Timothy Reaves &amp;lt;treaves@...&amp;gt;: Hi Timothy, This error is caused by running code that was compiled for a later version of Java in an earlier version, e.g. running code for 1.5 under 1.4. What version of the JVM did you use when running your test? Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>easymock.org down?</header>
    <body>Over the past week or so it seems that easymock.org is down more than up. Is this a problem with the site or a problem on my end? -- Jon Schewe | If you see an attachment named signature.asc, this is my digital signature. See For I am convinced that neither death nor life, neither angels nor demons, neither the present nor the future, nor any powers, neither height nor depth, nor anything else in all creation, will be able to separate us from the love of God that is in Christ Jesus our Lord. - Romans 8:38-39</body>
  </mail>
  <mail>
    <header>Re: Enhanced version of Easymock class extension attached</header>
    <body>Hi EasyMockers About 6 weeks ago I posted an enhancement to EasyMock to better support partial mocking. I haven't had any interest/responses to this as yet. If anyone has tried using it please contact me. I work on a mixture of Java and Ruby based projects. An argument I often hear on from Ruby developers here on why Ruby is better for testing is the ease of partial- and constructor- mocking. My patched version makes partial mocking about as easy as it could be in Java. [Note it doesn't (and cannot) address the constructor problem without bytecode weaving.] So Im kind of puzzled by the lack of interest in applying these techniques in Java. My ultimate wish would be to get these enhancements integrated into EasyMock, so my team can use them without relying on a non-standard version. Henri, what is the criteria for doing this? Regards Ben -- *Ben Hutchison Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 354 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Re: Enhanced version of Easymock class extension attached</header>
    <body>Hi Ben, I'm not easymocker but I'm interested in the motivations behind the partial mocking idea. I also did some ruby/java projects I kind of believe that some common practices that are good in ruby world don't work out that well in java. Readability-wise partial mocking in java is not as elegant as in ruby. I don't find partial mocking practical as well - it doesn't seem to lead to quality &amp;amp; simple code (both: application code and test code). BTW it is exactly what I can read in easymock documentation for partial mocking: (...) "In this case, the first thing to do is to consider a refactoring since most of the time this problem caused by a bad design" (...). What's the selling point of partial mocking? Is it working with legacy code? I don't want start the flame war - I may be wrong and partial mocking is a good thing - it's just I'm interested in your motivations. If I used EM on my project I would discourage from partial mocking. OTOH, this feature is already in EM so maybe it makes sense to make the implementation 'complete' by merging your changes. But I guess it's up to the community &amp;amp; Henri to make the call. I'm neither (+1) nor (-1), however I would be -1 if partial mocking was not in EM in the first place. Cheers, Szczepan Faber</body>
  </mail>
  <mail>
    <header>Re: Re: Enhanced version of Easymock class extension attached</header>
    <body>I too have heard the "Partial Mocking is bad" story many time both within my own organization and in the wider community. For a while that negative message constrained my own practices, until I started thinking for myself and asked the question "/Why/ is partial mocking bad?" I couldn't find a reason that convinced me, and once I started applying the technique I found it a very useful addition to my tool set. Mocking is about testing the operation of a piece of code in isolation, by mocking out all of the code-under-test's interactions with the "outside world". Normally, you have a straightforward situation where the external message receivers (ie invoked methods) are external objects, and thus partial mocks aren't necessary. But other times, the collaborators are other methods of the same class that you don't want included in the test: this requires partial mocks. Examples are testing abstract classes, methods with unpleasant side-effects, legacy code, factory sub-methods, and methods that compose other methods. Why should you test this situation differently? What is justification for treating message receivers in the /same/ object asymmetrically from receivers in /other/ objects? I spend much of my day doing TDD on imperfect &amp;amp; heavily-constrained code that is running in production, and I have to justify time that I spend developing against business value delivered to the client. I got sick of having to use more expensive/difficult test techniques in about 5-10% of cases where partial mocks were needed. Now I watch some of my colleagues who are partial-mock-phobic labour with unwieldy tests that I could write in half the code using partial mocking. -Ben -- *Ben Hutchison Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 354 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Re: Enhanced version of Easymock class extension attached</header>
    <body>Allow me to disagree. The catch with partial mocking is that it leaves an implicit relationship implicit. If I'm having to substitute part of an object, then that implies that there's a seam within that class and that the best thing I can do is to crack it open so other people can see the join. I suggest you re-read Wirfs-Brock on Object Design. The whole point of the technique is to measure the things that do matter, the visible effects that an object has on its world, whilst ignoring the things that don't, its private implementation. If this is proving too hard, maybe your team is unit-testing at too fine grain a level. Partial mocking starts to lock down the implementation of a class, making the tests brittle and inhibiting change. I've worked on code with lots of class mocking, including partials, and it was a pig to figure out where the dependencies were. There may be good reasons for using partial mocks, particularly with constrained code, but I regard them as a work-around that I use very carefully. My main use of partial substitution within a class is for factory methods, and I tend to just subclass and override rather than use a framework. S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>Setting up default ArgumentMatchers</header>
    <body>Hi, Is there anyway to setup default ArgumentMatchers for particular classes? This would be very handy for dealing with 3rd party classes that don't implement equals, hashCode or toString. Perhaps something like: Thanks, Joel</body>
  </mail>
  <mail>
    <header>IMocksControl.createNiceMock?</header>
    <body>Hi, Thanks for EasyMock - I'm a very happy user. Has anyone considered adding createNiceMock and createStrictMock methods to IMocksControl? It's something I think I'd like, but maybe there's another way that I haven't thought of? Basically, I want to use the convenience of nice mocks at the same time as the convenience of IMocksControl. My use case is very like the one presented by Szczepan Faber in a message with the subject "beNice method" on Sep 10, 2007. It sounds like that proposed solution would also work for me - what's the status of that work? Cheers, Mick</body>
  </mail>
  <mail>
    <header>Maven repository</header>
    <body>Hi, Meanwhile ending EasyMock version 2.4 I've set up two maven repositories. One is the release one which is rsync with the maven central repository. The other is a snapshot one. You will find it here: For those who want to use the latest features, that would be the place to find them. I'll only deploy versions that contain complete and fully tested features. Soon, the latest snapshot documentation will also be available online. The sources jar should also follow. Enjoy! Henri</body>
  </mail>
  <mail>
    <header>How to test simple class using EasyMock</header>
    <body>Hello All, I am trying to use this framework for the first time. So I am new to this area. I did look for help but did not solve the issue. I am using EasyMock 2.3 Class Extension to test my POJO class as shown below. So how can I test my constructor ? I get following error when I run it. Testcase: testWithStrictMock took 0.266 sec Caused an ERROR missing behavior definition for the preceeding method call getFirstName() java.lang.IllegalStateException: missing behavior definition for the preceeding method call getFirstName() at org.easymock.internal.MocksControl.replay(MocksControl.java:61) at org.easymock.classextension.EasyMock.replay(EasyMock.java:117) at com.broadlane.components.business.test.jmock.EmployeeTest.testWithStrictMock(Emp\ loyeeTest.java:22) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) Thanks in advance -Hitesh My test class public void testWithStrictMock()</body>
  </mail>
  <mail>
    <header>Re: How to test simple class using EasyMock</header>
    <body>Hi you have to use MockControl control = MockControl.createControl(ClassWithNoDefaultConstructor.class,new because ur class have no default constructor. above statment is example of constructor with integer argument. i think this is helpful for u. com.broadlane.components.business.test.jmock.EmployeeTest.testWithStrictMock(Emp\ loyeeTest.java:22) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) -- Thanks &amp;amp; Regards, Pankaj Khare QA Engineer Rishabh Software Pvt. Ltd.</body>
  </mail>
  <mail>
    <header>CGLIB 2.2 final released.</header>
    <body>&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=56933"&gt; I'd appreciate if you could test with classextension and let me know if you run into any problems (it should be backward compatible).</body>
  </mail>
  <mail>
    <header>Re: CGLIB 2.2 final released.</header>
    <body>Hi, I just did the test (ran my unit tests). Compiled with 2.1_3, ran with 2.2: Ok Compiled with 2.2, ran with 2.1_3: Ok Compiled with 2.2, ran with 2.2: Ok So everything seems to be fine. Thanks :-) Do you know when it will be available in the maven repository? (so I'll update my pom) And also, is there a complete release note (including the betas) somewhere? Do you know if there was compatibility issues with other frameworks? (hibernate and spring for instance) Finally, you should update the README in the cglib-src.jar. It still talk about 2.1_3. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Constructor of a mocked Object</header>
    <body>I need the constructor of a mocked object, but til now I can't find a way. For my project I have to work with java reflection to create the mock objects. Example: Maybe one of you has the same problem before and is able to help me. thanks</body>
  </mail>
  <mail>
    <header>Re: Constructor of a mocked Object</header>
    <body>Hi, Why would you need to constructor? The mock is already instantiated. Anyway, when calling getConstructor, you need to pass the exact classes of the parameters in the constructor definition. If you pass the mock class, since the extends/implements the original class, it won't work. Cheers, Henri On Thu, Jun 26, 2008 at 5:01 AM, andreas.maller</body>
  </mail>
  <mail>
    <header>EasyMock 2.4</header>
    <body>Hi, I just delivered EasyMock 2.4. I noticed that it took one year to do so which makes me a little ashamed but at least it's done. It's available for download and should be replicated in the maven repository quite soon. Meanwhile you can use this: The release notes: Notes: Possible impacting issue: multithreaded environment. You might be a failure if you were (wrongly) doing it. Your test should be fixed accordingly. Changes: Enjoy! - Henri P.S.: Of course I'm highly interested to know any issue you might encounter P.P.S.: Next delivery will be EasyMock Class Extension 2.4 which will as usual close the gap with EasyMock 2.4 and implement serialization. The pending issues for EasyMock will be implemented afterwards and hopefully in less than one year.</body>
  </mail>
  <mail>
    <header>makeThreadSafe doesn't work with classextension</header>
    <body>EasyMock.makeThreadSafe(...) throws this exception when invoked on mocks created using org.easymock.classextension.EasyMock.createMock(...): java.lang.IllegalArgumentException: not a proxy instance at java.lang.reflect.Proxy.getInvocationHandler(Proxy.java:637) at org.easymock.EasyMock.getControl(EasyMock.java:1600) at org.easymock.EasyMock.makeThreadSafe(EasyMock.java:1630) at flintstone.spark.controller.impl.TrackShipmentsControllerImplTest.setUp(TrackShi\ pmentsControllerImplTest.java:131) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.junit.internal.runners.MethodRoadie.runBefores(MethodRoadie.java:122) at org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadi\ e.java:86) at org.unitils.UnitilsJUnit4TestClassRunner$TestListenerInvokingMethodRoadie.runBef\ oresThenTestThenAfters(UnitilsJUnit4TestClassRunner.java:152) at org.junit.internal.runners.MethodRoadie.runTest(MethodRoadie.java:77) at org.junit.internal.runners.MethodRoadie.run(MethodRoadie.java:42) at org.unitils.UnitilsJUnit4TestClassRunner.invokeTestMethod(UnitilsJUnit4TestClass\ Runner.java:91) at org.junit.internal.runners.JUnit4ClassRunner.runMethods(JUnit4ClassRunner.java:5\ 1) at org.unitils.UnitilsJUnit4TestClassRunner.access$000(UnitilsJUnit4TestClassRunner\ .java:40) at org.unitils.UnitilsJUnit4TestClassRunner$1.run(UnitilsJUnit4TestClassRunner.java\ :58) at org.junit.internal.runners.ClassRoadie.runUnprotected(ClassRoadie.java:27) at org.junit.internal.runners.ClassRoadie.runProtected(ClassRoadie.java:37) at org.unitils.UnitilsJUnit4TestClassRunner.run(UnitilsJUnit4TestClassRunner.java:6\ 4) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReferen\ ce.java:45) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:196)</body>
  </mail>
  <mail>
    <header>makeThreadSafe &amp;amp; reset</header>
    <body>Apparently, EasyMock.makeThreadSafe() must be called again after EasyMock.reset() is called upon it.  The docs should reflect this.</body>
  </mail>
  <mail>
    <header>Re: makeThreadSafe &amp;amp; rese</header>
    <body>I'll add it. Thanks.</body>
  </mail>
  <mail>
    <header>Re: makeThreadSafe doesn't work with classextension</header>
    <body>Hickes! That is expected since the class extension hasn't been delivered yet. (However, I forgot to mention it in the release mail) However, if you need it, the best workaround is to call (which should be hidden in the EasyMock.makeThreadSafe is such a method was currently existing). flintstone.spark.controller.impl.TrackShipmentsControllerImplTest.setUp(TrackShi\ pmentsControllerImplTest.java:131) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadi\ e.java:86) org.unitils.UnitilsJUnit4TestClassRunner$TestListenerInvokingMethodRoadie.runBef\ oresThenTestThenAfters(UnitilsJUnit4TestClassRunner.java:152) org.unitils.UnitilsJUnit4TestClassRunner.invokeTestMethod(UnitilsJUnit4TestClass\ Runner.java:91) org.junit.internal.runners.JUnit4ClassRunner.runMethods(JUnit4ClassRunner.java:5\ 1) org.unitils.UnitilsJUnit4TestClassRunner.access$000(UnitilsJUnit4TestClassRunner\ .java:40) org.unitils.UnitilsJUnit4TestClassRunner$1.run(UnitilsJUnit4TestClassRunner.java\ :58) org.unitils.UnitilsJUnit4TestClassRunner.run(UnitilsJUnit4TestClassRunner.java:6\ 4) org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReferen\ ce.java:45) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:460) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:673) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :386) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:196)</body>
  </mail>
  <mail>
    <header>Re: makeThreadSafe &amp;amp; rese</header>
    <body>Hello Henri, could you explain what this method is doing, and why the mocks are not thread-safe by default? Thanks, Tammo Am 04.07.2008 um 22:45 schrieb Henri Tremblay:</body>
  </mail>
  <mail>
    <header>Re: makeThreadSafe &amp;amp; rese</header>
    <body>Hi, By default, Easymock mocks can't be accessed concurrently between threads. From a technical point of view, it all starts in ReplayState. EasyMock will search in the recorded behavior in both threads and bring undertermined results (usually, one thread finds a recording and the other throws a ConcurrentModificationException). So from there I've allowed to synchronized access to mocks since it seems useful to be able to access a mock in multiple threads. However, I didn't want this behavior by default to make sure the tester is aware that the real implementation that is mocked should be synchronized. I also didn't want to hurt performance. The final thought was that to instead of having a random failure when using the mock in a threaded environment, to detect that state and throw a meaningful error. I hope that explains this new feature a little bit better than previously - Henri</body>
  </mail>
  <mail>
    <header>I forgot...</header>
    <body>Hum... I just noticed that I forgot something... Thanks to all of those who contibute ideas and code for EasyMock 2.4! Jan Van den Bergh (1963449) Howard Lewis Ship (1963449) Kim Dang (1975452) Szczepan Faber (1963442) Jonathan Locke (1895630) Mike Dunbar (1896509) I hope I didn't forget anybody. (just tell me) And thanks to all EasyMock users! - Henri</body>
  </mail>
  <mail>
    <header>Re: makeThreadSafe &amp;amp; rese</header>
    <body>Hello Henri, thank you for the explanation! Now I see why it makes sense to not meke the mocks thread-safe by default. Tammo</body>
  </mail>
  <mail>
    <header>Mock one method of a class under testing</header>
    <body>Hi, i have a problem! I'm testing a class called Stopwords. I want to test a method in isolation and i need to mock a method of class Stopwords, but only one method not the all class!! For this Project i must use JUnit3 and consequently easymock 2.0 , easymock classextension 1.2 because the EasyMock Class Extension 2.0_Pre-Release have too many problem and 1.2 is the only i find for JUnit3. My problem is : //test code public void testLoadStopwordsListStringArray()throws java.lang.reflect.Method[] mockMethod = new java.lang.reflect.Method[] MockControl ctrl = MockClassControl.createControl(Stopwords.class, //error: java.lang.NoSuchFieldError:UNORDERED_BEHAVIOR_FACTORY //error at org.easymock.classextension.MockClassControl.createControl(MockClassControl.java\ ) What does it means? How i can fix the problem? There's a too easy way? Thanks a lot!! Say goodbay to all.</body>
  </mail>
  <mail>
    <header>Re: Mock one method of a class under testing</header>
    <body>EasyMock 2 can be used with any version of JUnit. Is it totally independant from any testing framework (JUnit, TestNG, ...). However, you must have a least Java 1.4. If that is your case, I highly recommand to use EasyMock 2. BTW, EasyMock ClassExtension 1.2 won't work with EasyMock 2. Which explains your error. Cheers, Henri org.easymock.classextension.MockClassControl.createControl(MockClassControl.java\ )</body>
  </mail>
  <mail>
    <header>Re: Dubious error message</header>
    <body>Hello Peter, Yes and no. Due to argument matchers, there may be more than one expectation matching the additional call (keep in mind that per default, the order of the method calls is not checked). An example: Then the error message would look like add(isA(java.lang.String)): expected: 1, actual: 1 (+1) add(isA(java.lang.Object)): expected: 1, actual: 1 (+1) to indicate that *both* expectations could have matched the additional call. Hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>Re: Dubious error message</header>
    <body>I agree with you Peter, I expect this is the most common pitfall when learning to use EasyMock. I think it would be better changed to reflect the most common usage, and make the actual count reflect the actual count. -Ben -- *Ben Hutchison Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 354 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Partial Mock methods from an actual instance of an object</header>
    <body>Hi, So I was able to invoke the manager to go out to the database and setup the data to be passed into the constructor of the object I am trying to partially mock. Only now, I've run across an issue where I get the error saying: Caused by: java.lang.IllegalStateException: missing behavior definition for the preceding method call It seems that during the constructor call, a method within the object to be mocked is called (ie. a method that is accessing a member that was previously setup up, and then later called during the constructor call). Is there any way to allow to the "real" method to be called during the constructor call? I'm hoping that the functionality to pass in an actual instance of an object to a partial mock will be added. It would be greatly appreciated! Along with avoiding the error above, I can also avoid going out to the database (ie. deserialize the object). Thanks Jerry using edit/view. object's existing was need Class think file) then an way to partially</body>
  </mail>
  <mail>
    <header>Re: Dubious error message</header>
    <body>So (+1) isn't supposed to mean the difference between expected and actual, but something like "and potentially one more"? I'd suggest to add this to the documentation, otherwise it's really hard to understand. Anyway, thanks for the explanation! Cheers, Peter</body>
  </mail>
  <mail>
    <header>Re: Re: Partial Mock methods from an actual instance of an object</header>
    <body>Do you have the authority to go in and change this code? The hole just seems to be getting deeper and deeper. for example, you change the constructor to be really simple (suitable for testing) and add a helper static method to do all the cleverness to set up an instance. S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>Re: Re: Partial Mock methods from an actual instance of an object</header>
    <body>Sorry, I wasn't clear. I meant does the OP have the authority to go in and change /his/ code. I didn't mean Easymock. S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>Mocking a FileInputStream</header>
    <body>Let me start out by saying that I'm new to the idea of mock objects. I think they're really neat, so it could be that I'm trying to misuse them. Like using a hammar for every projects... As I was writing some unit tests yesterday, I decided to try and mock the FileInputStream with EasyMock's class extension. This worked out fine, allowing me to record calls on the FileInputStream class and verify those calls. However, what I really wanted to do was put some fake info into the FileInputStream so that I could test the my class got that info out correctly. This doesn't seem possible with EasyMock. But I started realizing that it felt like I was trying to hack something together that EasyMock was never meant to handle in the first place. So I guess I have two questions. First, is mocking the FileInputStream even a good idea? I could write my own mock FileInputStream class, but it seems then that I might as well create the actually file with the contents I'm trying to test. Is the layer of isolation provided by a mock FileInputStream really worth it? Second, if it is worth it, is there a way to mock the FileInputStream class, so that when the read(byte[]) method is called on it, some actual data is put into the byte[]? I know this is a rather long post and I apologize. I'm just new to the idea of mock objects and am still trying to figure out how they fit into my unit tests. Thanks in advance.</body>
  </mail>
  <mail>
    <header>Re: Mocking a FileInputStream</header>
    <body>Jason, Thanks for the post. I think your hunch is right. Mocking might not be the best approach for this case, since it will be burdensome to figure out all the correct calls to make, especially for the FileInputStream class extension. Can you change your code to accept an InputStream instead? If so, you're golden: You can then easily use an existing implementation to provide the data you need. If not, yes, simply creating a sample data file is a good approach. One more step, but I've done it many times. Andy</body>
  </mail>
  <mail>
    <header>Re: Partial Mock methods from an actual instance of an object</header>
    <body>Hi, Sadly don't have the privileges to change that code. But, on top of solving my issue, I think it would be useful for others too since they can pass in a serialized object. Jerry in hole the instance. and I am that during of avoid</body>
  </mail>
  <mail>
    <header>Re: Mocking a FileInputStream</header>
    <body>Thanks for the replies, Andy and Henri. I've decided to just use some test files with known data for this part of my testing. I appreciate the example of how to modify the input parameters, but honestly, that seems like a lot of extra work for this case. I'm really just calling the read() method once on the FileInputStream, so there really isn't much interaction to be tested. More the state, in this case. Thanks again for the replies. Jason change example: approach. One objects. I mock felt like meant write test. Is FileInputStream to the</body>
  </mail>
  <mail>
    <header>Mock Classes</header>
    <body>Hi, I'm new to using Easymock, I was wondering if it's possible to verify a method call to a mocked class that is an expected return from a mocked interface. This is what it looks like in my code: My problem is, I can't verify the mockEntity.setProperty(true) call. Whether the actual code calls it or not, the test always passes. Thanks in advance for the help.</body>
  </mail>
  <mail>
    <header>Re: Mock Classes</header>
    <body>I think you want something like this: expectLastCall() hope this helps Andy</body>
  </mail>
  <mail>
    <header>Capturing objects</header>
    <body>Hi, In one of my projects I had the following (pseudo-)code I wanted to unit test: The unit test had to be as complete as possible. It had to check that a correctly initialized X was passed to the transformer and that the same X was returned from the method. In the end, I wrote a custom IArgumentMatcher that is able to capture the object passed to it. A unit test looks like this: Could you tell me if there is any other way to test this with Easymock (without changing the interface of the service or the transformer)? If not, and if you're interested, I'd be happy to share this code with you. Best regards, Jan Van den Bergh</body>
  </mail>
  <mail>
    <header>Re: Mock Classes</header>
    <body>Andrew, Actually, its not required to use expectLastCall() for void methods in Easymock 2.x. Simply calling a void method during the replay phase will record an expectation. expectLastCall() is for multiple calls or other non-default cases. I made the same mistake for while until someone pointed this out to me. -Ben PS itstimeforanap, Yes, Easymock does that - your code should work fine as presented, providing "mockEntity" really is a mock. -- *Ben Hutchison Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 354 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Mock Classes</header>
    <body>Oops, I meant to say "record phase" above. -Ben</body>
  </mail>
  <mail>
    <header>Re: Capturing objects</header>
    <body>In that case, is it possible that this behaviour is included in easymock? I already have the code for this (including unit tests) and don't mind donating it to the easymock project. Jan. capture compare</body>
  </mail>
  <mail>
    <header>anyObject() with generic type</header>
    <body>Hi, This is a difficult one for me, i tried to read the doc and can't find any: here is a test: @Test listed at end, if i use a real String instead of anyObject() it will work // some code to test here java.lang.IllegalStateException: 2 matchers Expected :init Actual   :init (ExpectedInvocation.java:26) at org.easymock.internal.RecordState.invoke(RecordState.java:64)</body>
  </mail>
  <mail>
    <header>Re: anyObject() with generic type</header>
    <body>If you use one argument matcher (anyObject(), isA(), etc) as an expected method argument, then ALL arguments must be a matcher. For example, try tc.set(isA(Class.class), (String)anyObject()) and that should get rid of the IllegalStateException. This is a limitation of EasyMock and the use of argument matchers.</body>
  </mail>
  <mail>
    <header>Re: mock object</header>
    <body>As well as Tim's response, there's another problem with what it seems like you're trying to do: toString(), equals(), and hashCode() can not be mocked, but return details about the mock object itself. As Tim requested, more details of what you're trying to accomplish would help us to help you. Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Improving partial mock support in Easymock</header>
    <body>Hi EasyMockers, I make extensive use of EasyMock on a day-to-day basis as my primary method of unit testing. This includes mocking of classes (rather than interface) and partial mocking, which I find invaluable for: - Testing internal methods of implementation classes in isolation - Mocking legacy code - Testing abstract classes I find the partial mocking API exposed by EasyMock 2.3, with its need to generate a Method[] array, a bit cumbersome and error prone. I find mode used by RhinoMock (.NET) superior: a partial mock starts with no methods mocked, and then  automatically mocks any method that has expectations recorded on it before replay(). As well as being easier to work with, it has the advantage that IDE renames of partially mocked methods are properly handled. //Example: //these invocations automatically register those methods to be mocked //testing that doTask() delegates to doSubtask1() and doSubtask2() The second limitation in EasyMock partial mock support is default behavior re: not calling the partial mocks constructor. Where a no-arg constructor exists, even private, I typically would like EasyMock to try to call it, and only then fall back on the current "magic" instantiation provided by the (excellent) Objenesis library. But creating a ConstrutorArgs object is more effort than I would prefer. I am currently working on a patch to EasyMock that provides both the above improvements. They fit nicely together, in that (by removing Method...) it becomes possible to offer a mock creation method signature like: createPartialMock(Class&amp;lt;T&amp;gt; toMock, Object constructorArg...) ...that constructs an auto-method-mocking partial mock, and allows convenient constructor-arg passing as well. I though I would share my ideas with the community at this stage, in order to gather feedback and reactions to this proposal. Once finished, I would be pleased to see my work incorporated into EasyMock, and so I want to ensure others are happy with the direction I take. -Ben PS Can I also throw an opinion out there: If classextension.EasyMock.* methods behave exactly like EasyMock.* methods for interfaces, but additionally support concrete classes, why not collapse both them into one library and end the confusion of two versions of EasyMock? -- *Ben Hutchison Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 354 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Improving partial mock support in Easymock</header>
    <body>To follow up my previous with, I like to put a question to the Easymock developers in how they would prefer I implement the auto-add-on-record for mocked methods for partial mocks. The change revolves around modifying the behavior of the MockMethodInterceptor (ClassProxyFactory line 60). Currently, it contains a switch that directs method invocations on the mock to either (a) the real object being partially mocked, or (b) the usual MockInvocationHandler, depending on whether the invoked method is in a Set&amp;lt;Method&amp;gt; that it gets at creation time. In an auto-add-on-record mode, the Set may be initially empty. As each invocation is intercepted, the switch need to decide what to do based upon the IMocksControlState of the relevant control: - if in RecordState, the invoked Method is added to the set, then the call is passed onto the MockInvocationHandler. - If in ReplayState, the behavior is as present (ie previous paragraph) Thus, the MockMethodInterceptor requires a reference to the relevant IMocksControl, to query the current state. Presently, this is difficult: the interceptor is created within the call to classProxyFactory.createProxy(Class&amp;lt;T&amp;gt; toMock, InvocationHandler handler), so the IMocksControl isnt made available when the proxy is factoried. Nor is it made available when the proxyFactory is instantiated, at MocksControl.createProxyFactory(Class&amp;lt;T&amp;gt; toMock). In short, the current design assumes that a proxy factory need not know about the IMocksControl to create proxies, and the auto-add-on-record violates that. Heres two solution options. I think (1) is clearly cleaner - does anyone disagree? 1. [Recommended] Change:   MocksControl.createProxyFactory(Class&amp;lt;T&amp;gt; toMock) to:           MocksControl.createProxyFactory(Class&amp;lt;T&amp;gt; toMock, IMocksControl control) 2. In createProxy(), downcast InvocationHandler -&amp;gt;MockInvocationHandler, and then use getControl(). -Ben -- *Ben Hutchison Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 354 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Re: Improving partial mock support in Easymock</header>
    <body>Actually, the change is easily accomplished by changing the implementation of MocksClassControl.createProxyFactory(). There is not the difficulty I mentioned in my last message. -Ben -- *Ben Hutchison Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 354 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Partial Mock methods from an actual instance of an object</header>
    <body>Hi, I know that the class extension for EasyMock allows for partial mocking of methods, and if the methods haven't been partially mocked then the "real" method is called.   This is functionality that I was looking for, except that when calling the "real" method, it is calling an object that was newly created.  I was wondering if there is a way to pass in an existing instance of an object, and from there partially mock some of the methods from that object? Thanks Jerry</body>
  </mail>
  <mail>
    <header>Re: Improving partial mock support in Easymock</header>
    <body>Is there any reaction/opinion to my proposal to improve how partial mocks work? I have a working version of the class extension with the auto-mocking behaviour I described. Henri, are you interested in incorporating it into EasyMock? -Ben need to mode methods with, it try instantiation signature protected copying the removed.</body>
  </mail>
  <mail>
    <header>Enhanced version of Easymock class extension attached</header>
    <body>Hi Easymockers (esp. partial mockers) I have attached a first-draft enhanced version of the EasyMock Class Extension, which adds 2 powerful new features for working with Partial Mocks, accessed via the new method: EasyMock.createPartialMock(Class toMock, Object.. constructorParameters) The above creates a partial mock by invoking the first constructor it finds of class "toMock" that matches the types of "constructorParameters". The constructorParameters can be empty of course, which invokes a no-arg constructor. Initially, the created mock has no methods mocked. During the record phase, any method that has behavior recorded on it is automatically mocked, on-demand. /Example: //invokes a constructor accepting 2 args of type String, Integer //these invocations automatically register those methods to be mocked //testing that doTask() delegates to doSubtask1() and doSubtask2() Note that in the presence of overloading, there may be multiple constructors that match the arguments, and the one chosen may not be the same one chosen by the compile-time Java syntax rules (which work on declared, not runtime, type). But in the vast majority of cases it works as expected. This is a first draft, so please provide feedback/bugs. I would like to see this feature make its way into a future version of the class extension library. -Ben -- *Ben Hutchison Developer * Level 2 476 St Kilda Road Melbourne VIC 3004 T 613 8807 5252 | F 613 8807 5203 | M 0423 879 354 | This e-mail (and any attachments to this e-mail) is for the exclusive use of the person, firm or corporation to which it is addressed and may contain information that by law is privileged, confidential or protected by copyright. If you are not the intended recipient or the person responsible for delivering this e-mail to the intended recipient, you are notified that any use, disclosure, distribution, printing or copying of this e-mail transmission is prohibited by law and that the contents must be kept strictly confidential. If you have received this e-mail in error, kindly notify us immediately on + 613 8807 0168 or respond to the sender by return e-mail. The original transmission of this e-mail must be destroyed. Internet Business Systems Australia Pty Ltd accepts no responsibility for any viruses this e-mail may contain. This notice should not be removed.</body>
  </mail>
  <mail>
    <header>Dubious error message</header>
    <body>The following code... ... gives this error (EasyMock 2.3): java.lang.AssertionError: Should it not be "actual: 2 (+1)"? Cheers, Peter</body>
  </mail>
  <mail>
    <header>Re: Is it possible to mock final class with easymock class extension??</header>
    <body>That works technically, but I think it's missing something. If there's an external relationship that causing problems, then wrap the whole thing behind an interface and write a thin veneer. The test is trying to tell you that there's a seam in the design that should be made explicit. The interface should be written in terms of your domain and the veneer translates between the that and the external code. S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>serializability</header>
    <body>when using easymock to do testing under the wicket framework, it is necessary for wicket to test serializability of components.  unfortunately, easymock adds non-serializable fields resulting in exceptions like this: Caused by: java.io.NotSerializableException: org.easymock.internal.ObjectMethodsFilter at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1081) at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1375) at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1347) at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1290) at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1079) at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1375) could these fields be made transient so that they wouldn't change the serializability of the objects they are being added to? thanks,</body>
  </mail>
  <mail>
    <header>Protected methods mocking???</header>
    <body>Hi I have one question Is is possible to mock inherited protected method(s)? Consider the following test cases public void testMyName() MyName mockmyname = control.createMock(MyName.class, MyName.class.getSuperclass().getDeclaredMethod("checkName", // here some expectancies and return  values // but it is not working</body>
  </mail>
  <mail>
    <header>Re: serializability</header>
    <body>All Wicket components and models must be Serializable to be valid due to requirements for transparent clustering. There is a serialization checker that runs to ensure this is the case, but also in the course of testing, components may be serialized into the page store as below. If there is no easy way to do lazy init of these transient fields (perhaps an object initializer block reconstructing them on deserialization), it would be a helpful measure to simply make the mock classes serializable even if it does produce deserialization classloader problems.  In many Wicket tests, the components will never be deserialized anyway. Ultimately, if it were possible, it would be best for the CGLIB proxy to also be reconstructed on deserialization. I don't really know the details of EasyMock yet though as I have inherited the code I'm working with here. at org.apache.wicket.util.io.SerializableChecker.check(SerializableChecker.java:342\ ) at org.apache.wicket.util.io.SerializableChecker.checkFields(SerializableChecker.ja\ va:610) at org.apache.wicket.util.io.SerializableChecker.check(SerializableChecker.java:533\ ) at org.apache.wicket.util.io.SerializableChecker.checkFields(SerializableChecker.ja\ va:610) at org.apache.wicket.util.io.SerializableChecker.check(SerializableChecker.java:533\ ) at org.apache.wicket.util.io.SerializableChecker.writeObjectOverride(SerializableCh\ ecker.java: 678) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:298) at org.apache.wicket.util.io.IObjectStreamFactory$1.writeObjectOverride(IObjectStre\ amFactor y.java:73) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:298) at org.apache.wicket.util.lang.Objects.objectToByteArray(Objects.java:1085) at org.apache.wicket.protocol.http.pagestore.AbstractPageStore.serializePage(Abstra\ ctPageSt ore.java:198) at org.apache.wicket.protocol.http.pagestore.DiskPageStore.storePage(DiskPageStore.\ java:70 8) at org.apache.wicket.protocol.http.SecondLevelCacheSessionStore$SecondLevelCachePag\ eMa p.put(SecondLevelCacheSessionStore.java:337) at org.apache.wicket.Session.requestDetached(Session.java:1360)</body>
  </mail>
  <mail>
    <header>Problem in expectation</header>
    <body>Hi, I'm trying to unit test with easymock on an existing class, following is a simplified version, problem is, I always get error: java.lang.AssertionError: I know the problem is the object passed to service.save in the class Store is different from the one in the test code, one way to pass the test is, restructure the code so that same object can be passed to the two calls, but quite difficult as the code is already there and that's also a very common approach like: // assign some values here any idea how to specify this kind of expectation? Thanks. // collaborator // object under test // test code</body>
  </mail>
  <mail>
    <header>Re: Problem in expectation</header>
    <body>Thanks, any short sample code for that?</body>
  </mail>
  <mail>
    <header>Re: serializability</header>
    <body>Sorry it's taken so long to get back to you. I am not 100% sure, but I think that's it, yes.  I am currently slammed, but as soon as I can, I'll check with the person who wrote all these tests on this. It seems like making easy mock objects and their method references and other recording metadata Serializable should be at least a good first effort, regardless. Thanks for your patience! org.apache.wicket.protocol.http.SecondLevelCacheSessionStore$SecondLevelCachePag\ eMa</body>
  </mail>
  <mail>
    <header>Beginner's question - chained invocation</header>
    <body>I'm starting to use EasyMock again after a long drought (I was a beginner back then, too).  I'm trying to see that a following method is called in a chained invocation: context.getReqCompletion().setCompletion(ReqCompletion.NORMAL, I have my mock object created here: I've tried to make sure the above chained method is invoked with no success (I can't exactly remember all the options I tried, but it was something like this - I just could never get it to work), e.g. org.easymock.EasyMock.expect(mockContext.getReqCompletion().setCompletion(ReqCom\ pletion.NORMAL, Obviously, it didn't work.  So I resorted to the following: org.easymock.EasyMock.expect(mockContext.getReqCompletion()).andReturn(EasyMock.\ Unfortunately, this will then take almost anything - e.g., if the following is called, the test will still pass: context.getReqCompletion().setCompletion(ReqCompletion.ERROR, "blah, What am I doing wrong?  Thanks in advance.</body>
  </mail>
  <mail>
    <header>Re: Beginner's question - chained invocation</header>
    <body>Hi Isli, I think you have to make chained expectations with several mocks in order to tests for your chained invokations, e.g. like this // or - if setCompletion() does not return anything I hope that somebody corrects me by showing an easier way to expect chained invokations where only the last invokation really matters (which, btw, is often an indication that the systems architecture needs refactoring, see Law of Demeter / Principle of Least Knowledge). Doei Malte</body>
  </mail>
  <mail>
    <header>Re: Beginner's question - chained invocation</header>
    <body>that's why it's _supposed_ to be clumsy to mock :) S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>Re: Beginner's question - chained invocation</header>
    <body>Well, now it all makes sense... ;-) Doei Malte Schwerhoff</body>
  </mail>
  <mail>
    <header>Re: serializability</header>
    <body>Okay, I've checked on this and yes indeed, that's exactly our use case. Thanks, org.apache.wicket.protocol.http.SecondLevelCacheSessionStore$SecondLevelCachePag\ eMa</body>
  </mail>
  <mail>
    <header>After calling an unexpected method, subsequent calls to expected methods fail</header>
    <body>Running the main method of this class demonstrates the issue. ----- ---- To me it seems like a bug that mocks report expected calls as unexpected, after any call to an unexpected method. At the very least, the error message is misleading because it only says that the expected method call was unexpected. I'm sure it's probably the case that you would normally be calling the unexpected method as part of a test, fail before you ever try and make a subsequent call on the expected method, and this wouldn't matter. But due to one of the automated testing tools that we use this isn't desirable. I would like subsequent calls to expected methods to behave based on the recording. Is this reasonable? BTW I am new to EasyMock and think it's a really great tool. Thanks, Mike</body>
  </mail>
  <mail>
    <header>Re: After calling an unexpected method, subsequent calls to expected methods fail</header>
    <body>Hi Mike, I haven't tested this answer, but you might get the results you want by using a 'nice' mock: instead of calling createMock(TheInterface.class), try createNiceMock(TheInterface.class). HTH Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Re: Protected methods mocking???</header>
    <body>Hi Thanks for the clue, but the way i am doing is right or wrong??? "MyName.class.getSuperclass().getDeclaredMethod("checkName", Please let me know!!</body>
  </mail>
  <mail>
    <header>Has a Bug Been Filed For This?</header>
    <body>Is this the correct place to submit EasyMock bugs? Has this been filed? I understand that createNiceMock() represents a work-around, but I think that expected method calls should ultimately not report that they are unexpected. Thanks, Mike</body>
  </mail>
  <mail>
    <header>how to specify this ?</header>
    <body>Hi, I have this interface: in the class under test, i have a line: Query q = dbServices.getSession().createQuery("from documents where usr = Now, how to specify this expectation? I tried following, but cant complete it: expect(dbServices.getSession()).andReturn(session);  // this only specify the firat half, any sample to do this? Thanks.</body>
  </mail>
  <mail>
    <header>Instance variables and static methods</header>
    <body>Hi I'm a newbie to easymock. After reviewing the forum email, I have following questions. 1. I'm using easymock class extension 2.2.2 Do I need to wait till 2.3 release or there other workarounds? 2. What is the best approach to mock a static method call? thanks Chandru Ganesan</body>
  </mail>
  <mail>
    <header>How to further restrict anyObject() in expect(..) call</header>
    <body>Hi One of my mock methods expect a parameter which is an instance of Object. See the sample below. my test code In my unit test code, I have something like this: I cannot pass anyObject() as param to expect(..) as the mocked method expects an instance of class Param1. Hope I was able to state the problem clearly! Any ideas much appreciated thanks Chandru Ganesan</body>
  </mail>
  <mail>
    <header>Re: How to further restrict anyObject() in expect(..) call</header>
    <body>the sample below. my test code an instance of class Param1. There may be a misunderstanding here, or you might understand correctly and want to ensure that the real code passes a Param1 instance. I'll deal with the latter first, since it's easier... You can assert that the parameter must be an instance of Param1 using the following code in your unit test: This will fail if an object of a type other than Param1 is passed in. Depending on your requirements though, this can often be enforced by the signature of the ClassB.method1 method. The misunderstanding might be that you think that the line you quoted from your unit test actually calls the mock - it doesn't, it just sets the expectations for when you exercise the real code. I hope I'm not underestimating your knowledge, but your previous mail did say you were new to EasyMock. So the bit where you had the ??? in your example just specifies what is acceptable when you call the ClassA code in your unit test after setting the mocks into Replay mode. In this case, '(Param1) anyObject()' may be just what you want... And I hope I've answered the question you were trying to ask :-) Cofion, Neil.</body>
  </mail>
  <mail>
    <header>Re: How to further restrict anyObject() in expect(..) call</header>
    <body>Am 04.12.2007 um 01:20 schrieb Ganesan, Chandru: You may either cast it: or use isA() (this requires the Object to be != null, like instanceof) Cheers, Tammo Freese</body>
  </mail>
  <mail>
    <header>Question</header>
    <body>I am getting the following error java.lang.AssertionError: Here is what I have [Test Code] [End of Test Code] [User Service Code] [End of User Service Code] I dont know what I am doing wrong</body>
  </mail>
  <mail>
    <header>Null Pointer Problem</header>
    <body>Hi, I have a small hitch. I have two Hashmap(s). Contents of two maps are: According to code if a method receives the aforementioned Map(s), in its parameters then it will search for the null value and fill it up according by a string value( for ex.Map1 will become like this Now my map matcher is getting an exception of the Null Pointer, since one of the key has null as a value any ideas how to get rid of the null pointer assignment??</body>
  </mail>
  <mail>
    <header>Automatically generating getter and setter easymock tests</header>
    <body>Hi! I use unit testing together with Clover. I generally don't waste time creating tests for simple getters and setters, but this means that they show up as un-tested in Clover. It would be good if there was an eclipse plug-in or macro that could inspect a class and create an EasyMock test that sets and gets fields in a test. Has anyone written anything like that, or have an idea of how one would go about doing it? Thanks! Gustav</body>
  </mail>
  <mail>
    <header>Re: Automatically generating getter and setter easymock tests</header>
    <body>Hello Gustav, generally, this should not be necessary, as other parts of the code should use the getters and setters, and they are tested as a by-product. An example: ... ... parse() may call setFirstName() and setLastName(), the test uses getFirstName() and getLastName(). If the getters and setters are never used, maybe they are not needed? Cheers, Tammo Freese</body>
  </mail>
  <mail>
    <header>can easymock do this?</header>
    <body>Hi, Just started learning EasyMock, I listed my test case source code at end of the message, with that I was able to test if MyGet's getIt call IGet or not, now I want to proceed my coding in the MyGet's getIt, I'd like to iterate the list and use them to do something, how to tell EasyMock to return something concret, example: "String1", "String2", etc, possible with EasyMock? Thanks.</body>
  </mail>
  <mail>
    <header>Mocking a class.</header>
    <body>Hi folks, sorry that I aks such a basic and hopefully simple question but how am I supposed to create a mock for a class? In prior versions it was done like this: MockControl myClassControl = With the newer Versions of EasyMock this method is deprecated. When using the new way by doing a static import like this ... I get an exception: java.lang.IllegalArgumentException: MyClass is not an interface at java.lang.reflect.Proxy.getProxyClass(Proxy.java:362) at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:581) at org.easymock.internal.JavaProxyFactory.createProxy(JavaProxyFactory.java:12) at org.easymock.internal.MocksControl.createMock(MocksControl.java:37) at org.easymock.EasyMock.createMock(EasyMock.java:60) ... Can someone point me to the replacement method for the old way of class-mocking? Thanks in advance. Greetings PeeR</body>
  </mail>
  <mail>
    <header>Re: EasyMock Class Extension 2.3 is out!</header>
    <body>Thanks! Merry Christmas and A Happy New Year! ./alex -- .w( the_mindstorm )p. TestNG co-founder EclipseTestNG Creator</body>
  </mail>
  <mail>
    <header>java.lang.NoClassDefFoundError: net/sf/cglib/proxy/Factory</header>
    <body>Seeing this error when trying to create a mock of an abstract class while running unit tests under Ant. This does NOT happen while running the same unit test under Eclipse. And we have no problem creating mocks of other (non-abstract) classes under Ant and successfully executing such tests. The problem is only when the test requires a mock of an abstract class and we run the test under Ant (outside of Eclipse). The net/sf/cglib/proxy/Factory class is in our Ant classpath. Could it be that EasyMock does some kind of manual class loading in the case of abstract classes and so the classpath we specified is not getting used? Stack trace from the error follows. The NoClassDefFoundError appears towards the end. Testcase: testMethod1 took 0.437 sec java.lang.reflect.InvocationTargetException--&amp;gt;null (AbstractClassGenerator.java:237) (Enhancer.java:377) (Enhancer.java:317) org.easymock.classextension.internal.ClassProxyFactory.createProxy (ClassProxyFactory.java:105) (MockControl.java:133) (MockClassControl.java:189) (MockClassControl.java:194) org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:36) removed&amp;gt;.OverviewBaseViewHelperTest.createMockPageContext (OverviewBaseViewHelperTest.java:174) removed&amp;gt;.OverviewBaseViewHelperTest.createBaseViewHelper (OverviewBaseViewHelperTest.java:166) removed&amp;gt;.OverviewBaseViewHelperTest.testMethod1 (OverviewBaseViewHelperTest.java:52) (Native Method) (NativeMethodAccessorImpl.java:85) (NativeMethodAccessorImpl.java:58) (DelegatingMethodAccessorImpl.java:60) (Unknown Source) (DelegatingMethodAccessorImpl.java:62) (ReflectUtils.java:384) (AbstractClassGenerator.java:219) net/sf/cglib/proxy/Factory (ClassLoader.java:800)</body>
  </mail>
  <mail>
    <header>unexpected argument matcher calls</header>
    <body>EasyMock is using a different argument matcher than I expect in the attached example.  Can anyone please tell me why this is?  (I've tried to produce a simplified example here.  I know that the code in this form no longer makes as much sense, but the original test and production code did.) The point of what I've written is to capture an argument passed to the mock and use it to indirectly poke at the object under test.  (In this case, I wanted to quickly simulate the passage of time, but keeping and using a method argument like this seems to be a fundamental need.) This technique has worked well for me in the past, and the Google tells me that the Tapestry guy had independently arrived at a virtually identical solution, right down to the naming of the thing. However, I ran into  trouble when I began to use this solution while invoking the same mock method more than once.  The capturing argument matcher I give during the first recorded invocation will be used again by EasyMock to attempt to match both the first and the second actual invocations. One last note... I'm aware of IAnswer as a callback hook, but that doesn't seem useful for void-returning methods.  I'm confident I can work around this behavior, and already have a hack, but working around it is not the point of my post.  I'm just eager to learn why the behavior isn't what I had expected, because have only guesses as to why EasyMock does this. Thank you.</body>
  </mail>
  <mail>
    <header>Why are bridge methods not mocked?</header>
    <body>Henri, what was the rationale for not mocking bridge methods? It would seem that a bridge method should be mocked just like a regular method, since if it is not there seems to be no way to ever mock the method. No? The JDK 6.x compiler is creating bridge methods in cases where the eclipse compiler does not. From reading the language spec, it appears that eclipse is doing the right thing and the JDK is creating unnecessary bridge methods. Of course at runtime, the behavior is the same with or without the bridge methods. But after an upgrade to 2.3 we have a few tests that failing because during a record on a method -- when compiled with the JDK -- the method has been bridged [in the subclass] and hence the actual implementation is called. -barry ----</body>
  </mail>
  <mail>
    <header>Re: Why are bridge methods not mocked? A Fix</header>
    <body>It seemed to me that using proxy.invokeSuper(...) for bridge methods will never create the desired result (ie, that the method record happen). So I did a quick experiment as shown below: With this code, the bridge method is skipped over but the true method is recorded. (The spring class BridgeMethodResolver is not trivial piece of code however.) -barry</body>
  </mail>
  <mail>
    <header>Is it possible to mock final class with easymock class extension??</header>
    <body>Hi all, I have a (probably I would call a basic and stupid question) question to ask. Is it possible to mock final class with easymock classextension v2.2.2?? Thanks Shubhashish Bhowmik</body>
  </mail>
  <mail>
    <header>Re: Changing the value returned by a stubbed method?</header>
    <body>So these would be equivalent then: right? I'm away from my work machine right now, so forgive me asking this one: what happens when you mix the two: // setup our default // excepting for the next time its called Does the andReturn() take precedence over the andStubReturn() ? -Josh</body>
  </mail>
  <mail>
    <header>How to modify the argument in a mocked method</header>
    <body>Hi, hmm, it's even hard to write the question, so I hope I can make clear what I want to do. Assuming I have a call like this: And the real method updateObject modifies the object itself, i.e. does smthg. like: How would I set up this behavior in my test method? Or where can I find information about how to do it? I couldn't find some information, but this is probably because I don't even know how to write the query ;-) Does this make sense? Thanks and cheers Heinrich</body>
  </mail>
  <mail>
    <header>Re: How to modify the argument in a mocked method</header>
    <body>Hi Tim, thank for your reply. Works perfect, and as expected. So just for completion: This is described in the documentation in the sections: - Creating Return Values or Exceptions - Changing Behavior for the Same Method Call And I'd recommend just to add the example given below... Cheers Heinrich</body>
  </mail>
  <mail>
    <header>Agruments Matcher</header>
    <body>Hi Does anyone know how to create my own argumentsmatcher? Thanks Shubhashish</body>
  </mail>
  <mail>
    <header>Re: Agruments Matcher</header>
    <body>You can check out the source code for my EasyMock PropertyUtils project (  ). The matcher implementation:  om/stephenduncanjr/easymock/matcher/BeanProperty.java The class with the static utility methods:  om/stephenduncanjr/easymock/EasyMockPropertyUtils.java -Stephen</body>
  </mail>
  <mail>
    <header>Re: Agruments Matcher</header>
    <body>Thanks to all of you for the links!!! :)   om/stephenduncanjr/easymock/matcher/BeanProperty.java  om/stephenduncanjr/easymock/EasyMockPropertyUtils.java</body>
  </mail>
  <mail>
    <header>Calling the constructor of the mocked object</header>
    <body>Hello! I'm using EasyMock CE 2.2.2. My problem is that the class that I partly mock sets up a few things in the constructor and createMock does not call the public no arg constructor of the mocked class. So after the createMock call I have a mock that is not correctly setup and subsequent calls to methods on the mock object will most likely fail. Is there some way I can use to explicitly call the constructor of the mocked object? BR Niklas</body>
  </mail>
  <mail>
    <header>Re: Agruments Matcher</header>
    <body>Hi, Once again i need a little bit of help I have created my own custom matcher, say Mapmatcher. Now inside my map there are many elements with key value pairs, and certain elements are array (byte and object). Is it possible to check the equality of the array by using the existing array matcher. if yes then how i could i embed in my own custom matcher(Mapmatcher)   om/stephenduncanjr/easymock/matcher/BeanProperty.java  om/stephenduncanjr/easymock/EasyMockPropertyUtils.java</body>
  </mail>
  <mail>
    <header>Re: Calling the constructor of the mocked object</header>
    <body>Hi Niklas, Not in version 2.2.2. I think this functionality will be included in 2.3, which should be out soon. Cofion/Regards, Neil.</body>
  </mail>
  <mail>
    <header>Re: Calling the constructor of the mocked object</header>
    <body>Any ideas about when this is supposed to happen? tia, ./alex -- .w( the_mindstorm )p. TestNG co-founder EclipseTestNG Creator</body>
  </mail>
  <mail>
    <header>Re: Calling the constructor of the mocked object</header>
    <body>I always know this feeling ;-). Take your time! ./alex -- .w( the_mindstorm )p. TestNG co-founder EclipseTestNG Creator</body>
  </mail>
  <mail>
    <header>EasyMock in multithread</header>
    <body>Actual Behavoiur: 1. Train mock object in thread1 As result there is an UnexpectedMethodCall exception in thread2. 3. Thread1 check mock object Everything is ok, test pass Expected Behavoiur: There are should be an UnexpectedMethodCall exception in step 3 within thread1.</body>
  </mail>
  <mail>
    <header>easymock version question</header>
    <body>EasyMock 2.x documentation states: EasyMock 1.2_Java1.5 documetation states: EasyMock 1.2_Java1.3 documentatino states: Is the second statement in error? Should is say "Java 2, 1.5.x"? And if so, what is the difference then between EasyMock 2.x and EasyMock 1.2_Java1.5 (as "1.5" just refers to the JDK version that is included with "Java Version 5.0")? thanks</body>
  </mail>
  <mail>
    <header>Re: easymock version question</header>
    <body>Hi, This is wrong. It should say "Java 2 Version 5.0 and above", like EasyMock 2. The difference is in how you express the expectations for your mocks. In EasyMock 1.2, you say something like: public void testMethod() throws Exception In EasyMock 2, the equivalent is: public void testMethod() throws Exception I haven't compiled or tested this code, so beware! HTH Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Re: Agruments Matcher</header>
    <body>Hi Thanks for the code snippet Here is my mapmatcher(Sample) public class HashmapMatcher implements IArgumentMatcher public HashmapMatcher(HashMap map) public void appendTo(StringBuffer buffer) // Hope there will be not any fault public boolean matches(Object arg0) Now how could i implement the array matcher, in this (sample) mapmatcher?   om/stephenduncanjr/easymock/matcher/BeanProperty.java  om/stephenduncanjr/easymock/EasyMockPropertyUtils.java</body>
  </mail>
  <mail>
    <header>Re: easymock version question</header>
    <body>Thanks. So EasyMock 1.2_Java1.5 and Easymock 2.x both require Java 5/1.5, but it looks like Easymock 2.x uses generics while EasyMock 1.2_Java1.5 does not (?) thanks, sam --- In easymock@yahoogroups.com, "Neil Greenwood" EasyMock 2. And if included mocks.</body>
  </mail>
  <mail>
    <header>Re: mock exception thrown in andThrow()</header>
    <body>I don't understand what "mocking from both directions" means. Could you give a little example? Interaction-based testing is a skill, just like TDD is. I've seen really bad implementations of both. (Actually, I've seen really bad implementations of almost everything, some of them mine). I don't think it's about intellectual horsepower but about development style. Interaction-testing works best with an OO style that's perhaps best described by Wirfs-Brock's Responsibility-Based approach. S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>Re: mock exception thrown in andThrow()</header>
    <body>Ok. So our terminology is different. [...] The only response I can make to this is that it works for me and some other people. The oldest example I can think of was the Connextra codebase, where they had an average of 8 developers over 4-5 years doing ongoing development. That was where most of the original Mock work was done (before the cute frameworks) and I don't believe they hit the wall. I and other people I work with have done projects of a reasonable size without seeing the problems you describe. There are even some enthusiasts I've corresponded with but never met. So either we're all geniuses (and should put our rates up) or there's a cultural mismatch over development styles. This is my current best theory since people seem to have such strong reactions to the technique. S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>IExpectationSetters.andStubReturn</header>
    <body>I think this method should accept a T as parameter, not an Object. Is this an oversight, or am I missing something? Cheers, Ilja</body>
  </mail>
  <mail>
    <header>"No last call on a mock available" error</header>
    <body>Hi, I'm using easymocks for some code testing and I've encountered this problem: java.lang.IllegalStateException: no last call on a mock available I'm using the Easymock class extension for this test and the code is this: The error every time for the first expect line. Already tried to alter their order but the error continues for which ever is the first expect. Any ideas??? Thanks in advance! Pedro Silva</body>
  </mail>
  <mail>
    <header>Re: "No last call on a mock available" error</header>
    <body>Ok, I can use the interface for the first mock but the second one, StepNode is a class that extends an abstract class. Is this a problem? Can i mix mocks created from classes and from interfaces? Pedro</body>
  </mail>
  <mail>
    <header>Re: "No last call on a mock available" error</header>
    <body>Hi Pedro, Yes that's OK. You can import the classextension version of EasyMock and it will handle both interfaces and classes (IIRC it delegates to the standard version for interfaces). Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Re: "No last call on a mock available" error</header>
    <body>I reaaly don't know what to do with this problem.... I've created a test with the sema class structure that I use in the official project, and evry things goes well... If I try to run the test with my real classes I always get the error : java.lang.IllegalStateException. no last call on a mock available If I switch the order of the expects I get: java.lang.IllegalStateException. incompatible return value type Wich doesn´t happen if I use the test classes I created... So what could possible be causing this errors ... What are the cases for this messages to appear? Thanks once more, Pedro Silva</body>
  </mail>
  <mail>
    <header>mocking final methods limitation - on v2.3 ?</header>
    <body>Hi, Does the limitation with mocking final methods still exist in EasyMock 2.3? The line "Final methods cannot be mocked. If called, their normal code will be executed." is included in EasyMock documentation/readme from1.x to 2.1, but then disappeared from 2.2 and 2.3 readme pages. I had a similar problem like this one  error was actually caused by the final method but the message I got ("method call on the mock needed before setting return value") confused me at first. After testing the scenario on various versions of EasyMock, then I found the documentation re the limitation with mocking final methods. Another thing I found while googling for EasyMock docs is this site  - displays EasyMock home page on the bottom frame, chewing bandwidth directly from easymock.org - displays Google Ads on the top frame, does the ad income go to EasyMock project? - to those who are not familiar with EasyMock site, gives the impression as if the page comes from roseindia.net Doesn't seem like an ethical practice to me, unless EasyMock project acknowledge the usage. Cheers, Cliff</body>
  </mail>
  <mail>
    <header>Re: mocking final methods limitation - on v2.3 ?</header>
    <body>Hi Henry, I was thinking about the following mocking way few days ago ... Why not to pass to method create*Mock the instance of object instead of class and mock just specified methods? The object will be initialized, working, but some methods will be mocked. This scenario is usefull for business object mocking, I need working object, with set properties but some method I want to mock. Or I'm testing the business object and want to mock some method to better test the others. Jirka PS. How it is with my patch about easier specifing methods to mock? Henri Tremblay napsal(a):  ith.html with.html -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: mocking final methods limitation - on v2.3 ?</header>
    <body>Brice, Henri, thanks for the help. I must've read the non-classextension readme and missed out the note on final methods there. D'oh. we are allowing limitation to create a There's a needs, invocation of  ith.html though I've target sites, EasyMock normal code methods.</body>
  </mail>
  <mail>
    <header>Re: mocking final methods limitation - on v2.3 ?</header>
    <body>Can I suggest you try to avoid this? The result is often brittle tests that inhibit refactoring and that are hard to read. The need to mock part of an object can be a symptom that it's carrying too many responsibilities. S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>classextension createMock(String, Class) throws IllegalArgumentException</header>
    <body>Hi everyone, I've been using the EasyMock framework for about 3 months now and have come across the following bug: All the create***Mock(String, Class) methods of the org.easymock.classextension.EasyMock class will throw IllegalArgumentException and complain that the Class argument is not an interface if you try to mock a class (which is what the classextension was intended for!). I checked the code and it seems that the create***Mock(String,Class) methods are not being overridden by the org.easymock.classextension.EasyMock and so the method invocation is being handled directly by its super class (org.easymock.EasyMock). Is this something that will be fixed in the next release? Or has no one else noticed this problem.</body>
  </mail>
  <mail>
    <header>Re: classextension createMock(String, Class) throws IllegalArgumentException</header>
    <body>I've been using it for months without problems. It sounds like you've actually import org.easymock.EasyMock.* instead of (or in addition to?) org.easymock.classextension.EasyMock.*. = Eric</body>
  </mail>
  <mail>
    <header>adapting the factory pattern</header>
    <body>We're developing a large application following the Domain Driven Design ethos, with service managers, services, entities and DAO/repositories. Our architect has now introduced the factory pattern so that different deployments of the app can be configured with different implementations of the entity classes. Not only does a typical factory instantiate a new instance of the requested class, but according to the new architecture, it also populates the entity bean from the calling parameters, validates it and passes it to the appropriate DAO/repository to be saved to the DB. This means I have code in my factory that I want to test, but the code is instantiating the entity classes. So it sounds like the old problem to which the answer is 'use a factory'. But it is the factory already! How do I get around this problem? Do I have to have a second level (mockable) factory to provide the factories with instantiated beans? Or should I advise our architect that we need to restrict the factory to instantiations only and then move all the attribute population (and any other test-worthy code) into the services? Or is there a third way? Thanks Adam</body>
  </mail>
  <mail>
    <header>Using EasyMock for an abstract class</header>
    <body>Hello, I would like to mock a class which is abstract and has inherits besides an interface to another abstract class. But I don't know how to handle this. There has been an article three years ago, but the method described there is now included in deprecated classes.  I'm now using easymock Release 2.3 and here is how I tried it: But unfortunately, this is not working: Exception in thread "main" java.lang.IllegalArgumentException: AbstractClassTest$BaseClass is not an interface org.easymock.internal.JavaProxyFactory.createProxy(JavaProxyFactory.java:12) org.easymock.internal.MocksControl.createMock(MocksControl.java:37) So I'm not sure if this is a god way to follow. Or what am I doing wrong here? What I'm basically want to do is to test my ibatis-DAO classes of my persistence layer without having a db running. The idea is to mock the class SqlMapClientTemplate and configure the method i.e. queryForList and give some expected results to the dao class. This is how I'd like to do my unit/classs test. Running the integration test in the next step would require a running db instance, even if there would not be any data neccessary, only a valid table system. Here I would test the sql-mapping of ibatisand so on. Is there any best practice? Is this a wrong approach for class testing the persistence layer? How would you do it? Thanks for your help. Cheers Heinrich</body>
  </mail>
  <mail>
    <header>Re: hashCode() - not implemented</header>
    <body>Hello Szczepan, it is not that they *should* not be used there, but they *are* not used there yet! There are three options in this case: 1) Not to overwrite hashCode() 2) to overwrite hashCode() with a real implementation 3) to throw an exception in hashCode(). 1) is to dangerous: You will get no warning if you use the objects in a HashSet/HashMap, but the code will not work correctly. I don't like 2), since I would write code that is not used. So I opted for 3) - as soon as the objects are used in a context where hashCode() is used, the exception will act as a reminder that hashCode() now needs a 'real' implementation. HTH, Tammo</body>
  </mail>
  <mail>
    <header>Re: Using EasyMock for an abstract class</header>
    <body>Hi Henri, thanks for your answer. That's exactly what I wanted to do. Now we can test dao-classes without a db and do the integration test separately with the already tested dao-package. cheers Heinrich</body>
  </mail>
  <mail>
    <header>Re: Mocking Static method calls</header>
    <body>We can re-factor some of the code - some we have no control over.  For instance, we cannot change the LocalCache implementation, but we can alter our code.  That said, changing to does not seem to help.  Still getting the same stack trace. Given your earlier comments, I don't believe material, however something I forgot earlier - the Failure Trade is different to the stack trace, being java.lang.IllegalStateException: incompatible return value type au.com.blah.blah.blah.DomainUtilTest.testGetValues(DomainUtilTest.java:7\ 0) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.jav\ a:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessor\ Impl.java:25) org.junit.internal.runners.OldTestClassRunner.run(OldTestClassRunner.jav\ a:35) org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4Tes\ tReference.java:38) org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.ja\ va:38) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTe\ stRunner.java:460) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTe\ stRunner.java:673) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRun\ ner.java:386) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRu\ nner.java:196) BTW, I don't understand the comments around using dependancy injection - can you point me to a reference where I can get more information please? Thanks....Andrew</body>
  </mail>
  <mail>
    <header>Re: Mocking Static method calls</header>
    <body>You can try using JMockit ( small tool that will instrument the bytecode and allow you to "redefine" specified method calls.   You do have to pass their jar in to the JVM as a javaagent. tc For stack (MocksControl.java:101) (DomainUtilTest.java:7\ (NativeMethodAccessorImpl.jav\ (DelegatingMethodAccessor\ (OldTestClassRunner.jav\ (JUnit4Tes\ (TestExecution.ja\ (RemoteTe\ (RemoteTe\ (RemoteTestRun\ (RemoteTestRu\ injection - please?</body>
  </mail>
  <mail>
    <header>Re: Re: Mocking Static method calls</header>
    <body>I think that JMockit works only on J6. ./alex -- .w( the_mindstorm )p.</body>
  </mail>
  <mail>
    <header>Re: Re: Mocking Static method calls</header>
    <body>The dependency injection refers to not calling "new LocalCache()" in the method you're testing. Try adding a LocalCache parameter to the constructor, or add a setLocalCache method to the class and call it before calling the method that uses the cache. To cover the background of dependency injection in two sentences: The class you're testing *depends* on LocalCache. Instead of hard-coding a dependency, you *inject* the instance into the class you're testing using the constructor or a setter method. If you want more details, try wikipedia  Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Easymock and signed jars&#xD;
    &lt;/a&gt;&#xD;
    &lt;span class="name"&gt;&#xD;
      &lt;a href="http://profiles.yahoo.com/r%2Emalagigi"&gt;&#xD;
        r.malagigi&#xD;
      &lt;/a&gt;&#xD;
    &lt;/span&gt;&#xD;
    &lt;br/&gt;&#xD;
    &lt;a href="/group/easymock/post?postID=GXAmqWCzKybDVToxhDk9nPDFIPFaDK8ii4Lqp75YkDdbXfYBzslah7uzkxdyWz4J9v8hOAFomLddfDwXstMgWgjynMO0jORNpxPK6_RcfGVzbA" class="smalltype ygrp-nowrap" title="Send Email"&gt;&#xD;
      &lt;img src="http://l.yimg.com/kq/static/images/yg/img/ui/sendemail.gif" width="12" height="12" alt="Send Email"/&gt;&#xD;
       Send Email&#xD;
    &lt;/a&gt;&#xD;
    



 

&#xD;
    &lt;div class="form-rowb12"&gt;&#xD;
      &lt;div class="msgarea" style="padding-bottom:10px;"&gt;&#xD;
        &lt;table border="0" cellpadding="2" cellspacing="0"&gt;&#xD;
          &lt;tbody align="left"&gt;&#xD;
            &lt;tr&gt;&#xD;
              &lt;td&gt;&#xD;
                &lt;div style="font-family:times new roman, new york, times, serif;font-size:12pt;"&gt;&#xD;
                  &lt;div&gt;&#xD;
                    Hi,&#xD;
                    &lt;br/&gt;&#xD;
                    I am using easymock classextension to  mock  Eclipse 3.3 
classes but  they belong to signed jars and I received a message like
(see attached file):&#xD;
                    &lt;br/&gt;&#xD;
                    .......&#xD;
                    &lt;br/&gt;&#xD;
                    Caused by:
java.lang.SecurityException: class
"org.eclipse.jface.viewers.LabelProviderChangedEvent$$EnhancerByCGLIB$$bd487669"'s
signer information does not match signer information of other classes
in the same package&#xD;
                    &lt;br/&gt;&#xD;
                        at java.lang.ClassLoader.checkCerts(Unknown Source)&#xD;
                    &lt;br/&gt;&#xD;
                        at java.lang.ClassLoader.preDefineClass(Unknown Source)&#xD;
                    &lt;br/&gt;&#xD;
                        at java.lang.ClassLoader.defineClass(Unknown Source)&#xD;
                    &lt;br/&gt;&#xD;
                        ... 30 more&#xD;
                    &lt;br/&gt;&#xD;
                    ....&#xD;
                    &lt;br/&gt;&#xD;
                    &lt;br/&gt;&#xD;
                    where org.eclipse.jface.viewers.LabelProviderChangedEvent is the concrete class to mock&#xD;
                    &lt;br/&gt;&#xD;
                    &lt;br/&gt;&#xD;
                    I saw that jmock team
already solve the problem (at least in &#xD;
                    &lt;a rel="nofollow" target="_blank" href="http://www.jmock.org/dist/jmock-cglib-1.1.0.jar"&gt;&#xD;
                      jmock-cglib-1.1.0.jar&#xD;
                    &lt;/a&gt;&#xD;
                     : I am not know sure about last release) and at the moment I am using jmock in those unit test rather than easymock.&#xD;
                    &lt;br/&gt;&#xD;
                    &lt;br/&gt;&#xD;
                    any suggestions!!!&#xD;
                    &lt;br/&gt;&#xD;
                    &lt;br/&gt;&#xD;
                    roberto malagigi&#xD;
                  &lt;/div&gt;&#xD;
                &lt;/div&gt;&#xD;
                &lt;br/&gt;&#xD;
                &lt;hr size="1"/&gt;&#xD;
                 Yahoo! Answers - Get better answers from someone who knows. &#xD;
                &lt;a href="http://uk.answers.yahoo.com/;_ylc=X3oDMTEydmViNG02BF9TAzIxMTQ3MTcxOTAEc2VjA21haWwEc2xrA3RhZ2xpbmU"&gt;&#xD;
                  Try
it now</header>
    <body>net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&amp;gt;null at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:237) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:377) at net.sf.cglib.proxy.Enhancer.createClass(Enhancer.java:317) at org.easymock.classextension.internal.ClassProxyFactory.createProxy(ClassProxyFac\ tory.java:98) at org.easymock.internal.MocksControl.createMock(MocksControl.java:36) at org.jeasytest.aspectscreator.decorators.JETLightweightLabelDecoratorTest.testAsp\ ectRegisterChangedNoifiesAllListenersUsingAnAsyncJob(JETLightweightLabelDecorato\ rTest.java:178) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at junit.framework.TestCase.runTest(TestCase.java:168) at org.jmock.core.VerifyingTestCase.runBare(VerifyingTestCase.java:39) at junit.framework.TestResult$1.protect(TestResult.java:110) at junit.framework.TestResult.runProtected(TestResult.java:128) at junit.framework.TestResult.run(TestResult.java:113) at junit.framework.TestCase.run(TestCase.java:124) at junit.framework.TestSuite.runTest(TestSuite.java:232) at junit.framework.TestSuite.run(TestSuite.java:227) at org.junit.internal.runners.OldTestClassRunner.run(OldTestClassRunner.java:76) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReferen\ ce.java:38) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:196) Caused by: java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:384) at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:219) ... 24 more Caused by: java.lang.SecurityException: class "org.eclipse.jface.viewers.LabelProviderChangedEvent$$EnhancerByCGLIB$$bd487669"\ 's signer information does not match signer information of other classes in the same package at java.lang.ClassLoader.checkCerts(Unknown Source) at java.lang.ClassLoader.preDefineClass(Unknown Source) at java.lang.ClassLoader.defineClass(Unknown Source) ... 30 more</body>
  </mail>
  <mail>
    <header>Open Source Apps developed using EasyMock and TDD</header>
    <body>Does anyone know of any open source applications that were developed using TDD and EasyMock?  I'm specifically looking for a project that is closer to what would be developed in the enterprise (such as CRM, or a billing application, etc). I've been trying to do TDD for about a year and a half now, but I continually find myself frustrated by the process (when a single test requires 6 or 7 mock objects, it just gets to be unwieldy). My problem could be my testing approach, or it could by my design. Ether way, I'm hoping that by looking at some other code others have developed, I might be able to determine what I'm doing wrong; or at the very least generate some new ideas. Jim++</body>
  </mail>
  <mail>
    <header>Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>Ah, but that isn't always easily done.  I've accepted the fact that third-party code is hard to mock (and of course it cannot be refactored).  But what about classic object-oriented designs of in-house code? Here's a specific problem that I currently face: I'm implementing a web service that has an operation that does some pretty complex stuff (an operation is equivalent to a single method). To manage the complexity, I've extracted the complexity into several highly-cohesive classes and interfaces.  However, to test the operation itself now requires a sizable number of mock objects. Here are some of the classes/interfaces that I have: - A parser interface to parse optional "control" files - Three implementations of the parser interface for different formats of the control files. - A factory class(and interface) to return the correct implementation of the parser depending which control file type is given. - An interface of a file generator to generate an "index" file - Two implementations of the file generator for two different output formats of the "index" file - A persistence class (and interface) (DAO) to persist requests for later retrieval (the web service is asynchronous) - A controller class that orchestrates the interaction of the above classes, thus implementing the desired functionality. As you can no doubt guess, it's the controller class that's giving me a headache when it comes to testing (I need at least six mock objects to test the controller class).  Since it contains some significant logic (the helper classes need to be used together appropriately), I definitely want to test it. By basic OO rules, the above design is "decent" (loosely coupled, high cohesion), and the helper classes are easy to test.  I'm not sure how to simplify the controller beyond where it is now. The web service definition is set in stone (by the customer) and cannot be modified (thus I cannot split out some of the functionality of this heavy operation into separate operations).  This is the kind of real-world problem I run into over and over. Any suggestions about what to do in this case? tricks to probably test, to ask always</body>
  </mail>
  <mail>
    <header>Unitils and EasyMock</header>
    <body>Hello EasyMockers! The Unitils ( incredible unit testing utilities.  In particular, they've added some interesting "simplifications" to the EasyMock library: - Create easy mocks using annotations - Annotations to assist with mock injection via reflection (allowing you to inject into hard places, such as private singleton static fields). - Dynamic switching between "nice" mocks and normal/strict mocks. - Simplified "lenient" argument matching by treating null and primitive defaults as "anyObject()" and "anyInt()", "anyFloat()", etc. Any chance that we'll see some of these features in a future release of EasyMock? The unitils project includes a number of other utilities to ease testing, including enhancements to dbUnit (Database unit testing), utilities for testing Spring and Hibernate applications, and reflection-based assertion methods. They also have a published list of unit testing guidelines where are a good read for anyone doing unit testing. P.S. I'm not affiliated with Unitils in any way.  I stumbled upon the project while engaging in random googling.  Anyway, I thought I'd pass it along in case anyone finds their utilities helpful (I know I will).</body>
  </mail>
  <mail>
    <header>Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>If we take a somewhat dogmatic, preachy approach to this then the above sentence highlights what I suspect is the cause of your problems. ;) You said you have designed your solution and NOW you want to test it. Strictly speaking you should start by trying to test it and use this to guide your design. This is why some people call it Test Driven Design rather than Test Driven Development. Admittedly there is a knack to this ☺ So, as you start trying to test the controller you find it convoluted to write tests for  specifically you need to use too many mocks. This might indicate that the controller class is doing too much, and so has too many collaborators... Yep the fact that the helper classes are easy to test probably indicates the design is largely pretty good - the controller seems to be the sticking point. Its hard to know without knowing more about what this service does, but I would look at breaking the controller up into a number of sub-controllers that control one specific area ( say a ParseController, a FileGenerationController and a PersistenceController) and then have a 'master' controller that orchestrates these sub-controllers. Hope this helps Cheers Perryn PS Also, In your email you mention that there are a number of implementations of two interfaces. You seem to imply that the controller needs to know about all the implementations. I would expect that the controller should only know about the interfaces? But perhaps I have simply misinterpreted your email here.</body>
  </mail>
  <mail>
    <header>Re: Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>Well, then let's not be dogmatic :-). TDD is not the ultimate approach, nor is it required to get good software. If it is too difficult to mock up everything, then you might want to take another approach: 1/ test it as it is (and/or mock only what are the most expensive parts of it) 2/ extensively test the helpers (including also the way their API is supposed to be used) At least this way you will get sure that what you have in place is working. Indeed, you may loose the part about assuring that the helpers API is correctly used. ./alex -- .w( the_mindstorm )p.</body>
  </mail>
  <mail>
    <header>Re: Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>I don't count as many collaborators in your code. I don't know if this is the case, and it seems like you're quite experienced with EasyMock so probably not, but make sure you are just testing controller logic with the controller test, and not some collaborator. If I'm reading it right, it seems like your controller only needs: - parser interface mock - factory class mock - file generator to generate index file mock - dao mock That doesn't strike me as too crazy. One idea: It may be possible to use a dependency injection pattern instead of a factory pattern, and that will remove one of your collaborators. Other ideas: 1. We have a base test case that creates mocks of most of our service interfaces. This saves quite a few lines in the controller test cases, but the setup can still be substantial. 2. I always start with and focus on  unit tests that don't need mocks, as those will be the easiest to write, and will give you the best return on your investment. It seems like you have several classes that may qualify here. 3. I advocate pushing logic down as far as it will go in the layered architecture. Can some logic done in the web  controller actually be put into a service/manager object? If so, that will probably make it easier to test. I can't really see it for your case. Just to echo what others are saying, I really started getting TDD when I saw how it affected my approach to coding. I consider testability as a primary requirement and it almost always affects the design. Hope this helps, Andy</body>
  </mail>
  <mail>
    <header>Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>Thanks to all for the outstanding replies. Well, that's not entirely correct. I looked at the requirements, and rather than trying to work from the top down (as it was pretty complex), I started from the bottom and looked for some functionality to implement to get me started (this happened to be the parsers).  I then implemented the other "helpers".  All this was done test-first. So in a way, the test-first approach did influence the design. I thought about doing that, but then I'd end up with a number of controller classes that have a single method of only a few lines of code each, all the while introducing yet-another-layer into the design. One could argue that, just as the size of a class can hinder maintainability, the number of classes in a project can hinder maintainability.  I was hoping to avoid a "sub-controller" layer so that future maintainers would have one less layer to comprehend/make changes to. This seems to be a case where testability is slightly at odds with maintainability (I have to add complexity to increase testability).  I guess this is why coding is  "craft" and not yet a "science". Yes, I can see how that comes out in my previous post.  No, the controller class interacts with the classes via the interfaces only, and for the most part, doesn't need any logic to decide which one to instantiate.  As you point out, THAT would have been a real problem. problems. ;) me a how to interfaces?</body>
  </mail>
  <mail>
    <header>Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>parts of it) That's not a half-bad idea...although I'll of course feel vulnerable in the places where the code isn't tested.  The question I have to answer is: am I comfortable with having some vulnerable code? --- In easymock@yahoogroups.com, "Alexandru Popescu â" operation problems. ;) parts of it)</body>
  </mail>
  <mail>
    <header>Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>--- In easymock@yahoogroups.com, "Andrew Peterson, Consultant" Oops..sorry about that.  There are actually a few more collaborators than what I listed in my post (two application configuration classes, and a callback interface for pushing the results of the work performed to the clients), but I left them out to simplify the discussion somewhat. If testability is a primary requirement, then maybe I should create sub-controllers.  Here's a place where I'm modifying the design solely for testability... --- In easymock@yahoogroups.com, "Andrew Peterson, Consultant"</body>
  </mail>
  <mail>
    <header>Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>If the web service is just a thin wrapper around functionality that is part of an application that is exposed in other ways, say via a web interface (as most web services are), then I whole-heartedly agree. There really isn't much to test (or that is worth testing). This particular application , however, is entirely and solely exposed as web services, and therefore contains all the complexity of other enterprise applications (as you correctly guessed). We don't test the actual web service plumbing.  In fact, we've made a point of drawing a thick line between the web service plumbing and the actual core logic of the application. The application interacts with several distributed systems,  all of which have their own state and were developed by third parties.  This makes the use of integration testing for regression testing difficult because the integration tests are heavily dependent on the state of the distributed systems (and it isn't easy to reset the state of those systems). Thus, we are relying on our unit tests to catch regressions, which would not be possible without EasyMock (thank you!), as we need to mock the distributed systems. But for other types of applications, I can definitely see the value of depending on the integration tests for catching regressions as well. because the be your I test case is a test the Something integration formats implementation</body>
  </mail>
  <mail>
    <header>Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>OK, i was being a bit tongue-in-cheek with the whole 'dogmatic' TDD thing anyway :) Yeah, If you let TDD completely drive your design you are likely to end up with a great many very small classes... Be careful in dismissing this as bad design though. One can also argue simple arrangement of complex parts" I'm not sure you have increased complexity. You have just moved it from how a particular class works into how a number of classes work together. Personally I have found that having lots of simple de-coupled classes can actually *increase* maintainability because when I need to make a change I can easily put them all together in a slightly different way to achieve my aim, rather like playing with Lego. I take your point that perhaps it is harder to envision how a number of classes work together than how a single class works. Perhaps rather than introduce a new sub-controller layer as such, you still have a single controller layer conceptually that just happens to be implemented with a number of classes. Or, you could just decide that it isn't worth unit testing the Controller class, and rely on your integration tests to get coverage over it :) cheers Perryn</body>
  </mail>
  <mail>
    <header>Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>You might want to take a look at some of the "test smell" patterns we've written up on the mockobjects site.  I'm afraid it's in jMock syntax, but the principles still apply. S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>Re: Re: Open Source Apps developed using EasyMock and TDD</header>
    <body>Sounds like a good start. My practice really is to start top-down. The trick is to find the minimal slice through that will get me started, which I usually test at the integration level. Over time, I've found that my designs for starting with lower-level concepts have usually been in the wrong place, so I stopped doing it. Depends on your point of view. As other poster have pointed out, the complexity is there regardless, it's a question of where you like to keep it. I'm not expecting any changes here soon :) S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>Re: Can you Mock a ServletOutputStream? [NC]</header>
    <body>You need to use EasyMock Class extension to mock classes. EasyMock Class extension can also mock interfaces. - Henri |------------------------------ |            rhodepc@... |            Sent by: |            easymock@yahoogro |            ups.com | | |            16/07/07 04:57 | | |            Please respond to |            easymock@yahoogro |                 ups.com | | I see folks creating a mock for a ServletOutputStream in my google searches, but whenever I do it, I get "javax.servlet.ServletOutputStream is not an interface" error. A ServletOutputStream is an abstract class, is there some other trick it it? Thanks. I am trying to get some unit tests for an open source java openid serve together for release. Thanks. java.lang.IllegalArgumentException: javax.servlet.ServletOutputStream is not an interface at java.lang.reflect.Proxy.getProxyClass(Proxy.java:362) at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:581) at org.easymock.internal.JavaProxyFactory.createProxy(JavaProxyFactory.java:12) at org.easymock.internal.MocksControl.createMock(MocksControl.java:37) at org.easymock.EasyMock.createMock(EasyMock.java:43) ************************************************************************* This message and any attachments (the "message") are confidential and intended solely for the addressee(s). Any unauthorised use or dissemination is prohibited. E-mails are susceptible to alteration. Neither SOCIETE GENERALE nor any of its subsidiaries or affiliates shall be liable for the message if altered, changed or falsified. Ce message et toutes les pieces jointes (ci-apres le "message") sont confidentiels et etablis a l'intention exclusive de ses destinataires. Toute utilisation ou diffusion non autorisee est interdite. Tout message electronique est susceptible d'alteration. La SOCIETE GENERALE et ses filiales declinent toute responsabilite au titre de ce message s'il a ete altere, deforme ou falsifie. *************************************************************************</body>
  </mail>
  <mail>
    <header>Re: Can you Mock a ServletOutputStream?</header>
    <body>There is an EasyMock classextensions package that can be used for mocking classes instead of interfaces. bests, ./alex -- .w( the_mindstorm )p.</body>
  </mail>
  <mail>
    <header>Re: Can you Mock a ServletOutputStream? [NC]</header>
    <body>to always use org.easymock.classextension.EasyMock instead of org.easymock.EasyMock?  I've been very careful not to mix the two, but if the entire bundle works (inc. replay and verify) then I'm confused why it's not simply part of the EasyMock package itself. Hi Will, It's safe to use the class extension all the time. It's not part of the base package since it's an extension, albeit an official one. You'd have to ask Henri and Tammo about why it wasn't included in the base package, but there are good arguments for always using interfaces (which is enforced by the base package) at system boundaries (i.e. the bits you want/need to mock). HTH Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>EasyMock and Hamcrest</header>
    <body>Hi, now that Hamcrest has made it into JUnit, is there an easy and concise way to use Hamcrest with EasyMock? Probably EasyMock should provide a method like JMock's with(), in order to adapt a Hamcrest matcher to the EasyMock matcher interface. Cheers Peter</body>
  </mail>
  <mail>
    <header>Partial mocks and Clover coverage</header>
    <body>Hello. I use Clover to show my unit test coverage. It works well with easymock with the exception of partially mocked classes. Say I have the class 'x' that has the methods 'a' and 'b'. 'a' calls 'b' and to test 'a' I make a partially mocked instance of 'x' and mocks up the behaviour of 'b' and run 'a'. I would expect Clover to pick up that I have indeed tested 'a' but not 'b' but alas, neither of the methods show up as tested. Are there any plans to resolve this? (and yes, I try to use partial mocks as little as I can but sometime they drastically cut down the complexities and lengths of tests.) Thanks for the help. Gustav</body>
  </mail>
  <mail>
    <header>Re: Partial mocks and Clover coverage</header>
    <body>I guess you're using the classextension to do the partial mocking. There's no easy way that Clover could pick up the fact that method 'a' has been called, since the classextension actually creates a separate subclass of 'x' and tests that (it's how the substitution of 'b' works). Maybe Clover could be changed to realise that the subclass is really 'x', but this certainly won't be easy, because I think Clover creates a further subclass to add it's monitoring instructions that check when statements/methods are called. The best way is to change the code-under-test so that you don't need partial mocking. I didn't say this was the easiest way though :-) Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>hi</header>
    <body>Hi, I am trying to mock some classes inside my program. While I was trying to call some methods on the mock objects, I am getting the following exceptions. I tried with the two options. In the following example, I am tring to call a get method on Map interface. I tried to expect a call in two ways. I have shown in the following example. First one:: Second one:: I tried in both ways. But I dont have any luck, getting the same problem. Plz have a look at the source:: /** * */ /** * @author sreeram kumar * */ /** * Common to all tests is the execution of the test. The execution also consists of verifying * that the mock objects were called as expected. * */ @Override stringUtils = createStrictMock(StringUtils.class,new Method[] /** * Test the Bind */ Plz have a look at the assertionError:: The assertionError as follows:: java.lang.AssertionError: at org.easymock.internal.MocksControl.verify(MocksControl.java:71) at org.easymock.classextension.EasyMock.verify(EasyMock.java:65) at hilton.cctui.spring.processor.bre.request.BookingRequestBinderTest.testBind(Book\ ingRequestBinderTest.java:77) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestR\ eference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:196)</body>
  </mail>
  <mail>
    <header>Private methods</header>
    <body>Hi , Can we mock private methods inside a public method of a class? I mean, Class A contains one public, two private method calls inside this public method. I can mock the class A with the one public method. If I try to mock the class with the private methods, its not allowing me to do. I know, as per Java access specifiers, we cant access any private methods outside of the class. Just I wanna confirm, do we have any way to test the private methods inside public method of a class.</body>
  </mail>
  <mail>
    <header>How do most people deal with java.io.File dependencies?</header>
    <body>Hi all, I'm in a situation where I have to work with some code that goes through some amount of subdirectories, instantantiates new files and opens and reads from them. How do I mock this out?  I can fake out a single File with createMock(File.class), but anything beyond that (especially the new File(parentDir, "foo") idiom) leaves me with no place to inject mocks. I don't really have the option of refactoring the code or even saying this is badly designed.  It is what it is, and I've got to figure out a way of working with it.  Anyone have any ideas? Will.</body>
  </mail>
  <mail>
    <header>Re: How do most people deal with java.io.File dependencies?</header>
    <body>I've faced the same problem before and have come to the following conclusion: If you can't/don't want to change the code: - Skip unit tests and only do integration testing on a real file system. You should test the real thing anyway. If you are willing to change the code, and think that integration testing alone is not good enough: - If your code only needs a few simple file operations, write your own file API facade and mock that out - Use Commons VFS and write/read from memory - Now that I think of it, using a RAM disk might be another option Cheers Peter</body>
  </mail>
  <mail>
    <header>EasyMock ClassExtension 2.2.2 fails quietly on Enums</header>
    <body>If I try something silly like this: enum MyEnum Then EasyMock should throw an identifiable exception.  As it is, it confuses JUnit into telling me that there are no runnable methods. Will.</body>
  </mail>
  <mail>
    <header>Re: EasyMock ClassExtension 2.2.2 fails quietly on Enums</header>
    <body>Why do you want to mock an Enum? Is that enum defining any methods for you app? ./alex -- .w( the_mindstorm )p.</body>
  </mail>
  <mail>
    <header>call to void method with unknown params?</header>
    <body>I need to make a call to a method in my mock that returns void but takes a parameter which i can't know in advance. For example // whatever I just can't seem to find a way to call this in a mocked object if i don't know what bar will be in advance. What i need is a way to say it's ok for this method to be called with any argument. Hopefully there's a way, as with other methods, to specify the number of times, or an unlimited number of times. -- - kate = masukomi</body>
  </mail>
  <mail>
    <header>Re: call to void method with unknown params?</header>
    <body>Am 06.08.2007 um 15:43 schrieb kate rhodes: Hello, to clarify: Matchers have to be used either for no argument, or for all arguments. - expect(foo.doSomething(foo)) will work, since no argument matcher was given. - expect(foo.doSomething(same(foo))) will work, since argument matchers were given for all arguments (1 argument). - expect(foo.doSomething(same(foo), anyObject())) will work, since argument matchers were given for all arguments (2 arguments). - expect(foo.doSomething(foo, anyObject())) will not work, since argument matchers were not given for all arguments. You will get an exception. Hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>Re: call to void method with unknown params?</header>
    <body>Do you know that there's a jMock2 that doesn't use strings for method names any more? S. Steve Freeman  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>Re: mock exception thrown in andThrow()</header>
    <body>Agreed. I don't usually mock simple value objects, which should often be immutable anyway. S. Steve Freeman Winner of the Agile Alliance Gordon Pask award 2006  M3P Limited. Registered office. 2 Church Street, Burnham, Bucks, SL1 7HZ. Company registered in England &amp;amp; Wales. Number 03689627</body>
  </mail>
  <mail>
    <header>void and throw exception</header>
    <body>how can setup a expect about a my void method throw a exception ? expect(T) can NOT apply to void -- Using Opera's revolutionary e-mail client:</body>
  </mail>
  <mail>
    <header>RE: void and throw exception</header>
    <body>Use: -- Jim McMaster mailto:jim.mcmaster@...</body>
  </mail>
  <mail>
    <header>isA() matcher doesn't accept null</header>
    <body>Hi, why is it that the isA() matcher doesn't accept null? Example: list.add(null); // java.lang.AssertionError: Unexpected method call add(null) By the way, is there a way around the unchecked conversion warning in line 1 other than @SuppressWarnings("unchecked")? Cheers Peter</body>
  </mail>
  <mail>
    <header>Re: isA() matcher doesn't accept null</header>
    <body>Because null isn't an instanceof String. I suppose you could write a matcher if you wanted the behavior isNullOrA(String.class). Nope. A limitation of the clazz-generics pattern is that Class references are only types to an erased class. For instance, the following test passes: Make sense? Phill</body>
  </mail>
  <mail>
    <header>Re: IArgumentAsserter extension... Is there something wrong with this pattern?</header>
    <body>I think I understand the the matcher construct better now and why I can't expect a not-null value or a specific instanceof in the pattern I was using. I still would like to be able to assert in my matchers however, as opposed to just returning 'false'. I get detailed information in my assertions about what was wrong with the argument. I've modified my class to look like this: ... The catch clause is needed instead of an instanceof because of the erasure restrictions on dealing with T. This class allows me to assert in my tests like this: ...and the matcher plays well now with other matchers. I'm finding it useful when I don't have a reference to what ought to be passed, but I want to verify properties of the argument are what they ought to be. Is this pattern going to get me in trouble in some way I'm not seeing? Phill</body>
  </mail>
  <mail>
    <header>Re: isA() matcher doesn't accept null</header>
    <body>The important question is what isA(String.class) is supposed to mean. I interpreted it as "the argument is-a String" or "the argument is assignable to a String variable", so I was surprised to get an error when I passed null. On a practical side, when mocking a method that takes a String, I used to write isA(String.class) instead of (String)anyObject(), which turns out to be incorrect. I have an impression that other people are making the same mistake. Cheers Peter</body>
  </mail>
  <mail>
    <header>Re: isA() matcher doesn't accept null</header>
    <body>That makes sense. I appreciate having isA() not accept null arguments, since I tend to avoid allowing them, but I can see how both matchers would be helpful if you're forced to test at a level where you might expect a number of calls where some are strings and some are null. I'd be tempted to try to test the cases independently, though. Ensuring only Strings are sent, then ensuring the argument is null when it ought to be. That said, the following matcher ought to do what you're asking for: And the method for adding it: Hope that helps. Phill</body>
  </mail>
  <mail>
    <header>isA throw NPE</header>
    <body>@Test(expectedExceptions = IOException.class) also in a other test : please help , very thanks -- Using Opera's revolutionary e-mail client:</body>
  </mail>
  <mail>
    <header>Re: isA throw NPE</header>
    <body>i still get same NPE : On Sat, 14 Jul 2007 03:34:51 +0430, Graham Lea -- Using Opera's revolutionary e-mail client:</body>
  </mail>
  <mail>
    <header>Re: isA throw NPE</header>
    <body>It would probably help if you showed us the stacktrace(s). Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: Re: isA() matcher doesn't accept null</header>
    <body>It wouldn't: null instanceof SomeClass is always false. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: Re: isA() matcher doesn't accept null</header>
    <body>That might be so. I think Henri was meaning something more like: Then string instanceof String is always true, IIRC. Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Re: Re: isA() matcher doesn't accept null</header>
    <body>I think you are misremembering. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: Re: isA() matcher doesn't accept null</header>
    <body>cases. I had a memory failure and did the test a litle bit too quickly when I wrote the mail. And it'll teach me to write statements without checking them with the compiler first! It's far too long since I did my programmer certification, obviously... Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Re: Re: IArgumentAsserter extension... Is there something wrong with this pattern?</header>
    <body>Hello Phill, You should definitely define appendTo to append a meaningful matcher string representation. It is explained in the documentation (well, it is mentioned ;)). As examples, please see the matchers in EasyMock's source code. Well, your test will not read that well. Please keep in mind that in matching, you may use or() and and() to combine matchers. In the test above, I would define a hasStripes() helper method so that the test reads like: - Tammo</body>
  </mail>
  <mail>
    <header>can't setup mock HttpServletRequest</header>
    <body>I am using easymock 2.2 and trying to use it to mock a HttpServletRequest. Here is a simple 3 line program that I put together, my mock object always outputs the value of "null" for the getServletPath() method.  I don't understand why the mock wouldn't return the value that I setup for it. Thanks very much, i will be cool when I get it working. HttpServletRequest httpRequest =</body>
  </mail>
  <mail>
    <header>Re: can't setup mock HttpServletRequest</header>
    <body>Thank you so much.  It works great now.  Can't wait to traverse my codebase with junit and easymock. Phillip</body>
  </mail>
  <mail>
    <header>Can you Mock a ServletOutputStream?</header>
    <body>I see folks creating a mock for a ServletOutputStream in my google searches, but whenever I do it, I get "javax.servlet.ServletOutputStream is not an interface" error. A ServletOutputStream is an abstract class, is there some other trick it it? Thanks.  I am trying to get some unit tests for an open source java openid serve together for release. Thanks. java.lang.IllegalArgumentException: javax.servlet.ServletOutputStream is not an interface at java.lang.reflect.Proxy.getProxyClass(Proxy.java:362) at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:581) at org.easymock.internal.JavaProxyFactory.createProxy(JavaProxyFactory.java:12) at org.easymock.internal.MocksControl.createMock(MocksControl.java:37) at org.easymock.EasyMock.createMock(EasyMock.java:43)</body>
  </mail>
  <mail>
    <header>Re: mock class implementing interface with generic</header>
    <body>It's the classextension that's imported. The problem is in the type passed to C, &amp;lt;U&amp;gt; . Try it out to see the problem. Sorry for the double post, the first time the connection broke. Bart mock for regular like</body>
  </mail>
  <mail>
    <header>Problems using andReturn with a bounded wildcard type.</header>
    <body>Hi, Please excuse me if this is a generics problem, but I can't seem to figure out how to get easy mock to expect a bounded wildcard type. My method under test looks something like: The portion of code that creates the new list is actually buried in a library, so I can't change the list creation erasure to &amp;lt;Foo&amp;gt; and I don't think there is a way to cast to it. When mocking, I have a test case like: which yields the error: andReturn(java.util.List&amp;lt;capture#412 of ? extends test.Foo&amp;gt;) in org.easymock.IExpectationSetters&amp;lt;java.util.List&amp;lt;capture#412 of ? extends test.Foo&amp;gt;&amp;gt; cannot be applied to (java.util.ArrayList&amp;lt;test.FooImpl&amp;gt;) If I try declaring the list as a bounded type, like: I get the even more confusing error: andReturn(java.util.List&amp;lt;capture#887 of ? extends test.Foo&amp;gt;) in org.easymock.IExpectationSetters&amp;lt;java.util.List&amp;lt;capture#887 of ? extends test.Foo&amp;gt;&amp;gt; cannot be applied to (java.util.List&amp;lt;capture#371 of ? extends test.Foo&amp;gt;) Any idea what is going on here?</body>
  </mail>
  <mail>
    <header>void method and andThrow in 2.2</header>
    <body>Hi, I have been using easymock for a few years now, but I have just recently started using 2.2 and some of new approaches contained therein. I have run into a problem trying to specify that a mock should throw an exception from a method that returns void. previously I would have just specified this using the mock control, but now the approach appears to be something like expect(&amp;lt;my method call&amp;gt;).andThrow(&amp;lt;my execption&amp;gt;) however, this does not compile if &amp;lt;my method&amp;gt; returns void - presumably to support the andReturn() method. Is there any way to do this in 2.2? cheers Perryn</body>
  </mail>
  <mail>
    <header>Re: void method and andThrow in 2.2</header>
    <body>Hi Perryn, That's the approach for methods that don't have a void return type. Yep, fear not! expectLastCall().andThrow(&amp;lt;my exception&amp;gt;) You can also use .times, etc. Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>EasyMock.isA() in EasyMock.expect()</header>
    <body>I am trying something as following. call#1 EasyMock.expect(someMock.do(mockA, mockB, call#2 EasyMock.expect(someMock.do(EasyMock.isA(String.class), EasyMock.isA(String.class), call#1 fails with the following exception. java.lang.IllegalStateException: 3 matchers expected, 1 recorded. call#2 works fine. Is it possible to combine EasyMock.isA() and other mocks/regular objects in the same EasyMock.expect() call as in call#1? I am using EasyMock class extension to create mocks. Thanks Kamlesh</body>
  </mail>
  <mail>
    <header>Re: EasyMock.isA() in EasyMock.expect()</header>
    <body>Hello Kamlesh, Yes, it is. If you would like to use matchers in a call, you have to specify matchers for all arguments of the method call (However, you may mix them freely). The exception tells you that three matchers were expected (as the method calls has three arguments), however, only one has been recorded. The default behavior of EasyMock is matching with equals(). For call #1, you may use: ... expect(someMock.do(eq(mockA), eq(mockB), isA(String.class)).andReturn Hope that helps, Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: EasyMock.isA() in EasyMock.expect()</header>
    <body>Thanks Tammo. It works if I put matchers for all arguments. But I still do not get why I can't do the following? Or "If you would like to use matchers in a call, you have to specify matchers for all arguments of the method call." is the requirement? Thanks</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock.isA() in EasyMock.expect()</header>
    <body>Am 17.06.2007 um 17:13 schrieb xkamlesh2: Yes, it's a requirement. Although EasyMock makes it look like matchers are passed as arguments to the method, they aren't. They are recorded, and mapped to method calls behind the scenes. If you call EasyMock gets: behind the scenes. Now consider: and For both, EasyMock would get the same calls: It is not clear whether the matcher belongs to the first or second argument. As a result, EasyMock requires you to either specify matchers for all arguments, or none at all. - Tammo</body>
  </mail>
  <mail>
    <header>mock exception thrown in andThrow()</header>
    <body>Should it be possible to use a mocked exception in the andThrow() method? Something like: I get : NullPointerException If it should I will complete the example above to a working test. Bart</body>
  </mail>
  <mail>
    <header>RE: Problems using andReturn with a bounded wildcard type.</header>
    <body>Thank you both for your comments. I certainly did not know you could recast generic types that way. I knew that using &amp;lt;? extends Foo&amp;gt; as a return type was probably not the best way to do things when I designed the system, but I am impressed with how hard the compiler chokes on it. It really is not that strange of a situation. - Solomon ________________________________ From: easymock@yahoogroups.com [mailto:easymock@yahoogroups.com] On Behalf Of Henri Tremblay Sent: Friday, June 15, 2007 17:00 To: easymock@yahoogroups.com Subject: Re: [easymock] Problems using andReturn with a bounded wildcard type. Your welcome... I feel totally the same... I would like someone to explain why erasure and captured worth the complexity. I just got a nicer answer for you. Adapted from an answer I had to a post on a forum about that. You can do: EasyMock.&amp;lt;List&amp;lt;? extends Foo&amp;gt;&amp;gt;expect(fooDoer.foo()).andReturn(new (... two minutes to digest this lovely syntax...) Ok, so it's mostly undocumented (I've seen it only in section 4.11 of the java spec, it's not even mentionned in Sun generics tutorials). From what I understand, it allows you to "fix" the type of the method call preventing a capture of an incompatible type. So kind of static cast, the generic way. Note that it prevents you from using a static import, you need to have "EasyMock." for the line to compile. Just as if the method was in the current class, you would need to prefix with "this.". Good to now but it doesn't make me feel better about generics... Cheers, Henri On 6/15/07, Nick Bauman &amp;lt; nick.bauman@... Thanks, Henri, for going out of your way to clarify this for me. Sometimes it seems that Java's generics violates my fundamental mental concept of how typing should work, other times it seems completely compatible, and I can't really figure out what causes which. I think it's because of capturing and erasure. Cheers, Nick On 6/14/07, Henri Tremblay &amp;lt; henri.tremblay@... Hi, No, the issue your talking about wasn't about compiling. It was about the fact that easymock might register a call to a bridge method and then the real method being call which will give an error and shouldn't. It's fixed for the class extension but not for standard easymock... Dumbly, due to a limitation in java, it doesn't seem possible to fix it. It never occured yet though. That said, Solomon issue is about wildcard capture (some explanation here really relevant to our case). Basically, the compiler is preventing something like this: l.add(new C()); // not allowed l.add(new B()); // not allowed neither To do that, it captures a type called capture#2-of that is '?' and so no other type is allowed. Basically, you won't be able to add anything to your list EVER because the compiler can't make this type safe! The only solution is you really want to do this is to provoke a warning. ((List) l).add(new C()); // unchecked warning That push us back in the good old days pre-generics where the compiler was thrusting us and works fine. (at least, that is my explanation for it) The solution is the same in our case. Just (just might not be the word... a friend of mine "guessed" it after searching for a while) do: EasyMock.expect(fooDoer.foo()).andReturn((List) new ArrayList&amp;lt;FooImpl&amp;gt;()); // warning, but compiling That said, I think the real solution would be to fix the typing in easymock somewhere. So I'm searching for the best solution to do so. Cheers, Henri On 6/13/07, Nick Bauman &amp;lt; nick.bauman@... I'm not sure but someone posted a problem a week or so ago that turned out to be a bug in EasyMock wrt generics. It has to do with code generated for typesafe checking by the compiler that was being mocked instead of the raw invocation. This sounds a little different but may be related. There is a fix in CVS for it. Hi, Please excuse me if this is a generics problem, but I can't seem to figure out how to get easy mock to expect a bounded wildcard type. My method under test looks something like: The portion of code that creates the new list is actually buried in a library, so I can't change the list creation erasure to &amp;lt;Foo&amp;gt; and I don't think there is a way to cast to it. When mocking, I have a test case like: DoFoo fooDoer = which yields the error: andReturn(java.util.List&amp;lt;capture#412 of ? extends test.Foo&amp;gt;) in org.easymock.IExpectationSetters&amp;lt;java.util.List&amp;lt;capture#412 of ? extends test.Foo&amp;gt;&amp;gt; cannot be applied to (java.util.ArrayList&amp;lt;test.FooImpl&amp;gt;) If I try declaring the list as a bounded type, like: DoFoo fooDoer = List&amp;lt;? extends Foo&amp;gt; fooList = new I get the even more confusing error: andReturn(java.util.List&amp;lt;capture#887 of ? extends test.Foo&amp;gt;) in org.easymock.IExpectationSetters&amp;lt;java.util.List&amp;lt;capture#887 of ? extends test.Foo&amp;gt;&amp;gt; cannot be applied to (java.util.List&amp;lt;capture#371 of ? extends test.Foo&amp;gt;) Any idea what is going on here?</body>
  </mail>
  <mail>
    <header>Names for Mocks</header>
    <body>Hi, I was hoping to do a bit of development for you by enabling mocks to have names that would be printed out in their toString(). I have been in desperate need of this feature for the last few weeks. I did a bit of work on it during lunch time yesterday before I noticed that you're doing your main development on a branch and that this feature is already checked in but not released. You must have read my mind, or heard my screams. So now my only question is: When will a version with mock names be released? Cheers, Graham.</body>
  </mail>
  <mail>
    <header>MockControl - Start n Stop</header>
    <body>Hi, I would like to ask if there is any way of stopping the mock control from registering method calls for a defined amount of time. An example of this would be: I am testing a class that is a subclass of another. They both use a mock delegate class.  Both of these classes take the mock delegate class in their constructor. I do not want to test any calls to the mock delegate class that happens in the subclass as that is out of the scope of my unit test. How can I stop the mock control monitoring any calls to the mock delegate class in the subclass. I thought that I would be able to just reset the control but this does not seem to work. Thanks, D</body>
  </mail>
  <mail>
    <header>How to test methods that modify values in parameter objects</header>
    <body>Hello, Instead of specifying return values, is there a way to specify what values will be in objects passed as parameters in the case that a method under test modifies values in an object passed as a parameter? I need to mock a call to a method that makes a call to a stored procedure. We are redeveloping a legacy system and wrapping the calls to stored procedures. As a standard way to wrap the calls to stored procedures, we made a parameter class to hold all parameters to the stored procedure including all IN, OUT, and IN OUT parameters. So, I need to pass an object as a parameter with some fields set and then check for certain values in the object after the method executes that should be set by the method. DpEditModes_Parms dpEditModesParms = if (dpEditModesParms.getErrorText() != null)</body>
  </mail>
  <mail>
    <header>Re: How to test methods that modify values in parameter objects</header>
    <body>// Invoke Stored Procedure to get MobilityDefault data for the // given DSOE_ID  // If MobilityDefault data found, then verify that the schema instance // for the currently logged in user, i.e. that the user selected when // logging in to the application, matches the SchemaInstance for the // given DSOE_ID per the MobilityDefault info. if ((AppContextUtils.getSchemaInstance() == SchemaInstance.ACTIVE)</body>
  </mail>
  <mail>
    <header>Re: How to test methods that modify values in parameter objects</header>
    <body>Yes! That is what I need! The Matcher stuff didn't sink in when I first read the README file. I re-read it after your reply and now I get it. This will also help in other case I'm dealing with where an object from a third-party that I pass as a parameter to the method under test does not have an appropriate equals() method and I can't modify the source. BTW, I searched the forum messages a couple of days ago and found that what I am asking is sometimes referred to as "side-effect behavior." I matcher</body>
  </mail>
  <mail>
    <header>IArgumentAsserter extension... Is there something wrong with this pattern?</header>
    <body>First off, I'm new to EasyMock (been using it for a couple of weeks now), and I adore it. Great job to those involved! One of the things I wanted to be able to do is assert that parameters passed to a mock are valid, without more granularity than an isA() or notNull().. but without the ability to do an eq()... I found suggestions on this board that involved something like the following: I didn't like this pattern for a number of reasons. I didn't want static methods everywhere, didn't like doing the casting, don't need to return a boolean, and don't need to append myself to a string. So I created this implementation of IArgumentMatcher: Now, the code displayed before looks like this: ...Which I find much more palatable. It works great! Except in one instance that has me stumped! If I expect more than one call to saveNew() with different types.. I get class cast exceptions because it seems to only use my first matcher. Here's an example: .. In this case I get an class cast exception thrown from the _first_ ArgumentAsserter created, complaining that it can't cast BasketBall to BeachBall. My intent was to verify that saveNew() was called first with a BeachBall, and then with a BasketBall.. It seems my first matcher instance is being used to evaluate _both_ calls, though. What am I missing? I very much appreciate any help in advance. Thanks, Phill</body>
  </mail>
  <mail>
    <header>Re: Suggested change to ClassInstantiatorFactory to support PERC JVM</header>
    <body>Sigh... This mail was meant to be sent ONLY to Kevin who is using Easymock with Aonix PERC to test a fix. As you can see... I've sent it to everyone (thanks to gmail reply...) The reason it wasn't supposed to be broadcast more openly is that I am waiting the fix to be approved by Aonix and be legally compliant. So, using this packaging is at your own risk. Regards, Henri Aonix. It seems to work now so I've created an easymockclassextensions packaging for you that should work with PERC.</body>
  </mail>
  <mail>
    <header>Re: IArgumentAsserter extension... Is there something wrong with this pattern?</header>
    <body>Really? No one is able to give me a hand with this?</body>
  </mail>
  <mail>
    <header>Re: IArgumentAsserter extension... Is there something wrong with this pattern?</header>
    <body>Wow. Thanks for the advice. The pattern you're suggesting is pretty painless. I'm still a bit curious about why the implementation is such that the matchers wouldn't be called more dependably? I imagined that when I call that method twice (first with my BeachBall instance, second with my BasketBall one.. ) those instances end up on a stack somewhere, held by the mock. The first time the method is called.. it applies the matcher against the first instance in the stack. The second time the method is called.. it uses the second instance. Obviously my mental model isn't quite right. Can you clear up how this process works so that we'll be able to avoid issues like this in the future? Thanks again for the reply and advice. Phill</body>
  </mail>
  <mail>
    <header>EasyMockClassExtension problem</header>
    <body>The code below gives an exception /** * TODO by qkasale. */ public class TestEasyMockClassExtension extends TestCase java.lang.IllegalArgumentException: not a proxy instance at java.lang.reflect.Proxy.getInvocationHandler(Proxy.java:620) at org.easymock.EasyMock.getControl(EasyMock.java:1336) at org.easymock.EasyMock.replay(EasyMock.java:1280) at se.ericsson.jambala.jasServices.nup.session.old.TestEasyMockClassExtension.testM\ ockJunk(TestEasyMockClassExtension.java:26) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestR\ eference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:196) Alex Kashko BSc (Physics London) MSc(Maths Brunel) PhD(Theoretical Physics London) 7 yrs Java, J2ME, EJB, JSP, J2EE Servlets JDBC, C++, C , UNIX, JNI, JBOSS, WEBSPHERE, BANKING and lots more. Speaks German,French,Russian, basic Dutch. British Citizen and British passport. Phone: +44 7092 020 786 ( Voice and Fax only : UK and Europe try first) Yahoo! Answers - Got a question? Someone out there knows the answer. Try it now.</body>
  </mail>
  <mail>
    <header>Re: EasyMockClassExtension problem</header>
    <body>Well, yes.. you're calling replay with an Object[], which isn't a proxied mock instance... Did you mean to reply to this thread? I don't see the relevance.</body>
  </mail>
  <mail>
    <header>Problems with mocking a logging object</header>
    <body>In my case, I'm trying to mock a logging object.  It is actually a JBoss Seam Log object ( However, when the mock is referenced in my code, I get the following error: (MockInvoca tionHandler.java:29) (ObjectMethod sFilter.java:45) I'm especially puzzled by the following line: What does this mean?  Am I using anyObject wrong?  Thanks!</body>
  </mail>
  <mail>
    <header>Re: Problems with mocking a logging object</header>
    <body>Am 15.05.2007 um 06:00 schrieb lsli: This means that the mock object gets an additional call to error(&amp;lt;any&amp;gt;) which was not expected. Mock objects fail as early as possible, so the code under test cannot do all the other expected calls. expected: 1, actual: 1 (+1) means expected: 1, actual: 2 The reason for displaying 1 (+1) instead of 2 is that in some cases, it is not clear which of the expectations got an additional call. as an example, consider mock.debug("baz");      // matches debug(endsWith("z")) mock.debug("aadvark");  // debug(startsWith("a")) mock.debug("atoz");     // could match both, but both are consumed which leads to the error message java.lang.AssertionError: Unexpected method call debug("atoz"): debug(startsWith("a")): expected: 1, actual: 1 (+1) debug(endsWith("z")): expected: 1, actual: 1 (+1) Displaying 2 insteadof 1 (+1) would be misleading, as it would look like the mock object gets 4 calls, and not three. Hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>Re: Problems with mocking a logging object</header>
    <body>Thanks for the info Tammo!  Because of my beginner status with EasyMock, I think I misunderstood EasyMock and what the replay feature does.  :) I think I could put in an additional log.error call in before I call replay.  However, my intent was that I had the following code: in my setup method.  What I'm trying to do is that any call to the log object in the code I want to test will always invoke the mock object.  As I want to reuse this above setup code, there would be some code that might call it once, some other code may invoke the log methods three times, zero times, etc.  Is there any way to accomplish this in EasyMock?  I just tried looking through the Javadoc and wasn't sure how to do this. Thanks in advance! (&amp;lt;any&amp;gt;)</body>
  </mail>
  <mail>
    <header>Re: Problems with mocking a logging object</header>
    <body>Hi Isli, here is an example for well known java.util.List: ... ... With andStubReturn you can make your mock a stub always returning the same object. With expectLastCall().anyTimes() you have what you actually wanted! Cheers, Tim</body>
  </mail>
  <mail>
    <header>Re: Problems with mocking a logging object</header>
    <body>Isli, I made a mistake: instead of it must be Yours, Tim</body>
  </mail>
  <mail>
    <header>Newbie problem with expect(...).andReturn(null)</header>
    <body>Hi guys and galls, when asked to perform some fixes to an application I thought I would do it the right way, the test driven way. So I was mocking up some result sets for use in the tests, part of the test was with the conversion and storing of nulls from the database into primative longs. From examples I have seen online I can do something like this with my expect(mockRS.getLong("VALUE")).andReturn(null) but when I replay the mock and hit that method i get a null pointer exception, this is the stack trace: java.lang.NullPointerException at $Proxy0.getLong(Unknown Source) at my.test.nullTest.testTest(AdvertNullInstanciationTest.java:88) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:40) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:90) this is the actual code: I am using easy mock 2.2 and java 1.5.0_05_b5 Any help would be greatly appreaciated</body>
  </mail>
  <mail>
    <header>Re: Newbie problem with expect(...).andReturn(null)</header>
    <body>sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) I think the problem you are seeing is caused by the behind the scene outboxing instruction you have here: ResultSet has a method getLong that return a long and not a Long. So, to do this a Long to long outboxing instruction is needed, but your return is null so this fails. ./alex -- .w( the_mindstorm )p. EclipseTestNG Creator</body>
  </mail>
  <mail>
    <header>Re: Newbie problem with expect(...).andReturn(null)</header>
    <body>--- In easymock@yahoogroups.com, "Alexandru Popescu â" longs. sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:40) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) com.intellij.rt.execution.application.AppMain.main(AppMain.java:90) OMG, what a tool I am... such a school boy error, thanks for pointing that out to me!</body>
  </mail>
  <mail>
    <header>mock class implementing interface with generic</header>
    <body>I have a minor problem testing some code , simplified it looks like this: The B Class, it's super A and interface C: ----------------------------------------- The naughty class to test, D : ------------------------------ The test DTest: --------------- The output: ----------- This is only if the interface has a type. Remove the type and all goes well. Any ideas ? Bart</body>
  </mail>
  <mail>
    <header>Re: Error: missing behavior definition for the preceeding method call</header>
    <body>Hi Jirka, Thanks for the reply. It seems to be OK. But want to know should we use expect when method returns something and use the other way for void methods. Regards, Bala following one. methods. the case</body>
  </mail>
  <mail>
    <header>Re: Re: Error: missing behavior definition for the preceeding method call</header>
    <body>Hi Bala, try to read very nicely explained what is expect(..) and expectLastCall() about. If you mock method, that returns a value you have to tell what to return. If you mock void method, you haven't. Jirka -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Helper class for EasyMock</header>
    <body>Hi, I have been using EasyMock for a while now and after initially struggling to get my head around it, I now find it invaluable for unit testing. I have writen the same piece of helper code a few times now at different workplaces and was wondering if it could be added to EasyMock. It is a very simple implementation of the composite pattern for mocks. It allows you to keep track of all your mocks and call replay, verify and reset on them all at once. I have included the source and an example of it's usage. Cheers Jeremy</body>
  </mail>
  <mail>
    <header>Re: Re: Error: missing behavior definition for the preceeding method call</header>
    <body>Hi Bala, A point that isn't related to EasyMock - in your testing methods, it's best not to catch exceptions (and fail in the catch block) but rather to declare them in a throws clause. Then JUnit will automatically fail if the exception happens. I.e. I would write your test method like this: This will give you the same behaviour, except it's easier to get right (since there's less code). The only time you need a try..catch block in a testing method is if the method that you're testing *should* throw an exception in order for the test to pass (e.g. if you're testing validation behaviour). HTH. Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Mocking a toString method</header>
    <body>Hello all, Is it possible to mock a toString return value in EasyMock 2.2? It's one of the intercepted methods in ObjectMethodsFilter's invoke method, so I don't think it can be done, but I just wanted some confirmation. Many thanks, Neil.</body>
  </mail>
  <mail>
    <header>newbie starting easymock</header>
    <body>I downloaded easymock1.2_java1.5 and after unziping and adding the easymock.jar to my classpath and also i add the tests.zip file to the classpath.  However, when i try to run 'java org.easymock.tests.AllTests'. as it is indicated in the documentation i get an error message: Exception in thread "main" java.lang.NoClassDefFoundError: junit/swingui/TestRunner at org.easymock.tests.AllTests.main(AllTests.java:13). Any idea of why this would be happening.  I had installed junit4.1 in a different location and had also added a junit4.1 to the classpath. Don't know if this would cause problems or not. Thank you.</body>
  </mail>
  <mail>
    <header>Re: Mocking a toString method</header>
    <body>you cannot record a behavior for them. you get a default known behavior. Hi Henri, Thanks for the confirmation. Unfortunately, the app I'm testing relies on the toString behaviour of the real object, and I think it's going to be a real pain to instantiate the real object in the test... :-( Oh well, I'll have to see what I can do. Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Re: newbie starting easymock</header>
    <body>I downloaded easymock with JUnit 4.1 and am still getting an error. Exception in thread "main" java.lang.NoSuchMethodError: main Do i need to unzip the tests.zip file ? not works the the to the documentation</body>
  </mail>
  <mail>
    <header>Re: Mocking a toString method</header>
    <body>rely on toString()... overloading toString(). Or something way more tricky (I didn't try but it should work), to dynamically overload the easymock mock with cglib to overload toString() and call the easymock mock methods otherwise. Hi Henri, Thanks for the advice. It turned out that using the real object wasn't too expensive in the end (I'd been looking at the wrong class!). I agree with you that I ought to refactor the use of toString(). Unfortunately, business realities mean that I can't - at this point in time. I'll certainly try to in the future though. Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Re: Helper class for EasyMock</header>
    <body>Nice work Jeremy - that will save me a lot of code! Cheers, Andrew</body>
  </mail>
  <mail>
    <header>Easymock class extensions maintenance releases</header>
    <body>Hi, I've been away of easymock code for some time now... Partialy because of &amp;lt;a href=" delivery. And so got really late in my planning... (I was suppose to release in novembre)... So, there will be two maintenance releases this week. I'll put the following features in it: Easymock class extension 1.2.1: - objenesis integration to provide support for all JVMs - fix OutOfMemoryError on perm size issue Easymock class extension 2.2.2: - objenesis integration to provide support for all JVMs - fix OutOfMemoryError on perm size issue - Fix varargs replay, reset, verify issue Then, I'll have a look at all the contributions, request for new features, etc. of the last months, create issues in sourceforge base on that, release a new version ASAP. On top of my head, there is: - Helper to make partial mocking easier - cmpTo matcher (and check if they cover BigDecimal and Date case) - multithreading issue - Be able to call a constructor for partial mocking So you can help me by telling me two things: - Features you would like in the next main release - Features / Bug fix, I've forgot in the class extension maintenant release Thanks a lot, Henri</body>
  </mail>
  <mail>
    <header>Re: Easymock class extensions maintenance releases</header>
    <body>Hi Henry, please don;t forget to have a look at my code for easier method selection ... Jirka</body>
  </mail>
  <mail>
    <header>Suggested change to ClassInstantiatorFactory to support PERC JVM</header>
    <body>Hello, I am running into a problem running EasyMock class extension under the PERC JVM from Aonix: java.lang.NoClassDefFoundError: sun/reflect/ReflectionFactory COM.newmonics.PercClassLoader.RuntimePercLoader.loadPercClass(LCOM/newmonics/Per\ cClassLoader/PercClass;Ljava/lang/String;Z)LCOM/newmonics/PercClassLoader/PercCl\ [compiled] COM.newmonics.verifier.ConstantPoolData.resolve(LCOM/newmonics/PercClassLoader/P\ [compiled] COM.newmonics.verifier.ConstantPoolData.resolve(LCOM/newmonics/PercClassLoader/P\ [compiled] COM.newmonics.verifier.ConstantPoolData.resolve(LCOM/newmonics/PercClassLoader/P\ [compiled] COM.newmonics.verifier.NonVerifier.generatePIA(LCOM/newmonics/PercClassLoader/Pe\ rcClass;LCOM/newmonics/verifier/MethodData;I[LCOM/newmonics/verifier/ProcessedIn\ [compiled] COM.newmonics.verifier.NonVerifier.verifyMethod(LCOM/newmonics/PercClassLoader/P\ ercClass;LCOM/newmonics/verifier/MethodData;LCOM/newmonics/util/IntHashtable;)[L\ [compiled] COM.newmonics.PercClassLoader.DynamicPercLinker.prepareOneMethod (LCOM/newmonics/PercClassLoader/Method;Z)V [compiled] org.easymock.classextension.internal.SunClassInstantiator.newInstance(Ljava/lang\ [compiled] org.easymock.classextension.internal.ClassProxyFactory.createProxy [compiled] org.easymock.internal.MocksControl.createMock(Ljava/lang/Class;)Ljava/lang/Objec\ [compiled] (Ljava/lang/Class;)Ljava/lang/Object; [compiled] It seems to that ClassInstantiatorFactory.isSunJVM() is returning "true" for the Perc JVM.  I looked, and it is querying the "java.vm.specification.vendor" property which is returning "Sun Microsytems Inc.".  Since isSunJVM() is true, EasyMock instantiates the SunClassIntantiator which is trying to instantiate sun.reflect.ReflectionFactory which does not exist in PERC, hence the exception. I reported this as a bug to Aonix and they replied that no, indeed Sun Microsystems Inc. is the spec vendor b/c they WROTE the spec.  Aonix IMPLEMENTED the spec.  Instead they suggested that EasyMock should really be querying the "java.vm.vendor" property, which correctly returns "Aonix". So I'd like to suggest changing the getJVM() method in ClassInstantiationFactory from to</body>
  </mail>
  <mail>
    <header>Re: Suggested change to ClassInstantiatorFactory to support PERC JVM</header>
    <body>Hi Kevin, I believe this change has already been made in the unreleased version. There's due to be a new release in the very near future that will have this change in it (Henri made an announcement in the last couple of days, if you check the archive). If you need this before the release, you can get the latest version from CVS or SVN (I can't remember which one Easymock currently uses). HTH Hwyl, Neil.</body>
  </mail>
  <mail>
    <header>Re: Suggested change to ClassInstantiatorFactory to support PERC JVM [NC]</header>
    <body>Unfortunatly, there are two problems.... First,  my Internet connexion died two days ago Second, the code fixing this is not yet checked-in. Easymock will now use Objenesis underneath to perform the instantiation. Objenesis does check the correct property. However, Aonix is not currently supported. But since it's now requested, it could be really soon. Aside from that, initially the bug was found with JRockit. And BEA did two things: 1- Fix our code to work with JRockit 2- Make the next version of JRockit directly compliant with Sun That's quite nicer than the Aonix answer... Because, even if the bug wasn't there, you couldn't have a perfect mock, the constructor would be called. So, the best that can happen: 1- I get my internet connexion back 2- Aonix helps us that have their JVM supported by Objenesis 3- I release a new Objenesis and then Easymock version supporting Aonix - Henri P.S.: We are under CVS. |------------------------------ |            neil.greenwood.li |            sts@... |            Sent by: |            easymock@yahoogro |            ups.com | | |            28/02/07 22:36 | | |            Please respond to |            easymock@yahoogro |                 ups.com | | &amp;gt; Hello, I am running into a problem running EasyMock class extension &amp;gt; under the PERC JVM from Aonix: &amp;gt;[snip] &amp;gt; So I'd like to suggest changing the getJVM() method in &amp;gt; ClassInstantiationFactory from &amp;gt; to Hi Kevin, I believe this change has already been made in the unreleased version. There's due to be a new release in the very near future that will have this change in it (Henri made an announcement in the last couple of days, if you check the archive). If you need this before the release, you can get the latest version from CVS or SVN (I can't remember which one Easymock currently uses). HTH Hwyl, Neil. ************************************************************************* This message and any attachments (the "message") are confidential and intended solely for the addressee(s). Any unauthorised use or dissemination is prohibited. E-mails are susceptible to alteration. Neither SOCIETE GENERALE nor any of its subsidiaries or affiliates shall be liable for the message if altered, changed or falsified. Ce message et toutes les pieces jointes (ci-apres le "message") sont confidentiels et etablis a l'intention exclusive de ses destinataires. Toute utilisation ou diffusion non autorisee est interdite. Tout message electronique est susceptible d'alteration. La SOCIETE GENERALE et ses filiales declinent toute responsabilite au titre de ce message s'il a ete altere, deforme ou falsifie. *************************************************************************</body>
  </mail>
  <mail>
    <header>Re: Testing strategy/how to mock?</header>
    <body>The tricky part here is that you create a new instance of OtherClass within the Executor. Does it really need a new instance every time? If that delegated object was an instance, you could pass it into the Executor on construction and use a mock implementation for the test. S. Steve Freeman M3P Limited.  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>Re: Testing strategy/how to mock? [NC]</header>
    <body>Hum. Are we talking about easymock documentation? Because if yes.... then I don't think it can be more straightforward. JUnit in Action is getting old (even if I still recommend it as a really good thing to read) so it's using easymock 1.2. Look at:  |------------------------------ |            agovil@... |            Sent by: |            easymock@yahoogro |            ups.com | | |            02/03/07 07:34 | | |            Please respond to |            easymock@yahoogro |                 ups.com | | Hi, I am a newbie. Please try to answer even if this seems like a dumb question. I have a class that I need to test. This class contains a Command class object as a member variable. For each method, I set some parameters of the Command object and call a method of another class. For example: I want to test the Executor class. Clearly I would have to mock the execute method of the OtherClass or mock the private execute method. Can anyone tell me what steps I need to follow to to mock a method? I was referring to JUnit in Action for Easy Mock, however it works on an old version. The documentation is a bit hard to follow. How would you test this class? Any tips/pointers? Thanks in advance, Aneesha ************************************************************************* This message and any attachments (the "message") are confidential and intended solely for the addressee(s). Any unauthorised use or dissemination is prohibited. E-mails are susceptible to alteration. Neither SOCIETE GENERALE nor any of its subsidiaries or affiliates shall be liable for the message if altered, changed or falsified. Ce message et toutes les pieces jointes (ci-apres le "message") sont confidentiels et etablis a l'intention exclusive de ses destinataires. Toute utilisation ou diffusion non autorisee est interdite. Tout message electronique est susceptible d'alteration. La SOCIETE GENERALE et ses filiales declinent toute responsabilite au titre de ce message s'il a ete altere, deforme ou falsifie. *************************************************************************</body>
  </mail>
  <mail>
    <header>Bug in geq, gt, leq and lt for float and double?</header>
    <body>Hi, I think I have found a bug with the argument matchers gt, geq, lt, leq.  The JUnit tests below demonstrate the problem, but to summarize I had a peek at the code and noticed that these argument matchers use Number.longValue() to do their comparisons.  Therefore, gt(0.0) does not match 0.3 (for example). Likewise geq(1.5) wrongly matches 1.4 for example.  I suspect that Number.doubleValue() should be used instead. Here are the unit tests (N.B.  they all fail currently, but should not): public class EasyMockGreaterLessThanTest @Test public void testGT_Double() @Test public void testGEQ_Double() @Test public void testLT_Double() @Test public void testLEQ_Double() Thanks and ciao, Joe _________________________________________________________________ Win a trip for four to a concert anywhere in the world!</body>
  </mail>
  <mail>
    <header>Need help with error: no last call on a mock available</header>
    <body>Hi, Is there a place which documents all the possible error messages of EasyMock? They're usually hard to understand, and now I'm stuck on this one: no last call on a mock available. Here's the stack and pseudocode: java.lang.IllegalStateException: no last call on a mock available at org.easymock.EasyMock.getControlForLastCall (EasyMock.java:123) at org.easymock.EasyMock.expect(EasyMock.java:105) at MyTest.setUp(MyTest.java:52) The first test I wrote like this worked fine, then the second one gave me the above error. The only difference I can see between the two tests is that in the first case A is an interface, and in the second case A is a concrete class with no default constructor and all methods are declared final. But I have no idea if any of this is relevant since I don't understand the error message at all. Thanks for reading :)</body>
  </mail>
  <mail>
    <header>Re: Need help with error: no last call on a mock available [NC]</header>
    <body>Hi, The message means that during recording, a return value was set but nothing was expected (expect wasn't called). It is not your case. You encounter a class extension limitation. Final methods can't be mocked right now (do that will required some weavering at class loading). So the genuine doThis() method was called, not the mocked one. So nothing was recording. I agree, it's hard to guess given the current error message. Indeed, we could do a list a possible errors. Cheers, Henri |------------------------------ |            mengo76@... |            Sent by: |            easymock@yahoogro |            ups.com | | |            09/03/07 01:45 | | |            Please respond to |            easymock@yahoogro |                 ups.com | | Hi, Is there a place which documents all the possible error messages of EasyMock? They're usually hard to understand, and now I'm stuck on this one: no last call on a mock available. Here's the stack and pseudocode: java.lang.IllegalStateException: no last call on a mock available at org.easymock.EasyMock.getControlForLastCall (EasyMock.java:123) at org.easymock.EasyMock.expect(EasyMock.java:105) at MyTest.setUp(MyTest.java:52) The first test I wrote like this worked fine, then the second one gave me the above error. The only difference I can see between the two tests is that in the first case A is an interface, and in the second case A is a concrete class with no default constructor and all methods are declared final. But I have no idea if any of this is relevant since I don't understand the error message at all. Thanks for reading :) ************************************************************************* This message and any attachments (the "message") are confidential and intended solely for the addressee(s). Any unauthorised use or dissemination is prohibited. E-mails are susceptible to alteration. Neither SOCIETE GENERALE nor any of its subsidiaries or affiliates shall be liable for the message if altered, changed or falsified. Ce message et toutes les pieces jointes (ci-apres le "message") sont confidentiels et etablis a l'intention exclusive de ses destinataires. Toute utilisation ou diffusion non autorisee est interdite. Tout message electronique est susceptible d'alteration. La SOCIETE GENERALE et ses filiales declinent toute responsabilite au titre de ce message s'il a ete altere, deforme ou falsifie. *************************************************************************</body>
  </mail>
  <mail>
    <header>Re: New matchers</header>
    <body>Hi Henry, It is okay (maybe the name cmp is enough), but you missed also the interval matcher, that should look like: and You are not right, because using this sruff I can't perform the comparation to equality, that is my basic motivation (because of BigDecimals). If we can choose the name for the eq than we can have lt, leq, gt, geq and ??? that also uses Comparable and Object and Comparator. And maybe it is right direction, but what about the name for equality matcher?? Jirka -- Jiøí Mare¹ (mailto:Jiri.Mares@...) ÈSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: New matchers</header>
    <body>matcher, that should look like: True, a range / between matcher could be useful equality, that is my basic motivation have lt, leq, gt, geq and ??? that also uses what about the name for equality matcher?? It's doing almost everything except compareTo() == 0... Which is just a matter of adding a matcher for that... I think we should figure out a name :-)</body>
  </mail>
  <mail>
    <header>Re: New matchers</header>
    <body>Okay, I try to make a patch for the current easymock, where I try to suggest the name you can change it after applying ... Jirka P.S. How it is going with mine patch for method selection? -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Why doesn't easyMock reuse generated classes?</header>
    <body>We're using EasyMock to run tests in our continuous build. We've started to get "OutOfMemoryError: PermGen space" problems regularly. We've already increased the amount of available PermGen space, but this solution cannot scale indefinitely. Our workaround is to reuse mocks by creating them in static initializers rather than in the test's setUp() method. This approach is very fragile.   I describe this hack here:  Can you fix EasyMock so that it reuses the generated classes crated when createMock() is called?</body>
  </mail>
  <mail>
    <header>Re: Why doesn't easyMock reuse generated classes?</header>
    <body>Hi all, but I think that this is particularly not a case of EasyMock but jUnit. Ehy? Because jUnit for each test method creates new instance of the TestCase class and the class is also holder of the results. So all objects created in setUp are in memory during running all tests .... Therefore we have developed our own subclass of TestCase that has the following tearDown method: This method causes that all class attributes are set to null and it dramatically reduced the required memory for running tests ... Also the another way how to solve is to migrate to TestNG that doesn't have this problem ... Jirka -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: New matchers</header>
    <body>Hi Henri, please, can you tell me where is the right last version of easymock in repository? I reached repository, but HEAD looks like old version. To develop agains the Version/easymock EasyMock2_2 is not maybe the best solution because there can be changes from the april 2006 when the version 2.2 has been released. Maybe you can tell me the same for classextension and I can prepare also patch for the method selection ... Thanks Henri Tremblay napsal(a): -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: New matchers</header>
    <body>Hi Jiri, for EasyMock, the branch 'EasyMock2' is the right one. It contains some changes for the next version (EasyMock 2.3, not released yet). The changes are listed at the bottom of doc/Documentation.html. For EasyMock Class Extension, HEAD is the newest version. Tammo</body>
  </mail>
  <mail>
    <header>Re: New matchers</header>
    <body>Thanks I try to do my changes ... and post the patch .. Tammo Freese napsal(a): -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: New matchers</header>
    <body>Hi, so here are mine new matchers using Comparable and Comparator .. A little problem was with the names of the methods in EasyMock class. The test to equality using compareTo and compare methods I named cmpEq?? Next I try to improove the code for choosing the object method to be mocked (classextension) and also submit the patch. Please let me know whether the code is ok, or you want to make some changes or even to add tests (I saw there are no tests for matchers, therefore I have done none too). Jirka -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: EasyMock classextension improovement</header>
    <body>Hi, once again the method selections, but as a patch. I have done a small imrpoovement to be able also specify pattern, that causes the method will not be mocked. Sometimes it is easier to tell what method won't be mocked ... jirka P.S. I'm prepared to cooperate in the feature description in manual ... ").append(method.getReturnType().getSimpleName()).append(" ").append(method.getDeclaringClass().getSimpleName()).append(".").append( -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: Why doesn't easyMock reuse generated classes?</header>
    <body>Hi, you are not 100% right, because the PermGen space can be garbage collected as other heap spaces. And when there is instance of the class in heap, the class cannot be garbage collected. If the instance doesn't exists it can't. So setting all local variables to null maybe enables the possibility to collect the PermSpace. P.S. I didn't mention that the error is in PermSpace, thefore the mine mail was written as it was. Jirka  -- Jiøí Mare¹ (mailto:Jiri.Mares@...) ÈSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: Why doesn't easyMock reuse generated classes?</header>
    <body>I agree. But I can't see why the old tests would be still referenced and so their attributes not garbaged collected. But I'm not an expert of the JUnit core. It might also be a test runner implementation issue. About PermGen. I just dumbly assumed because we had these kind of issue with cglib class extension. other heap spaces. And when there is instance doesn't exists it can't. collect the PermSpace. was written as it was.</body>
  </mail>
  <mail>
    <header>Comparing bean property by property</header>
    <body>Hi all, do you know  tried to agree on with stephen on some improovements, but he is not responsive :-(( I think I can prepare something like that with much more functionality as direct patch for easymock. Are you interested? -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: Comparing bean property by property</header>
    <body>I understand and have the same feeling. Thefore I introduced some annotations and copying property values for comparison from objects. Therefore it is refactoring safe. Jirka Henri Tremblay napsal(a):  -- Jiøí Mare¹ (mailto:Jiri.Mares@...) ÈSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Date Matchers</header>
    <body>I provided (still in the files section) matchers fore before, after, and approximately equal date matchers back in August of last year. Did anything ever get done with them? (I couldn't find anything in CVS)  Would it be better to recontribute them as a patch? (against EasyMock2 branch?)  This might take some time (still haven't become familiar with CVS layout, tests, or code style for EasyMock), but if it would get them added, I'm willing to try to get around to it...</body>
  </mail>
  <mail>
    <header>Re: Date Matchers</header>
    <body>Well, they are here:  dnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip or easymockmatchers3.zip in the files section on the yahoo group if the link doesn't work.  It includes the property stuff, but you can just get rid of that part and keep the date stuff. -Stephen mailing will be added to the</body>
  </mail>
  <mail>
    <header>Re: Re: Date Matchers</header>
    <body>Hi, the matchers for before, after, not before, not after, equal, between are not necessary because the patch sent by me (using Comparable) covers this ... Jirka P.S. Henri, I think about providing test cases for new matchers, and because I didn't find any, I implemented none. And you speak about 100% coverage ... how are matchers tested?? Stephen Duncan Jr napsal(a):  dnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip CdnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: Re: Date Matchers</header>
    <body>Readability of what?? Stephen Duncan Jr napsal(a):  dnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip CdnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip  dnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip CdnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip -- Jiøí Mare¹ (mailto:Jiri.Mares@...) ÈSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: Re: Date Matchers</header>
    <body>My test case code. myMockObject.doSomething(before(today)) I assume that will look better than using something generic with comparable.  I didn't read your patch, but I assume it would be "lessThan" instead of before, for example?  Between, you're right, is probably made totally redundant though... -Stephen  dnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip CdnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip  dnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip CdnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip after, if -- Stephen Duncan Jr www.stephenduncanjr.com</body>
  </mail>
  <mail>
    <header>Re: Re: Date Matchers</header>
    <body>As usual I just made the name shorter, even I reused the names also suggested by easymock ... (lt, leq, gt, geq) Jirka Stephen Duncan Jr napsal(a):  dnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip CdnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip  dnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip CdnkDGkPafYtAt8WC9PYBHdFdNHlTsQCX2Fv8YhLMN/easymockmatchers3.zip after, if -- Jiøí Mare¹ (mailto:Jiri.Mares@...) ÈSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Error: missing behavior definition for the preceeding method call</header>
    <body>Hi, Always getting "missing behavior definition for the preceeding method call" error for the following test class and testcase methods. TestCase: TestClass: public boolean executeInternal(Context ctx) throws Exception Error: java.lang.IllegalStateException: missing behavior definition for the preceeding method call isInternal("Bala") at org.easymock.internal.MocksControl.replay (MocksControl.java:61) at org.easymock.EasyMock.replay(EasyMock.java:1280) Have just started integrating EasyMock, this is my first test case and not able to proceed further. Any help on this issue would be great.</body>
  </mail>
  <mail>
    <header>Re: Error: missing behavior definition for the preceeding method call</header>
    <body>Hi Bala, to me it looks that the commented line is the right one, not the following one. Jirka -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Réf. : need easymock 2.2 pdf file</header>
    <body>The documentation is here:  It contains beginner and advanced usage. The javadoc and some examples are also included in the delivery. Cheers, Henri Extranet callkasim@...@yahoogroups.com - 20/12/2006 06:26 Veuillez répondre à easymock@yahoogroups.com Envoyé par :      easymock@yahoogroups.com Pour : easymock cc : Objet :     [easymock] need easymock 2.2 pdf file Dear Friends, I am new to easymock. I have selected easymock after comparing all other tools and found it good for my application. I need a pdf or any other document files which starts for the beginners. I found there is a link for document in easymock.org site, but it looks like very advanced and not for beginners. waiting for your reply. Thanks and Regards, Kasim __________________________________________________ Do You Yahoo!? Tired of spam? Yahoo! Mail has the best spam protection around  This message and any attachments (the "message") is intended solely for the addressees and is confidential. If you receive this message in error, please delete it and immediately notify the sender. Any use not in accord with its purpose, any dissemination or disclosure, either whole or partial, is prohibited except formal approval. The internet can not guarantee the integrity of this message. BNP PARIBAS (and its subsidiaries) shall (will) not therefore be liable for the message if modified. Ce message et toutes les pieces jointes (ci-apres le "message") sont etablis a l'intention exclusive de ses destinataires et sont confidentiels. Si vous recevez ce message par erreur, merci de le detruire et d'en avertir immediatement l'expediteur. Toute utilisation de ce message non conforme a sa destination, toute diffusion ou toute publication, totale ou partielle, est interdite, sauf autorisation expresse. L'internet ne permettant pas d'assurer l'integrite de ce message, BNP PARIBAS (et ses filiales) decline(nt) toute responsabilite au titre de ce message, dans l'hypothese ou il aurait ete modifie.</body>
  </mail>
  <mail>
    <header>Re: Réf. : need easymock 2.2 pdf file</header>
    <body>Hi I have gone through the documents, i have few questions here: it calls some methods like createMock(...), replay(..), verify(..) in the class ExampleTest.java, where this method has been implemented? when i use this class and compiles it, it gives compile time error, can any one help me on this?  other other link for not for</body>
  </mail>
  <mail>
    <header>Re: Réf. : need easymock 2.2 pdf file</header>
    <body>Hello, The methods are defined on the class org.easymock.EasyMock. To access them, add a static import: Hope that helps, -Tammo</body>
  </mail>
  <mail>
    <header>Re: Strugling with partial mocking...</header>
    <body>Can I strongly recommend you avoid partial mocking except in the most extreme circumstances? The need to do so is probably telling you that you've got at least two objects in there that need teasing apart. S. Steve Freeman M3P Limited.  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>EasyMock classextension improovement</header>
    <body>Hi, I have started using easymock also with the class extension and feels that creating partial mock is very struggling to specify what method to mock and what not. I know this is not the right direction to go from the easymock community, but I think it is necessary. Therefore I have developed small utility class that can be used to better specify the methods (especially using the AspectJ way, see  Lets compare the two ways: and my way: bill = createMock(Billing.class, "public * *.add(..)", "* I'm able to create the patch for the org.easymock.classextension.EasyMock class to support this way of creating partial mocks. Are you interested in? Jirka</body>
  </mail>
  <mail>
    <header>Re: EasyMock classextension improovement</header>
    <body>Hi Henry, because I don't have access to the repository (I didn't try to find out how to connect) to create patch and because the code is very easy I'm sending you just the 4 static method that have to be added to the EasyMock class. The methods are: - getSimpleMethodSigniture - creates the string representing the method - createRegexPatterns - from the input strings creates the regexs patterns that are used to meatch the method signutures - findMethod - looks up the method in the class and all superclasses, I leaved it public to be able verify what methods are choosen if there is any problems ... - createMock - new implementation using findMethod to look up methos The only limitation I know is that it doesn't support national characters in the methos names and class names (uses the regex [a-zA-Z_0-9]* to replace * and [a-zA-Z_0-9 ,]* to replace .. but for me it is not a problem and I'm not the regex guru to know how to choose all characters that can be used in the class name and method name. I hope you will like it. Have a nice day Henri Tremblay napsal(a): -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: EasyMock classextension improovement</header>
    <body>Hi Henry, once again ... I forgot to implement createNiceMock and createStrictMock ... and there was a small error, that the compiler can't distinguish createMock(Class a) from createMock(Class a, String... regexs), so I have to implement it into the methods. Jirka Jiri Mares napsal(a): ").append(method.getReturnType().getSimpleName()).append(" ").append(method.getDeclaringClass().getSimpleName()).append(".").append( -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>EasyMock Extensions on Site</header>
    <body>It was brought to my attention that there might be several extensions to EasyMock out and about.  It might be nice to add them to the Links section of the website.  If you would like to do that, I'll point the person who asked about it here to provide ones in addition to my EasyMock-PropertyUtils:  -Stephen</body>
  </mail>
  <mail>
    <header>Re: EasyMock Extensions on Site</header>
    <body>Hi Stephen, I was looking at your library and think of small improovement, to be able to perform property comparation no tonly with a map, but also with an object of the same class. I'm going to implement this behaviour. Are you interested in incorporating this into your library? Jirka Stephen Duncan Jr napsal(a): -- JiÄ¹â¢ÄÂ­ MareÄ¹Ë (mailto:Jiri.Mares@...) ÃÅSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: EasyMock Extensions on Site</header>
    <body>Actually, that is implemented in trunk currently, based on a request from someone else.  So check it out and let me know what you think. I'll probably make a new release in a week or two. -Stephen</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock Extensions on Site</header>
    <body>Hi Stephen, I look to your source code via the online-reposite-browser and find out that the source code is containing only matching with Map where the property names and values are stored. I'm thinking about mathcing with other bean (probably the same class). Meaning matching two object property by property (not using equlas). Than the enhancement could be marking the get property method using annotation to ignor it during comparing. I have to implement it in very near future, today or tomorrow, therefore there is no problem to let it be done by me and then adding to your library. Eg. you code can be used: or and I suggest also: Next suggestion I have is to shorten the nema of the matcher, from propertyEq to propEq ... Stephen Duncan Jr napsal(a): -- JiÄ¹â¢ÄÂ­ MareÄ¹Ë (mailto:Jiri.Mares@...) ÃÅSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock Extensions on Site</header>
    <body>Hi Stephen, finally I found the code you wrote about.  Ok, it looks great, but I have few suggestions: Maybe it is suitable also support ignores specified via annotations, because from mine point of view, the ignores are still the same .. if you use intospection you have access to the getMethod ... where the annotation will be. Next, suitable will be using BeanUtils for retrieving the introspection details from the object, because it has the cache and performs the introspection only once for a class. Then uses the cached value. And you requires the bean-utils on class path. Shortening the property(ies)Eq to propEq I have already suggested. Jirka Stephen Duncan Jr napsal(a): -- JiÄ¹â¢ÄÂ­ MareÄ¹Ë (mailto:Jiri.Mares@...) ÃÅSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock Extensions on Site</header>
    <body>Hi Stephen, I have one more suggestion ... why not create also: public static &amp;lt;T&amp;gt; T propertiesEq(T valuesObject, final List&amp;lt;String&amp;gt; ignored) ... Jirka P.S. I can help you with the development and send you the patch, if you are interested in. Stephen Duncan Jr napsal(a): -- JiÄ¹â¢ÄÂ­ MareÄ¹Ë (mailto:Jiri.Mares@...) ÃÅSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: EasyMock Extensions on Site</header>
    <body>I don't want to take over discussion here, so could you bring discussion over to the Google Group I just created for the project:  I've already committed this change.  I have a discussion started for the name of the methods.  If you could add the other two requests as discussion items (I'm not clear on how you envision the annotations working, or what you're talking about changing regarding the use of BeanUtils... Back on topic, for the moment I've started this wiki page to track EasyMock extensions:  I've also added a topic you can post to in case you can't edit the wiki:  70ae627dcf1fa/ba0c97b9d840e368?hl=en#ba0c97b9d840e368 - Stephen ignored) to be also with extensions the Links point the</body>
  </mail>
  <mail>
    <header>New matchers</header>
    <body>i Henry, during my assimilation of easymock I have to implements 4 more matchers: - compares using compareTo (useful for BigDecimals, where 12.000 is no 12.0 (using equals) but are equals using compareTo) - the same thing but using Comparator - compares using compareTo whether the passed value is between start and end - the same using Comparator Do you want a patch? I need to know where to put the IArgumentMatcher implementations. Jirka -- JiÅÃ­ MareÅ¡ (mailto:Jiri.Mares@...) ÄSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: New matchers</header>
    <body>Hi Henry, It is okay (maybe the name cmp is enough), but you missed also the interval matcher, that should look like: and You are not right, because using this sruff I can't perform the comparation to equality, that is my basic motivation (because of BigDecimals). If we can choose the name for the eq than we can have lt, leq, gt, geq and ??? that also uses Comparable and Object and Comparator. And maybe it is right direction, but what about the name for equality matcher?? Jirka -- Jiøí Mare¹ (mailto:Jiri.Mares@...) ÈSAD SVT Praha, s.r.o. ( Czech Republic</body>
  </mail>
  <mail>
    <header>Re: Help for matcher</header>
    <body>I suppose there's a good reason for that requirement? (That if you use a matcher on one argument you have to use one on all the arguments.) -- Software-udvikler Colin Rosenthal PhD Digitale Ressourcer Statsbiblioteket                      tlf: 89462074 DK 8000 Århus C                     mobil: 26462564</body>
  </mail>
  <mail>
    <header>Re: Help for matcher</header>
    <body>Am 06.10.2006 um 08:49 schrieb Colin Rosenthal: Yes, there is. Although EasyMock makes it look like matchers are passed as arguments to the method, they aren't. They are recorded, and mapped to method calls behind the scenes. If you call EasyMock gets: behind the scenes. Now consider: and For both, EasyMock would get the same calls: It is not clear whether the matcher belongs to the first or second argument. As a result, EasyMock requires you to either specify matchers for all arguments, or none at all. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Help for matcher</header>
    <body>Yep, it works now. It makes sense to have this requirement and state it clearly in the readme file or some places. Thank you very much!</body>
  </mail>
  <mail>
    <header>Make classextentions.EasyMock.createMock(Class, Method[]) a vararg</header>
    <body>I think it would be nice if classextentions.EasyMock.createMock(Class, Method[]) were made a vararg. :)  What do you think? Mike</body>
  </mail>
  <mail>
    <header>It would be nice is classextensions replay, verify, and reset worked with vararg</header>
    <body>The vararg support in EasyMock.replay, verify, and reset are sweet. It would be nice if classextensions could get vararg support for those same methods.  What do you think? Mike</body>
  </mail>
  <mail>
    <header>Re: It would be nice is classextensions replay, verify, and reset worked with va</header>
    <body>Sorry, the subject got cut off.  It made my post sound harsher than I intended. :) It should be: "It would be nice is classextensions replay, verify, and reset worked with vargs"</body>
  </mail>
  <mail>
    <header>Re: It would be nice is classextensions replay, verify, and reset worked with va</header>
    <body>excellent.  Thanks. on a new after. It's "youngm77" those</body>
  </mail>
  <mail>
    <header>Thread safety problem in EasyMock 2.2</header>
    <body>I think I've uncovered a thread safety problem in EasyMock 2.2 It involves use of WeakHashMap inside org.easymock.internal.LastControl The problem is that the static method pushCurrentArguments doesn't synchronize threadToCurrentArguments when inserting a new Stack - which means that popCurrentArguments occasionally manages to pop a null Stack when running tests in a multi-threaded environment. At first glance, it looks like other methods in the same class may suffer from similar problems. I can provide more information if required.</body>
  </mail>
  <mail>
    <header>Re: Thread safety problem in EasyMock 2.2</header>
    <body>Better still - I can provide a patch. Turns out that the java class ThreadLocal&amp;lt;T&amp;gt; is optimised for exactly this circumstance: it doesn't need to synchronize, since ThreadLocals are held in the Thread object. Patch will be uploaded to the Files area</body>
  </mail>
  <mail>
    <header>Mocking Superclasses</header>
    <body>Hi! I am using a framework that supports me with superclasses. I'd love to mock these superclasses, so my subclasses use the mocked functionality of their parents. Is there a possibility to mock superclasses (i.e. change the class hierarchy at runtime)? Thanks</body>
  </mail>
  <mail>
    <header>Newbie--Trying to create tests for Spring implemented MVC appliction.</header>
    <body>Hi, I'm operating with around 2 strikes against me.  I'm looking down the barrel of an extremely tight timeframe(basically today and tomorrow) where I need to create some tests for an application I've built using the Spring MVC paradigm.  This is my first time using Spring, and am really trying to test the back end of the application. The model connects to an Oracle database and executes a variety of both Stored Proc's(PL/SQL), and some prepared Statements, and straight sql. The application is a real heavy datahog.  I would like to create a variety of tests for perhaps starting at the controller(anyplace is fine), however since I'm using Spring, I find myself almost encumbered by it's paradigm.  So, I really don't even know if my Models will behave , because I have to move the application up to a server, and up to this point, I'm a little in the dark regarding the placement of the tests. I'd done Web Services in the most recent past, (without Spring), and the tests are pretty straight-forward. So for the rest of the afternoon, I'm going to try to put some substance to testing(a little late, but the timeframes on this project have been sick), using a combination of SpringMock and EasyMock. Could anyone comment and/or provide a walkthrough of what I'm looking at?  I really want to test the Http portion of the app, but don't know if I need to put everything up on the server to do this, will I need to put a jsp together to activate the tests?  As you can tell, I'm really unfamiliar to how to do this with the minimum of effort, but the most bang.... Thank you for reading this and if you have any ideas, God Bless you for helping me. Regards, Peter Adelmann</body>
  </mail>
  <mail>
    <header>Re: Newbie--Trying to create tests for Spring implemented MVC appliction.</header>
    <body>This is straightforward, although it definitely helps to have someone walk you through it the first (few) times. The book Expert Spring MVC has good examples of using EasyMock to mock the service you inject with Spring, and then using MockHttpRequest and calling handleRequest(). I figured this out myself, but starting from the book would be a great advantage.  (I have nothing to do with this book besides having read it.) nd</body>
  </mail>
  <mail>
    <header>[Announcement] EasyMock-PropertyUtils 1.0 Released</header>
    <body>EasyMock-PropertyUtils lets you test property values when matching arguments using EasyMock. See the announcement here:</body>
  </mail>
  <mail>
    <header>Re: Newbie--Trying to create tests for Spring implemented MVC appliction.</header>
    <body>Henri, Andrew, Rasmus, Thank you so much for your suggestions, comments.  I have a copy of Expert MVC that I carry around with me....and maybe some day I'll even get to read it.  Things are in much better perspective now. I can spend some time reviewing all the information you've provided and get in the mind-set.  I wish I could learn thing in an hour or less, but then mangers would expect results in 5 minutes... Cheers and once again thank you for taking the time to answer. Peter using a application using straight controller(anyplace is encumbered and up of the project looking know</body>
  </mail>
  <mail>
    <header>Re: Re: Thread safety problem in EasyMock 2.2</header>
    <body>Hello Bill, thanks for the patch, I commited it today. Tammo</body>
  </mail>
  <mail>
    <header>Re: Thread safety problem in EasyMock 2.2</header>
    <body>Can someone please add the thread safe LastControl.java file to the files section?  I don't use eclipse or cvs so the path will not work for me. I have looked through the patch file and it seemed pretty straight forward to change - I made the changes but I am still having what I believe to be a threading issue. (Running the test alone works, running it as part of a suite fails with either "matcher calls were not used outside expectations" or "0 matchers expected, 1 recorded") I can change a passing test and get the failing test to pass - which leads me to believe the problem is a threading issue. The problem is complicated to explain, so rather than attempt to explain it I will work up a simple way to replicate the problem and post it tomorrow. I first wanted to make sure that I have correctly patched LastControl, thus the request to post the corrected file. Thanks, Dale</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. You can access this file at the URL:  To learn more about file sharing for your group, please visit:  Regards,</body>
  </mail>
  <mail>
    <header>Re: Confused: IllegalStateException: matcher calls were not used outside expect</header>
    <body>I solved this by replacing ".andReturn(isA(Distribution.class))" with ".andReturn(new Distribution())" in the expect() call. --James component that I am mocking using EasyMock.  I am testing a method of the component which does nothing other than call its member DAO component's makePersistent() method.  This method's signature looks like this: DAO property of the component I'm testing.  I then record the call to makePersistent() like so: expect(mockDistributionDao.makePersistent(isA(Distribution.class))).andReturn(is\ verify that the mock object was called as expected. expectations extensive searching using Google.  Can someone here explain to me what the above error means and/or what I'm doing wrong?</body>
  </mail>
  <mail>
    <header>Re: Confused: IllegalStateException: matcher calls were not used outside expectations</header>
    <body>Hello, [...] The error message is confusing here, it should be 'matcher calls were used outside expectations' (already fixed in HEAD). in the andReturn() part, simply specify the object that should be returned, or return null if it's not important in the test: expect(mockDistributionDao.makePersistent(isA -Tammo</body>
  </mail>
  <mail>
    <header>Re: Nonspecific Testing of Overloaded Method Calls</header>
    <body>Well, you could use jMock instead :) I can't tell enough from your posting, but you might want to think about introducing a layer above the package and mocking /that/. The idea would be to write interfaces that express your use of the package /in your domain/. That's the real value of mocks, to drive a cleaner design. Then you could test your eventual implementation of those interfaces against the real library. This implementation would be minimal and focussed, avoiding some mocking issues when testing against a larger stack. When mocking is difficult it's usually trying to tell you something. Unfortunately, sometimes your options to respond are limited. S. Steve Freeman M3P Limited.  Winner of the Agile Alliance Gordon Pask award 2006</body>
  </mail>
  <mail>
    <header>mocking local variables, static classes</header>
    <body>Hi, I am trying to develop some best practices for unit testing on my project. Currently there is almost no unit testing on the project. I am trying to use easymock for mocking a backend ( a hibernate session, encapsulated in a custom properitary architecture). I am running into the following problems and I am wondering if there is a way to do it with easymock. 1) a backend is declared and initialized as a local variable in a method. Is there a way to say, when you get to use this method, use the mock instead. 2) a static class with static methods is also used extensively. Is there a way to get around this. 3) Easymock documentation says that final classes will not be mocked. However if we have an object of that class that is being passed in as a final argument to a method, will that be mocked ? Thanks for your time. Faisal</body>
  </mail>
  <mail>
    <header>Re: New Matchers</header>
    <body>It is not.  I'm not sure if it'll be possible to be both refactoring-safe and straight-forward to use.  The only way I can think of to do this in a refactoring-safe way would be to go beyond answers, and then the matcher would run those same methods on the incoming parameter and check that the return values match.  That's a bit beyond the scope of what I'd know how to get started on at this point, but if it sounds feasible to you, it could be a powerful (though fairly clunky) way to do really complicated matching if someone really needed it... Separate from the refactorability, another path I'd like to investigate at some point is that currently it can only do equality for the property.  It would be better if existing matchers could be applied to the property, so that all the currently suported matching could apply to the property (including the date stuff). As you'll see in the code, the current stuff is a bit messy &amp;amp; very simple.  It really is intended mostly as a jumping-off point for figuring out something better if possible and if anyone's interested... intoemy own style, built with Maven 2...) with a full coverage Ok.  I've added it to the files section.  I donate it to EasyMock, so it's yours to release under the EasyMock license. -Stephen</body>
  </mail>
  <mail>
    <header>Re: New Matchers</header>
    <body>looking at these. For takes different I'm posting a second zip where I removed the extra propertyEq methods. I think the simpler one that takes in the object is a bad idea as it will encourage using the same object that expect to get back, which would defeat the tests purpose by setting the value before testing starts.  The one that takes a blank object to determine the class was just redundant; clearer to specify the class.  I also fixed a bug caused by using BeanUtils instead of PropertyUtils, and added tests to prevent it from happening again. - Stephen</body>
  </mail>
  <mail>
    <header>Re: How to match varargs</header>
    <body>I am trying to create an arguments matcher which compares varargs. But am getting into problems. The method I want to create the matcher for looks like this: void attributesSet(ManagedObjectImpl mo, AttributeChangeInfo... I don't think my implementation of the matcher is faulty ... I think the problem is in my static declaration of the argument matcher: The problem seems to be in the return value from the above declaration. When I returned null I get the following error: java.lang.NullPointerException at java.lang.reflect.Array.getLength(Native Method) at org.easymock.internal.matchers.ArrayEquals.createObjectArray(ArrayEquals.java:73\ ) at org.easymock.internal.Invocation.expandVarArgs(Invocation.java:32) at org.easymock.internal.Invocation.&amp;lt;init&amp;gt;(Invocation.java:23) at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:24\ ) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:45) at $Proxy1.attributesSet(Unknown Source) When I return an empty array as above I get: java.lang.IllegalStateException: 1 matchers expected, 2 recorded. at org.easymock.internal.ExpectedInvocation.createMissingMatchers(ExpectedInvocatio\ n.java:41) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:33) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:26) at The test code looks like this: Any ideas what I can do to resolve this?? Regards, David</body>
  </mail>
  <mail>
    <header>Re: Re: How to match varargs</header>
    <body>Hello David, it is currently not possible to specify an own matcher for the array of varargs, the varargs are handled one-by-one. For the case you described above, no own argument matcher should be neccessary: - Tammo</body>
  </mail>
  <mail>
    <header>Re: New Matchers</header>
    <body>And I've posted yet another version that allow providing the properties as a Map so that several properties can be checked at once. I'd like some feedback on whether these (or what parts) will be included in EasyMock, so that I can maintain whatever is not included as a separate open-source project.</body>
  </mail>
  <mail>
    <header>Re: Re: New Matchers</header>
    <body>Am 08.09.2006 um 19:33 schrieb Stephen Duncan Jr: Hello Stephen, The time matchers or something similar will be included, but I can't tell when I'll find the time to do it. The property matchers will not be included, as they are not refactoring-safe. - Tammo</body>
  </mail>
  <mail>
    <header>Re: New Matchers</header>
    <body>Thanks for the information.  That's what I figured. -Stephen</body>
  </mail>
  <mail>
    <header>&lt;i&gt;&#xD;
        (No subject)&#xD;
      &lt;/i&gt;</header>
    <body>Hi, just used EasyMock.anyObject for the first time, and was somewhat bewildered that I had to use a cast... ;) I know it doesn't improve a lot, but what about being able to write instead? Shouldn't be too hard to implement - didn't try it, but something like the following should work, I'd guess: What do you think? See you at XPday Germany :) Regards, Ilja</body>
  </mail>
  <mail>
    <header>&lt;i&gt;&#xD;
        (No subject)&#xD;
      &lt;/i&gt;</header>
    <body>bewildered that I had to use a cast... ;) something like the following should work, I'd guess: Unless I'm missing something, you should use: -Stephen</body>
  </mail>
  <mail>
    <header>Re: (unknown)</header>
    <body>I see - will try that monday. Might do the trick, but doesn't really communicate what I want to test. I don't want to test that the parameter is-a PropertyChangeEvent - the method signature already guarantees that. I want to test that the method gets called with an arbitrary PropertyChangeEvent. Does that make sense? Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: (unknown)</header>
    <body>Am 16.09.2006 um 10:00 schrieb Ilja Preuss: Hello Ilja, Stephen's idea should work fine. If you would like to check that a non-null Object gets passed, I would use anyObject() accepts anything (even null). - Tammo</body>
  </mail>
  <mail>
    <header>Re:</header>
    <body>Am 15.09.2006 um 14:59 schrieb it@...: Hello Ilja, you are right, that would work as well. I opted against it, as the argument would only be passed for the type cast, and not be part of the matcher validation. Especially on other matchers this looked really strange. Consider aMock.log(notNull(String.class)) vs I think the first one is harder to read, and even misleading. See you at XPDay 2006, Tammo</body>
  </mail>
  <mail>
    <header>Re:</header>
    <body>Tammo Freese schrieb: Well, then it seems we just have different tastes in this regard. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Announcing: EasyMock-PropertyUtils</header>
    <body>&lt;a href="http://www.stephenduncanjr.com/2006/09/announcing-easymock-propertyutils.shtml"&gt; (Please let me know if you're ok or not with me announcing future items about this or similar projects such as releases, etc. on this list)</body>
  </mail>
  <mail>
    <header>Re: EasyMock ClassExtension 1.2 does not initialise fields</header>
    <body>You're missing the point. Bypassing the constructor can be very handy, but I'm talking about bypassing field initialisation. This is not a constructor, but a field declaration with initialisation. My point is that this field will not be initialised in the mocked instance. Now, you could argue that being able to bypass field initialisation is also a nice feature, and I would agree to some extent. But I think it should have been documented as a breaking change between 1.1 and 1.2, and that there should be a property that can disable this feature. -- Ulrik is an net.sf.cglib.proxy.Enhancer.create create in the the most org.easymock.classextension.internal.SunClassInstantiatorimplementation will be used. This is a real beast. It does not call order to effect of initialised. Using (unless the fields serious in two default behavior, either. you get two and/or brand. think it to do. .vendor" work-around is using</body>
  </mail>
  <mail>
    <header>Re: EasyMock ClassExtension 1.2 does not initialise fields</header>
    <body>Good, so we are on the same page. I like the idea of _being able to_ bypass constructors and initialisers. However, I do have a couple of issues with the implementation: 1. It varies depending on JVM brand and version, and the algorithm used to decide that is flawed. "java.vm.specification.vendor" is pretty much always Sun, isn't it? "java.vm.vendor" would be more correct. 2. It uses an internal sun.reflect class for which there is no source code available. Or is there? 3. It can't be turned off without changing central system properties like "java.vm.specification.vendor" or "java.vm.version". Any comments on those? -- Ulrik compatible release notes. handy, Before, some from the of your a real result in created org.easymock.classextension.internal.SunClassInstantiatorimplementation documentation or DefaultClassInstantiator</body>
  </mail>
  <mail>
    <header>Help for matcher</header>
    <body>Hello, Expert, I do not understand the following error messages associated with a matcher I implemented. No matter what expected count I specified in the test code, it always return the same error. I must did something wrong. Pls give me some light! Thanks &amp;amp; Regards [ stacktrace ] ------------------------------------------------------ ----- java.lang.IllegalStateException: 2 matchers expected, 1 recorded. at org.easymock.internal.ExpectedInvocation.createMissingMatchers (ExpectedInvocation.java:41) (ExpectedInvocation.java:33) (ExpectedInvocation.java:26) at org.easymock.internal.RecordState.invoke (RecordState.java:64) at org.easymock.internal.MockInvocationHandler.invoke (MockInvocationHandler.java:24) at org.easymock.internal.ObjectMethodsFilter.invoke (ObjectMethodsFilter.java:45) at org.easymock.classextension.internal.ClassProxyFactory$1.intercept (ClassProxyFactory.java:67) at com.hp.ov.nms.disco.analyzer.AnalyzeInfo$$EnhancerByCGLIB$$c9c2269d.a ddData(&amp;lt;generated&amp;gt;) at com.hp.ov.nms.disco.analyzer.arp.ArpCacheAnalyzerTestCase.testProcess DataDefinition(ArpCacheAnalyzerTestCase.java:80) ----------------------------- Test code ---------------------- cache entries is " +</body>
  </mail>
  <mail>
    <header>Re: Help for matcher</header>
    <body>Hello, If you would like to use matchers in a call, you have to specify matchers for all arguments of the method call. change this to info.addData(eq(IfMacMappings.IFMACMAPPINGS), HTH, Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: Problems with conversion warnings using generics on createMock()</header>
    <body>Here is how I fixed it. It's not a nice solution. I created a blank, useless inner interface that specifies the type parameter, like this: And then I use: The warning goes away and my tests still pass (they were passing before). This reveals two things to me about generics. 1) I didn't really understand them fully until I stumbled across this problem. The lightbulb turned on when I realized that there is no such class as Foo&amp;lt;Flurfl&amp;gt;, that it is merely a construct of a "complier hint" until it is specified by an actual type: that generic declarations are not to be confused with concrete definitions. 2) The solution is very, very stupid and shows the limitations of generics in that I had to define something I never wanted to use just to get a real class. Because generics are not supported on a bytecode level, only on a compiler level, this stupidity will likely persist in Java for some time to come.</body>
  </mail>
  <mail>
    <header>Re: Problems with method expecting an array parameter</header>
    <body>Eh eh, yes :-) parameter</body>
  </mail>
  <mail>
    <header>How to match varargs</header>
    <body>I am trying to mock a method with variable arguments (vararg). I would like the mock object to ignore all the arguments and just return something, but I can't get it right. The method I am trying to mock looks like this: The specific call I am trying to mimic receives nine strings as arguments, so I wrote the expect call to nine anyObject()s casted to strings. It is working for now, but the number of strings can change, and I wouldn't like the test to fail when it happens. Not to mention that the multiple calls to anyObject() look really ugly. Any ideas? Cheers, Thiago Arrais -- Mergulhando no Caos - Pensamentos, idéias e devaneios sobre desenvolvimento de software e tecnologia em geral</body>
  </mail>
  <mail>
    <header>Re: How to match varargs</header>
    <body>9 parameters are a little too many I think (or are you testing a command line interface input method?). Why don't you introduce a parameter object? :-) Anyway, if the method contract/signature changes, it is normal to update the test, isn't it? And so, it is good if we have a failure to look at. Just my opinion :-) Regards, -- Alessio Pace</body>
  </mail>
  <mail>
    <header>Re: Re: How to match varargs</header>
    <body>You guessed it right! Sure, but this is covered by another test. On this test I am talking about, a mock object is used just as a stub to return a hard-coded result. It really doesn't care if its arguments (or the number of arguments) change. Regards, Thiago Arrais</body>
  </mail>
  <mail>
    <header>easymock-classextension behaviour calling replay() and verify() with varargs?</header>
    <body>Hi, I noticed that when using easymock-classextension to mock concrete classes, I can't call org.easymock.classextension.EasyMock.replay() and org.easymock.classextension.EasyMock.verify() passing more than one mock object per call, because I get the stacktrace: java.lang.IllegalArgumentException: not a proxy instance at java.lang.reflect.Proxy.getInvocationHandler(Proxy.java:637) at org.easymock.EasyMock.getControl(EasyMock.java:1336) at org.easymock.EasyMock.replay(EasyMock.java:1280) at [......] It all works instead if I make a single replay() (and verify() ) call for each mock object. So, for instance: gives the exception. While instead: does the trick. I paste a test case I wrote to show the thing. The first test shows the expected beahviour using varargs when the mock objects are mock made from an interface type (Collaborator), the other 2 tests are instead over mock of a concrete class (CollaboratoImpl): the one using varargs does not pass throwing the exception above. You can copy and paste it and then run it, it just requires JUnit, EasyMock and EasyMock-classextension. Regards, Alessio Pace. // ===================================== /* OK */ public void testReplayWithVarargs_onMockInterfaceTypes() throws this.clazzUnderTest = new ClazzUnderTest(this.mockFirstCollaborator, EasyMock.replay(this.mockFirstCollaborator, EasyMock.verify(this.mockFirstCollaborator, /* DOES NOT WORK LIKE THE PREVIOUS TEST */ public void testReplayWithVarargs_onMockConcreteTypes() throws this.mockFirstCollaborator = this.mockSecondCollaborator = this.clazzUnderTest = new ClazzUnderTest(this.mockFirstCollaborator, /* gives Not a proxy instance in this way */ EasyMock.replay(this.mockFirstCollaborator, /* gives Not a proxy instance in this way */ EasyMock.verify(this.mockFirstCollaborator, /* IT WORKS IF INVOKING replay() and verify() on each mock object */ public void testReplayAndVerifyOneByOne_onMockConcreteTypes() throws this.mockFirstCollaborator = this.mockSecondCollaborator = this.clazzUnderTest = new ClazzUnderTest(this.mockFirstCollaborator,</body>
  </mail>
  <mail>
    <header>Re: easymock-classextension behaviour calling replay() and verify() with varargs</header>
    <body>Thanks for the information, I hope to see the 2.3 soon then :-D If useful, obviously feel free to reuse the test case. cheers, Alessio Pace replay easymock frozen</body>
  </mail>
  <mail>
    <header>Re: How to match varargs</header>
    <body>Am 17.07.2006 um 20:26 schrieb Thiago Arrais: Hello Thiago, unfortunately, there is currently no better way to do this. If you've got an idea how the calls should look like, please provide some test cases. Thanks, Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: How to match varargs</header>
    <body>How about expect(mock.execute(anyObjects()))? This could even be extended to non-varargs methods. Is this possible in Java? Cheers, Thiago Arrais -- Mergulhando no Caos - Pensamentos, idéias e devaneios sobre desenvolvimento de software e tecnologia em geral</body>
  </mail>
  <mail>
    <header>basic query regarding mock objects</header>
    <body>Hi, I am new to using mock objects for unit testing and has a fundamental question regarding testing using EasyMock. In most of the examples provided in EasyMock, the mocks are injected to the class under test using dependency injection pattern. I am trying to test a Session bean class which internally creates an instance of DAO class. This DAO class is an interface and its implementation is created by the session bean using a factory class. I would like to mock the factory class (which is a singleton) so that I can provide a mock implementation of this DAO interface. Is there a way where I can mock these classes without refactoring the Session bean class (to use DI pattern)? The session bean class has already been implemented. Best Regards, Vinay</body>
  </mail>
  <mail>
    <header>Re: basic query regarding mock objects</header>
    <body>Hi Vinay, You've got at least a couple of options.  First of all, you could refactor the Session Bean so that it is just a thin facade on a normal Java class and then pass the DAO interface into the normal Java class. This should be a very safe refactoring, and your facade should then be 'too simple to fail'.  This would allow you to test your normal Java class outside of the session bean by mocking the DAO object and passing it in. Secondly, if you used a JNDI lookup to get the DAO interface's implementing class, you could use mockrunner ( JNDI namespace and get it out.  I've used that mechanism to, for instance, mock web service interfaces that were stored in JNDI. That's a lot of work compared to option 1, though. Third, you could change the factory class to add a protected 'setDAO()' method to inject in a mock object, add a method to the session bean (not exposed through the public interface) to set a new factory to use, subclass the factory class to use the setDAO(), and then run the session bean via mockrunner, using the subclassed factory.  That's *really* a lot more work than option 1. Last, get yourself a copy of Michael Feather's "Working Effectively with Legacy Code" and refactor your code to get it under test.  He doesn't address this problem (getting a session bean under test) specifically, since it's more of a symptom of not having developed the classes via TDD in the first place.  I'm going through this exercise right now, and it's not much fun :) Hope that helps, - Bill -- Bill Woodward     wpwood@... "I have more trouble with D. L. Moody than with any other man I ever met." -- D. L. Moody</body>
  </mail>
  <mail>
    <header>setters?</header>
    <body>This feels like a dumb question, but googling didn't help me.  How do you set a mock's properties without verify() complaining that your code didn't call those setters? On a related note, anybody know of any open source projects out there using EasyMock 2.2 (i.e. a good set of real-world examples)? __________________________________________________ Do You Yahoo!? Tired of spam?  Yahoo! Mail has the best spam protection around</body>
  </mail>
  <mail>
    <header>Re: setters?</header>
    <body>Thanks Tim, I'm still getting up to speed here with mocking in general, and the codebase I'm working on wasn't particularly test-driven to begin with... anyway the thing I'm trying to mock has a method that returns void and modifies the input.  for example: the interface to mock: client code does this: // bunch of code // bunch of code I was trying to force the client code to run foo.execute() with a particular input by mocking the Populator and setting "override" to something that makes populate() return what I need. I ended up writing a fairly ugly stub populator to do that, but it seems like EasyMock should be able to help me here. p.s. Thanks for the tip about Tapestry. __________________________________________________ Do You Yahoo!? Tired of spam?  Yahoo! Mail has the best spam protection around</body>
  </mail>
  <mail>
    <header>Re: setters?</header>
    <body>That's awesome.  I was wonder what IAnswer was all about.  Thanks, I'm sure this will fit the bill. __________________________________________________ Do You Yahoo!? Tired of spam?  Yahoo! Mail has the best spam protection around</body>
  </mail>
  <mail>
    <header>Re: setters?</header>
    <body>got around to replacing that stub I had with your solution today... works great with a small mod.  This is going to come in handy all over the place, thanks for the assist. // had to use expectLastCall() since expect() won't work on a void call. mockPopulator.populate(isA(Request.class), __________________________________________________ Do You Yahoo!? Tired of spam?  Yahoo! Mail has the best spam protection around</body>
  </mail>
  <mail>
    <header>New Matchers</header>
    <body>There are two needs for paramter matchers that I've found that I'd want while using EasyMock.  The first is for matcher that handle dates.  The second is for matchers that compare equality by looking at some property on the object. So I coded up a utility project for my use that implements these.  For dates it provides before(), after(), between(), and approxDate(). approxDate() comes in two flavors: approxDate(date) that uses a 1-second margin of error, and approxDate(date, errorMargin) that takes in the margin of error in milliseconds. For property equality I wrote a very basic property equality matcher that uses commons-beanutils to get the property.  I've a few different ways to call the matcher.  I think implementing property equality could probably be done better, but it is a start. I'd like to see these two categories of use cases incorporated into Easymock.  What's the best way to share what I've got?  I have a full project (in my own style, built with Maven 2...) with a full coverage of test cases that I would just want to change the package names before handing over.  I think the date methods &amp;amp; classes could be taken in with minimal style &amp;amp; testing changes; the property equality stuff could probably use some design work to do something better, but what I have could at least maybe trigger some though.</body>
  </mail>
  <mail>
    <header>Method throwing an exception but not returning anything</header>
    <body>Hi all, I just joined today and this is my first post on the group. I am stuck into this problem which I am sure someone else would have faced before. I tried mock a method call that throws an exception like: void method(int a) throws XException The TestCase: void testXYZ() But the problem is: EasyMock.expect method only takes method calls as argument that return something. So I am stuck. Is there any way in easy mock to achieve this? Any help is kindly appreciated. Thanks, Shimol.</body>
  </mail>
  <mail>
    <header>Re: New Matchers</header>
    <body>Hello Stephen, Sounds great! Is this refactoring-safe or not? Just send it to the group. To be incorporated in EasyMock, it has to be released under the license/copyright of EasyMock. -- Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: Method throwing an exception but not returning	anything</header>
    <body>Hi Shimol, Use expectLastCall().andThrow(). Here is an example:</body>
  </mail>
  <mail>
    <header>Re: Method throwing an exception but not returning anything</header>
    <body>Hello Shimol, for void methods, you may use expectLastCall(): ... -- Tammo Freese</body>
  </mail>
  <mail>
    <header>Create mock object using a constructor with parameters</header>
    <body>Hi. I`m using EasyMock Class extension 2.2 in my JUnit tests. Now, i need to create a mock object calling a constructor with some parameters. I read in documentation that it`s impossible. It's true? Any idea? Thanks.</body>
  </mail>
  <mail>
    <header>Mocking a service locator</header>
    <body>Hi, I have a case where the class under test calls a singleton to obtain a service: MyServiceLocator.getInstance().getService("Service I want the class under test to use a mock service. My idea is to create a mock MyServiceLocator where calls to getService("Service A") would return a mock service. I was able to create a mock service locator using MockClassControl - worked fine. However, I can't record a replay sequence that would return my mock service. For example doing this won't work because the actual code under test uses the getInstance() method: Setting the return value for getInstance() doesn't work either because it's static. Is what I'm trying to do possible? Or is a different approach required? thanks, Rossen</body>
  </mail>
  <mail>
    <header>How to avoid testing super classes?</header>
    <body>Hi, there. I am looking for a solution about how to avoid testing super classes. I have a class which extends a class from a third-part library. I override one method of the super class to add some extra processes, then use super.xxxxx() to call the super version. In test code, all parameters passed to the method are mock object. This would lead to one problem, that is I must know how the super class uses these parameters and set behaviors for these mock objects. Apparently I am not interested in how super class uses these parameters. And I don't want my test codes are tied to a particular version of this third-part library. What I want to make sure is just those extra processes have been executed correctly and my overridden version indeed calls the super version of the method in the end. Is there a solution aim at such a problem? Best regards</body>
  </mail>
  <mail>
    <header>Re: Mocking a service locator</header>
    <body>Yes, this is the option I am likely to go with. I was just looking for a simpler solution. This is not an option because I am using a foundational layer I can't modify. I don't really understand this. Could you elaborate? thank you, Rossen</body>
  </mail>
  <mail>
    <header>Re: Mocking a service locator</header>
    <body>Is that singleton part of the foundational layer? Can you really not modify it AT ALL? I have successfully used mocks behind a singleton service registry by making the "private static Singleton instance" variable into "protected static Singleton instance" and then made a subclass of the singleton that returns what I need from the equivalent of "getService". Making a field more accessible is, of course, a "safe refactoring". It cannot break anything. Field singletonInstanceField = MyServiceLocator.class.getDeclaredField("_theInstance"); // or whatever singletonInstanceField.setAccessible(true); // rude reflection hack Where MockServiceLocatorSubclass is a subclass of MyServiceLocator. ~Johannes</body>
  </mail>
  <mail>
    <header>Re: Mocking a service locator</header>
    <body>Thank you. I was missing the part where setAccessible(true). Yes, the foundational layer is maintained by another group within the company so it makes it pretty inaccessible in reality. Ross</body>
  </mail>
  <mail>
    <header>Re: Mocking a service locator</header>
    <body>My recommendation is that you nag them again, and again, and again: "So, how am I supposed to test my code that uses your code?" I've seen it work. ESPECIALLY with internal "frameworks", it is the damned job of the framework developers to consider their clients need for testing. (I have to end this mail now before I get too worked up. Sorry) Good luck. ~Johannes</body>
  </mail>
  <mail>
    <header>Re: How to avoid testing super classes?</header>
    <body>Dear Tim: your solution works. What can I do after extracting the call to super.xxxx ? What can I do to prevent testing parentMethodUnderTest when methodUnderTest is being tested ? Best Regards want to extract-method that</body>
  </mail>
  <mail>
    <header>Re: How to avoid testing super classes?</header>
    <body>Currently I am working with easymock 1.2, so using anonymous class is the only option. Although the extracted method of calling super method looks a little bit strange, it solves the problem indeed. Thank you, Tim and Henri. Downey" great classes. processes, objects. particular super</body>
  </mail>
  <mail>
    <header>Returning simple values.</header>
    <body>Hi, I'm trying to test a function that should return a simple int. When I try to just do (where ACCESS_GRANTED is an int), the compiler complains that you can't cast an int to an object.  Is there a way to return an int value with this?</body>
  </mail>
  <mail>
    <header>Re: Returning simple values.</header>
    <body>Hi, the preferred solution is: You may also use the longer version: EasyMock.expectLastCall().andReturn((int) Hope that helps, Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: Returning simple values.</header>
    <body>Err sorry.  That's what I did, I just didn't write it.  I used the longer version, since the compiler throws another error about expect() not wanting an int (since the function returns an int). My more complete code: AccessDecisionVoter grant = (AccessDecisionVoter)</body>
  </mail>
  <mail>
    <header>Re: Returning simple values.</header>
    <body>Also, casting it to (int) doesn't work.  I still recieve the same error: andReturn(java.lang.Object) in org.easymock.IExpectationSetters cannot be applied to (int) value</body>
  </mail>
  <mail>
    <header>Re: Returning simple values.</header>
    <body>That might actually be it.  Thanks! error: "iangrey531" expect() simple int. that you</body>
  </mail>
  <mail>
    <header>Re: Returning simple values.</header>
    <body>Well, I'm pretty confident I've got java 1.5, but I'm still getting the errors.  Any other guesses? there's no cannot Tammo an int</body>
  </mail>
  <mail>
    <header>Re: Returning simple values.</header>
    <body>Okay, I had java 1.5, but my project was set up to compile in 1.5 for some reason.  I got it working now.  Thanks for your help.</body>
  </mail>
  <mail>
    <header>Problems with conversion warnings using generics on createMock()</header>
    <body>This is a really simple question for people who have written classes that implement generics. I have been using generics a lot but I haven't writen any generic implementation code, which I've heard is hard if you've never done it. I have an interface that goes something like this When I go to use easymock to create a mock, like this: I get a "Type safety: The expression of type Foo needs unchecked conversion to conform to Foo&amp;lt;Flurfl&amp;gt;" So it warns me that, in essence, I'm not typesafe with that call to createMock, but I have no idea what the syntax is to tell createMock that I want a Foo&amp;lt;Flurfl&amp;gt;. The simplest thing would be something like this: But that obviously doesn't work. What am I not getting here? Thanks for any insights. Nick</body>
  </mail>
  <mail>
    <header>Re: Problems with method expecting an array parameter</header>
    <body>I changed it like you suggested and it works. I had to change also: to: Great bug.. :-) Thanks a lot, Alessio Pace. EasyMock.expect(mockCollaborator.joinStrings(aryEq(this.expectedInput))).and Behalf method constructed inside of the maven2 EasyMock.expect(mockCollaborator.joinStrings(this.expectedInput)).andReturn( object of reference with commas far as I</body>
  </mail>
  <mail>
    <header>Re: Support for varargs in replay/verify in EasyMock class extension 2.2</header>
    <body>Am 24.04.2006 um 02:04 schrieb Tim Downey: Never mind, thanks for reporting it! It's fixed in the class extension 2.2.1 available at  HTH Tammo</body>
  </mail>
  <mail>
    <header>Re: Test failure after upgrade to EasyMock 2.2</header>
    <body>Hello Tim, [...] In EasyMock 2.2, it is checked at replay() that no additional calls were made. An example: will fail, since notNull() is used in a wrong place. In EasyMock 2.1, the notNull() call may have caused the next test to fail, or even modify the semantics of the next test. Or be ignored, if it's the last test that gets executed. Would you please boil down your example test by test and send me a minimal example? (only the test, not the production code ;)) Thanks, Tammo</body>
  </mail>
  <mail>
    <header>How exactly does setDefaultReturnValue() work?</header>
    <body>Hi there, glad to be here. Thank you, Tammo. =) I'm trying to get over the hump of EasyMock newbie-ness, and am bumping up against a problem that makes me wonder how the experts would do this.  By the way, I'm using EasyMock 1.2 for Java 5. Basically we have a rather heavy-weight (talks to the database) access-control system that we make use of in many places in our code. Typically our use of this interface looks like the following: boolean hasAccess = getPermissionChecker().checkAccess(user, target, Simple enough, what I'd like to do is mock this PermissionChecker class so that I can easily set up test cases with various permission assignments.  What I would like to do is, by default, have the checkAccess() method return false anytime it is called in my test UNLESS I specify otherwise. My first attempt at this was something like this: // in setUp() . . // in testMethod() It seems like that once a defaultReturnValue has been specified, there's no way to override it, which isn't altogether surprising.  Is there any accepted way of doing something like this? Thanks very much for your time.</body>
  </mail>
  <mail>
    <header>Re: How exactly does setDefaultReturnValue() work?</header>
    <body>Hello, Am 24.04.2006 um 22:29 schrieb bdotzour: You should definitely upgrade to EasyMock 2.2: Less code, better features, better usage of Java 5. Yes - the way you've done it :) I could not find any error in your code. To be sure, I wrote a quick test (see below), and the feature seems to work fine. Maybe you forgot to specify that the call is allowed more than once: or equivalent: control.expectAndReturn(checker.checkAccess(actualUser, actualTarget, BTW, the same spec in EasyMock 2.2 (more readable, no MockControl): expect(checker.checkAccess(actualUser, actualTarget, In EasyMock 2, default values are replaced by stub values, which allow for greater flexibility. See the documentation for details. HTH, Tammo ----------------</body>
  </mail>
  <mail>
    <header>Re: How exactly does setDefaultReturnValue() work?</header>
    <body>Excellent!  Thanks, Tammo, for your response.  I'm very glad to hear that is how it's supposed to work.  Needless to say, the problem was in my test and not in EasyMock =) I had paraphrased my setup to make it a shorter post, but as it turns out, we were using a 3rd party framework that provided some nice utility classes on top of EasyMock. The unfortunate thing was that it was always creating STRICT mocks rather than normal mocks.  Therefore, the problem I was running into was that my script was not getting called in the same order that it was scripted. Long story short, using the normal mock (unordered execution) fixed my test. Thanks for your help!</body>
  </mail>
  <mail>
    <header>Re: Re: Test failure after upgrade to EasyMock 2.2</header>
    <body>Hello Tim, I am glad that your problem has been resolved. I am afraid I can't help you there. I recommend introducing interfaces and testing against them, instead of mocking classes. Maybe Henri can help you. He knows the Class extension and the associated CGLIB much better than I do. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Re: Test failure after upgrade to EasyMock 2.2</header>
    <body>Hi, It is a really interesting issue. The thing is that I'm creating a new class for each mock. Which means the class loader contains a lot of classes after a while. I'm required to do that because an interceptor (whose doing the mocking behavior) is set for a class and not for an instance. I'll check if something smarter can be done. One think that will minimise the issue is that cglib team (that I use to create the mocks) is currently working on recuding the bytecode of their classes. So they should take less memory (and also being created faster). Meanwhile, the best solutions for you are to increase PermGen like you did or to fork you tests. Since this normally make them run slower, maybe partially fork them can help. Hum... I'm thinking about weak references here... and I think surely something smarter can be done. Thanks for the feedback, Henri</body>
  </mail>
  <mail>
    <header>Generate Interface</header>
    <body>Does someone know some tool to generate a java interface from a java class (.java or .class)? I've googled for it but no luck. :-)  </body>
  </mail>
  <mail>
    <header>Re: Generate Interface</header>
    <body>(.java or .class)? The standard Eclipse refactoring tools do this. jim</body>
  </mail>
  <mail>
    <header>Changing expectations</header>
    <body>Hi, I was tryting to set up a mock with some general expectations un the Junit.setUp() method and then adding some more expectations in the actual test method and the replaying the mock. Is it possible to reset the mock without removing the expectations ? Like resetting all the counters maybe changing some of the expectations and then reusing it? in pseudocode it would look something like this replay() So ya to my experience reset() removes all expectations. The way I worked around this was by creating a setupMock method that calls all the expectMethods that should be generally available. Like the getName method. Any help or Ideas would be greatly appreciated. Regards Andreas</body>
  </mail>
  <mail>
    <header>Re: Changing expectations</header>
    <body>I would suggest just to add a reset method to your test class: Should do what you want. No, it's not genuinely included to have some recording savepoints. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: Changing expectations</header>
    <body>Hello Henri, thanks for the reply, as a matter of fact that's exactly what I ended up doing. Good to know that I didn't miss a feature. But maybe that's something for the future. Who knows :-) I should go to bed, it's midnight here in Europe. I really have to say everyone in this group and everyone involved in the development of EasyMock has my greates respect and appreciation. It's awesome work you do. Keep it up. Regards Andreas</body>
  </mail>
  <mail>
    <header>Mock Decorator</header>
    <body>EasyMockers, I have been using this pattern on my tests and mock objects where you use a mock object as proxy to a real object. It is an application of the Decorator pattern, having the mock delegate all the calls to the real object and just controlling if the messages were sent in the correct order. Most of the time I do this when I need to mock a library object and check if the expected method were called. Can I do that with EasyMock? Do you think there is a better way to do that? Cheers, Thiago Arrais</body>
  </mail>
  <mail>
    <header>Eclipse Plug-In</header>
    <body>Is EasyMock published as an Eclipse plugin anywhere? It would be useful for those among us that are Eclipse plugin developers. I tried searching the 'net but couldn't find anything. I am willing to publish this somewhere, if anyone hasn't done that yet. Cheers, Thiago Arrais</body>
  </mail>
  <mail>
    <header>Re: Eclipse Plug-In</header>
    <body>Henri, Me too. Let me explain my intentions... Just expose the easymock.jar to other plugins inside the platform. This is what was done to the JUnit library, for example. This would be useful (at least at first sight) for people like me that are developing other Eclipse plugins and using EasyMock for the tests. The Eclipse platform has built-in support for defining plugins and dependencies among them. The Eclipse-way of adding something to a plugin's available classpath is to declare a dependency to another plugin that has that something. The EasyMock plugin would just include the easymock.jar and expose the classes to other interested plugins. It would naturally be identified inside the platform by 'org.easymock'. I can do such a plugin, of course, but I need permission form the EasyMock folks (you :-) to use the name. Simple like that... Cheers, Thiago Arrais</body>
  </mail>
  <mail>
    <header>Re: Mock Decorator</header>
    <body>needed. Yup, I think I got it. Actually, I think what I am currently doing is almost ((if not exactly) that. But I thought there could be another (better) way to achieve that. Here is a commented code excerpt... ------------- // set expectations and have it return what the actual object would return expect(workspace.getRoot()). //                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //                      actual object ------------- Regards, Thiago Arrais</body>
  </mail>
  <mail>
    <header>Re: Eclipse Plug-In</header>
    <body>Yup, but the Eclipse standard way of doing that is packaging the library as a plugin. There is all the plugin dependency and OSGi stuff that Eclipse takes care for you when you do that. Tammo answer Maybe the plugin could be distributed on the easymock.org site or at least be mentioned as a reference once it gets published. I am sure this would save some people some headaches. I can try to keep the plugin synchronized at least with the major releases, that is no problem. Cheers, Thiago Arrais</body>
  </mail>
  <mail>
    <header>Re: Eclipse Plug-In</header>
    <body>I'd find this useful too. I've been trying to find out how to add the classpath variable (like JUnit does) using the org.eclipse.jdt.core.classpathVariableInitializer extension point, but I can't get this working yet (my class never gets called). Thanks for the offer to keep it synchronised too. I think it would be useful to host it on easymock.org too. Regards, Neil.</body>
  </mail>
  <mail>
    <header>Using JVMTI to remove all final modifiers at load-time</header>
    <body>Not sure if anyone will actually use this, but here you go anyway :-)  Chris</body>
  </mail>
  <mail>
    <header>Re: Can EasyMock simulate modification of a method parameter?</header>
    <body>Whoa,  looks like part of what I wrote and then (thought I) deleted wound up at the bottom of that last message.  Everything starting with the second "Andrew". to had the you method JUnit the actually correctly (in</body>
  </mail>
  <mail>
    <header>Error using mock for Hibernate SessionFactory</header>
    <body>The code is pasted below. This is using EasyMock version 2.0. This line: is not applicable for the arguments (Session) Using eclipse, it thinks that it should have a org.hibernate.classic.Session--which is not what I want, and isn't what that method on SessionFactory returns either. If I add a cast just for fun to get past the compiler error, I get a runtime ClassCastException at that point. This seems like a bug as I think I'm using it correctly. A rather odd bug, though. Any ideas? Thanks! public abstract class HibernateTestCase extends TestCase</body>
  </mail>
  <mail>
    <header>Re: Error using mock for Hibernate SessionFactory</header>
    <body>Hello Joel, openSession() on SessionFactory of Hibernate *does* return org.hibernate.classic.Session:  SessionFactory.html#openSession() HTH, - Tammo</body>
  </mail>
  <mail>
    <header>Re: [ANN] EasyMock 2.1 is available</header>
    <body>Tammo, do you know if the class-extension-2.0-pre is compatible with easymock-2.1? -barry</body>
  </mail>
  <mail>
    <header>Re: [ANN] EasyMock 2.1 is available</header>
    <body>Well I only asked Henri because I don't see a classextension 2.0 final on SF. Is it somewhere else? -barry</body>
  </mail>
  <mail>
    <header>Re: [ANN] EasyMock 2.1 is available</header>
    <body>Would it be possible to get 2.1 in the Maven repository? Thanks, nitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer\ +monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=zb3sFxhi-tmca0EDuSrdbg =Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer+monitoring+software\ &amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=I7EBHfo5x5ryPp_cfIwsbg monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+comput\ er+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=oV1vUZqKIG_WNHYmy3y9mA er+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+com\ puter+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=RishPPW2ja69fF9T9jDp4g</body>
  </mail>
  <mail>
    <header>[ANN] EasyMock Class Extension 2.1 is available</header>
    <body>Hello, I've uploaded the EasyMock Class Extension 2.1. This release does not introduce new features, it is recompiled to ensure compatibility with EasyMock 2.1. Henri has migrated the tests to JUnit 4. - Tammo</body>
  </mail>
  <mail>
    <header>Re: [ANN] EasyMock 2.1 is available</header>
    <body>Hello Andy, I have no experience so far with Maven, if you're experienced in using it, feel free to upload EasyMock and the EasyMock Class Extension there. - Tammo Am 23.03.2006 um 18:04 schrieb Andy DePue:</body>
  </mail>
  <mail>
    <header>Unexpected IllegalStateException</header>
    <body>I have a strange (to me) problem using easymock - a pair of test cases that seem innocuous won't run together. Either of the two test methods below will run and pass, but if they both run, the 2nd invocation of the initializeMocks() method throws an IllegalStateException (reproduced below) on the expect(holder.getPrevayler()).andReturn(prevayler).anyTimes() statement. What have I done wrong? Is there any way to remove all the stored easymock objects from ThreadLocal so I can be sure my tests are isolated? Best regards, jim ... @Before @Test @Test // @Ignore ... java.lang.IllegalStateException: 0 matchers expected, 1 recorded. at org.easymock.internal.ExpectedInvocation.createMissingMatchers(ExpectedInvocatio\ n.java:41) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:33) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:26) at org.easymock.internal.RecordState.invoke(RecordState.java:63) at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:24\ ) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:45) at $Proxy6.getPrevayler(Unknown Source) at uk.ac.cam.spectra.crystal.prevayler.PrevalentChemistUpdateTest.initializeMocks(P\ revalentChemistUpdateTest.java:41) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:585) at org.junit.internal.runners.BeforeAndAfterRunner.invokeMethod(BeforeAndAfterRunne\ r.java:74) at ...</body>
  </mail>
  <mail>
    <header>Re: Unexpected IllegalStateException</header>
    <body>Hello Jim, [...] See below. Calling matchers in the wrong place is the problem here. With EasyMock 2.1, you should get the error message when switching to replay(), therefore in the erroneous test case and not in the following one. is the line where the error. eq(c) and all other matchers should only be used as mock arguments. Change it to and the tests should pass. HTH, Tammo</body>
  </mail>
  <mail>
    <header>Re: Q: mocking a singleton and a class created in the tested class</header>
    <body>Hello Henri, Thank you for your answer. I was hoping there is a way to do it without the need to change the tested code... I need to find out a creative solution that will not result in many code changes. Thanks, David. some kind be able frameworks like You then outside. Maybe want to do. puter+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+\ computer+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=zb3sFxhi-tmca0EDuSrdbg tware&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer+monitoring+\ software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=I7EBHfo5x5ryPp_cfIwsbg Computer omputer+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Fre\ e+computer+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=oV1vUZqKIG_WNHYmy3y9mA 1=Computer+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=\ Free+computer+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=RishPPW2ja69fF9T9jDp4g easymock-unsubscribe@yahoogroups.com&amp;lt;easymock-unsubscribe@yahoogroups.com?subjec\</body>
  </mail>
  <mail>
    <header>Re: Unexpected IllegalStateException</header>
    <body>Thanks, Tammo! Works now. That will be useful - I was looking in the wrong place... Thanks, jim -- Jim Downing                    ojd20@... Software Developer, SPECTRa project</body>
  </mail>
  <mail>
    <header>How to intercept arguments or value of parameter passed to easymocked object.</header>
    <body>I'm trying to implement easymock frame for a project i'm looking for a soln for a problem i have an hand. 1)I mocked ExternalsericeSessionbean  which has only one method called process(RequestxmlString) and it responds with response xml string,i'm passing a xmlstring from an action class.during a single test run multiple actions  can be called from an action and they send out requestxmlstring as parameter to the same external service process method.how i will be able to differeniate one request from the other and send response accordingly and throw an exception. is there any way i can parse my requestxmlString get the string i need and send out response based upon it. 2)how to use to abstractmather, can i parse  the argument sent to easymock. Thanks</body>
  </mail>
  <mail>
    <header>Re: [ANN] EasyMock 2.1 is available</header>
    <body>Hi, I was wondering if EasyMock has been updated in the Maven Repositories yet, I haven't found it so I'm figuring it's not yet there!? Thanks, Andreas easymock   itoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer+\ monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=zb3sFxhi-tmca0EDuSrdbg  Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer+monitoring+software&amp;amp;\ c=4&amp;amp;s=123&amp;amp;.sig=I7EBHfo5x5ryPp_cfIwsbg  onitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+compute\ r+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=oV1vUZqKIG_WNHYmy3y9mA  r+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+comp\ uter+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=RishPPW2ja69fF9T9jDp4g ------------------------------------------------------------------------ ------------------------------------------------------------------------</body>
  </mail>
  <mail>
    <header>Re: Easymock upload to maven</header>
    <body>That's awesome. I'm looking forward to trying it out. Thanks for the awesome work to all the developers involved. -Andreas maven 1 somewhere</body>
  </mail>
  <mail>
    <header>Easymock in ibiblio/maven</header>
    <body>Hi, Easymock and Easymock CE 2.2 are now available in maven and maven 2 repository under ibiblio. The paths are "org.easymock" for maven 1 and org/easymock for maven 2. Enjoy, Henri</body>
  </mail>
  <mail>
    <header>Re: Easymock in ibiblio/maven</header>
    <body>Hey just tried out if it works, and Easymock is downloaded but I think there is a mistake in the dependency cause I get an error saying --snip-- [INFO] Failed to resolve artifact. Missing: ---------- 1) cglib.cglib-nodep:cglib-nodep:jar:2.1.3 -DartifactId=cglib-nodep \ --snip-- So I looked it up in the repository and found the following  so as you can see the Version has an underscore and not a dot after the 1 and before the 3 so I guess that might be the problem. Regards -Andreas</body>
  </mail>
  <mail>
    <header>Re: Easymock in ibiblio/maven</header>
    <body>I changed the Dependency in the easymockclassextension-2.2.pom to That worked in my local repo so that I got the cglib Regards -Andreas</body>
  </mail>
  <mail>
    <header>Re: Re: Easymock in ibiblio/maven</header>
    <body>True... get it right the first time would have been lucky. The pom is indeed wrong and should be like you said. I've just reopen the upload task now providing the right pom (which I've tested correctly this time). Sorry about that, Henri</body>
  </mail>
  <mail>
    <header>Re: Support for varargs in replay/verify in EasyMock class extension 2.2</header>
    <body>Hello Tim, it's now fixed in the CVS, and will be available in the next version of the class extension. HTH, Tammo Am 21.04.2006 um 16:29 schrieb Tim Downey:</body>
  </mail>
  <mail>
    <header>Re: Mock within a mock?</header>
    <body>One other thing that may be related. When I said lines 3 and 4 worked fine I lied. Or at least I think I lied. If I passed the real object to my testing class (line 10) it worked. 10)     ViewErrorList lViewErrorList = PIH.doAction(hsr, But if I passed the mock object as below 10)     ViewErrorList lViewErrorList = PIH.doAction(hsr, I get the following error message junit.framework.AssertionFailedError: moh.cdm.views.PatientView@60aa2ba9): expected: 0, actual: 1 expected: 1, actual: 0 At this point I'm at a loss. Im not sure which version of the above is correct. I've read so many different things over the past week that my head is spinning and I'm probably mixing up the approaches of different utilities. supposed On error. [mailto:easymock@yahoogroups.com] actual since to Here controlHelpDS.getMock in suggested in of that into the to it matter am r+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4 e&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer+monit mputer+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+softwa Free+computer+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=RishPPW2ja69fF9T9jDp4</body>
  </mail>
  <mail>
    <header>Re: java.lang.IllegalStateException with Matchers and EasyMock 2.0</header>
    <body>I don't :) - Tammo</body>
  </mail>
  <mail>
    <header>Re: Mock within a mock?</header>
    <body>The missing parenthesis is just a typo that occurred when I copied the code into here. There is no missing parenthesis in the real code. The error appears to occur with the mockHelpDS object. I tried to just mock it and nothing else replacing line 5 with And still line 5 failed with a NPE. And when I stepped through the code in debug mode it actually stepped into the real selectPageHelp when line 5 was executed. I then thought to mock the objects INSIDE the selectPageHelp and that got me a little further but I got stopped again because the method of one of the objects I was trying to mock was protected. This is getting way too complicated. All I was hoping to do was test pre-existing servlets with the database objects they use mocked out. Now it is begining to look like I will have to create interfaces of the database objects and mock them. And create test versions of the servlets in order to use the mocked interfaces. I'm begining to think I was not using EasyMock in the manner it was intended for. --- In easymock@yahoogroups.com, "Henri Tremblay" that (CDMHelpConstants.PATIENT_INSERT, phase. So selectPageHelp is something NPE is mocked When error. [mailto:easymock@yahoogroups.com] On actual null since my Here suggested to managed another with do and enters of into aOutputParameters and the to it matter am of</body>
  </mail>
  <mail>
    <header>Re: Mock within a mock?</header>
    <body>Nope, its not final. Its public and static. --- In easymock@yahoogroups.com, "Henri Tremblay" code. just selectPageHelp that method of test out. was and or call fine. didnt see have with a called call to finding been in problems trying to here in validating retrieval line that HelpDataService mock indicate break what I Terms</body>
  </mail>
  <mail>
    <header>Re: using generics for mocked interfaces?</header>
    <body>Indeed, take this factory method: I'd love to be able to do this: If anyone knows a work around, I'd love to hear it as well.  For now, it ends up being a cast somewhere in the statement and sometimes a nice warning from the compiler. nitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer\ +monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=zb3sFxhi-tmca0EDuSrdbg =Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer+monitoring+software\ &amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=I7EBHfo5x5ryPp_cfIwsbg monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+comput\ er+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=oV1vUZqKIG_WNHYmy3y9mA er+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+com\ puter+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=RishPPW2ja69fF9T9jDp4g</body>
  </mail>
  <mail>
    <header>Can EasyMock simulate modification of a method parameter?</header>
    <body>I use EasyMock quite a bit and am comfortable with setting expectations on mocks in most cases, e.g. specifying what method calls are expected with what arguments, and setting up the desired return values or throwables. However I'm stumped as to how to tell a mock to modify a parameter it has been passed. Here's an example of what I mean. I want to mock the FooValidator interface, which looks like this: It's easy to test the case where validation passes, with a JUnit test like this (this is standard EasyMock 2.0 stuff): However I don't know how to simulate the case where validation fails, which with a real FooValidator would mean setting a flag on the Foo object to which it was passed a reference. I'd like to be able to do something like this: Does anyone know if this is possible? Please don't suggest changing the FooValidator interface, because it's outside my control (in fact it's based on Spring's "Validator" interface). TIA, Andrew</body>
  </mail>
  <mail>
    <header>Re: Re: Mock within a mock?</header>
    <body>You need to mock the prepareCall method on your java.sql.Connection mock object. I.e. record the behavior of the your Connection object (the mock) by calling: mockConn.prepareCall(...) controlConn.setReturnValue(...) controlConn.replay() etc. before actually using the object. /rasmus -- /rasmus</body>
  </mail>
  <mail>
    <header>Re: Mock within a mock?</header>
    <body>I started down that route but then I got to the dataServcesBase.executeStatement line in the code which meant I had to mock that object as well. Not a big deal until I looked under the covers and saw all the different things it did and all the other objects I would then have to mock as well. As that point it just seemed ridiculous. for supposed is else? [mailto:easymock@yahoogroups.com] On call error. see [mailto:easymock@yahoogroups.com] have actual since called to Here controlHelpDS.getMock in suggested to in validating retrieval of that into the indicate to break it matter I am Terms r+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4 e&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer+monit mputer+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+softwa Free+computer+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=RishPPW2ja69fF9T9jDp4 of</body>
  </mail>
  <mail>
    <header>Re: Mock within a mock?</header>
    <body>Crapola. Thats what I was afraid of. --- In easymock@yahoogroups.com, "Henri Tremblay" methods don't refactoring method or improve I can do. copied real tried to (CDMHelpConstants.PATIENT_INSERT, through the and was mocked interfaces versions of it parenthesis recording make is the mockOutParms class is (CDMProperties.PATIENT_VIEW, (CDMProperties.HELP_VIEW,new method null don't code. think i the (obviously incorrectly. controlConn.getMock have with user For the (CDMProperties.HELP_VIEW,new object loaded No Yahoo!</body>
  </mail>
  <mail>
    <header>Assertion exceptions being eaten?</header>
    <body>Hi folks, I'm new to the group, and I hope I'm not covering something that has been beat to death already.  I did a search and didn't find anything that appeared to be the same. I'm using EasyMock 2.0 with Sun JDK 5.0 and JUnit 4.0.  I have a pretty simple test case in which one of the parameters of my expected method call is not the same as what is expected.  That's one issue, obviously, but the bigger problem is that the Assertion exception that is thrown by EasyMock appears to be eaten up by the JUnit framework in TestCase.class.  So, my test runs and shows an error, but does not present me with any stack trace or error information. Did I miss something in how to set up the test properly, perhaps?  It seemed really straightforward. Thanks, Dave</body>
  </mail>
  <mail>
    <header>Re: Assertion exceptions being eaten?</header>
    <body>Hard to tell without seeing your Java code, but I often find that if I temporarily disable verification of my EasyMocks, JUnit is a lot better at reporting any exceptions that happened along the way. HTH, Andrew</body>
  </mail>
  <mail>
    <header>Re: Assertion exceptions being eaten?</header>
    <body>Andrew, Thanks for the input, but I'm puzzled by two things. 1) I don't see from the docs/javadoc how to "disable" verification - only that createMock() returns a mock object with "order checking" is disabled by default. 2) If you disable verification, doesn't that prevent the mock object from performing its job? Please pardon my ignorance, I'm only just learning this tool, so there are probably a lot of details that I haven't covered yet. Thanks again for the response, Dave</body>
  </mail>
  <mail>
    <header>Re: Assertion exceptions being eaten?</header>
    <body>Am 07.03.2006 um 02:22 schrieb David C. Hicks: That's interesting. I have not seen stack traces being cut by JUnit 4. I've attached a test case and its stack trace below. The stack trace actually shows too much, it should begin at the third or fourth line. Can you tell me what's missing, or provide an example where the trace is incomplete due to JUnit 4? Tammo Freese gives the following stack trace (Mac OS X 10.4.5): java.lang.AssertionError: at org.easymock.internal.MockInvocationHandler.invoke (MockInvocationHandler.java:29) at org.easymock.internal.ObjectMethodsFilter.invoke (ObjectMethodsFilter.java:45) at atest.$Proxy4.aMethod(Unknown Source) at atest.ATest.justatest(ATest.java:24) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at org.junit.internal.runners.TestMethodRunner.executeMethodBody (TestMethodRunner.java:99) at org.junit.internal.runners.TestMethodRunner.runUnprotected (TestMethodRunner.java:81) at org.junit.internal.runners.BeforeAndAfterRunner.runProtected (BeforeAndAfterRunner.java:34) at org.junit.internal.runners.TestMethodRunner.runMethod (TestMethodRunner.java:75) at org.junit.internal.runners.TestMethodRunner.run (TestMethodRunner.java:45) at org.junit.internal.runners.TestClassMethodsRunner.invokeTestMethod (TestClassMethodsRunner.java:71) at org.junit.internal.runners.TestClassMethodsRunner.run (TestClassMethodsRunner.java:35) at org.junit.internal.runners.TestClassRunner$1.runUnprotected (TestClassRunner.java:42) at org.junit.internal.runners.BeforeAndAfterRunner.runProtected (BeforeAndAfterRunner.java:34) at org.junit.internal.runners.TestClassRunner.run (TestClassRunner.java:52) at junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:32) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests (RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run (RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main (RemoteTestRunner.java:196)</body>
  </mail>
  <mail>
    <header>Re: Assertion exceptions being eaten?</header>
    <body>Hello Andrew, can you give an example where disabling verification gives a better exception report? Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: Assertion exceptions being eaten?</header>
    <body>The test case I currently have is a bit complicated. It may take some time, but I'll try to whip up one that is cut down that demonstrates the same issue. Basically, I get the report from JUnit that an error occurred, but no stack trace or error messages at all. It's really strange. Thanks!</body>
  </mail>
  <mail>
    <header>Re: Assertion exceptions being eaten?</header>
    <body>Let me see if I can whip up something simple ... give me a day or so... Cheers, Andrew</body>
  </mail>
  <mail>
    <header>Re: Assertion exceptions being eaten?</header>
    <body>1) Usually I call EasyMock.verify(myMock) on each of my mocks in my TestCases' tearDown() methods. So to disable verification, I just comment those lines out temporarily. Sorry for not making this clearer. 2) Yes, that's why you only do it temporarily, to let the true exception bubble up to where you can see it. I hope to post a demo you can try for yourself. After working out why your test case is failing (e.g. maybe you have a bug in your test code), you should re-enable verification of all your mocks to make 100% sure everything went as expected. HTH, Andrew</body>
  </mail>
  <mail>
    <header>Re: Assertion exceptions being eaten?</header>
    <body>Ok, I see what you're saying.  I new about verify() - it just didn't sound the same originally. Thanks for the clarification. nitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer\ +monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=zb3sFxhi-tmca0EDuSrdbg =Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer+monitoring+software\ &amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=I7EBHfo5x5ryPp_cfIwsbg monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+comput\ er+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=oV1vUZqKIG_WNHYmy3y9mA er+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+com\ puter+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=RishPPW2ja69fF9T9jDp4g</body>
  </mail>
  <mail>
    <header>Re: Assertion exceptions being eaten?</header>
    <body>Hi Tammo, After much trial and error, I nailed down the exact circumstances. Consider this JUnit test (typing this from memory, so please excuse any dumb compilation errors): In this case, JUnit works fine; it shows you the RuntimeException message. But if you move the verify() call to inside JUnit's tearDown() method, you only get "Expectation failure on verify, expected run(), actual 0" (or whatever the real wording is). The point is that the verification failure message (which happens because run() was never called) obscures the real exception. To get it back, you you have to temporarily disable verification. In case you're wondering why I don't just move my verify() calls to inside my test methods, the reason is that I have a superclass from which my test cases extend, and in its tearDown() method, all the mocks that each subclass reports as being in use are verified. This saves me having to verify each mock at the end of each test method, which is a big time saver and ensures I don't leave that step out accidentally. So is this an EasyMock bug or just a limitation? Andrew</body>
  </mail>
  <mail>
    <header>Re: Can EasyMock simulate modification of a method parameter?</header>
    <body>Hi Neil, Thanks for the sensible suggestion, but the Foo is instantiated by the superclass of the code I'm trying to test, and that superclass is inside a third-party library (Spring), so I have no way of injecting a mock one.</body>
  </mail>
  <mail>
    <header>Re: Can EasyMock simulate modification of a method parameter?</header>
    <body>Andrew, assuming you're testing some other class, it seems like ought to be mocking both Foo and FooValidator, and maybe checking the order of calls across them. For instance, if your class-under-test was supposed to check if Foo had an error, then ask the validator to validate it, and then check if it has an error, and then do something, you could do i like this: expects(validator.validate(foo));  // You don't actually need the enclosing expects(..) here. If you could explain more about what you're testing, that might help. Andrew,  I think I'd just implement FooValidator to do what you want. You can always do it with an anonymous inner class: Foo foo = ... assert(foo.isValidated()) inside one. and calls return parameter it mock the test correctly fails, Foo to do changing fact</body>
  </mail>
  <mail>
    <header>Re: Assertion exceptions being eaten?</header>
    <body>Hello Andrew, moving verify(mock) in the tearDown may be the problem here. See  and  - Tammo Am 10.03.2006 um 11:29 schrieb Andrew Swan: [...]</body>
  </mail>
  <mail>
    <header>[ANN] EasyMock 2.1 is available</header>
    <body>Hello all, I have just uploaded EasyMock 2.1 (only on SourceForge, not yet on the EasyMock site). Changes: - Arguments passed to the mock object are now - The bug reported in - If unused matchers were specified, EasyMock now fails earlier than before. - Tammo Freese</body>
  </mail>
  <mail>
    <header>RE: AssertionFailedError appears but doesn't cause the test to fail</header>
    <body>Hi Neil and Henry, Thanks very much for your help. Neil was correct that the exception was being raised within another thread and so never reached the thread executing the test. And thanks Henry for reminding me to let JUnit handle all unexpected exceptions. The modified test is now behaving as expected and the test code is simpler too. Cheers, Tom -----Original Message----- From: easymock@yahoogroups.com [mailto:easymock@yahoogroups.com] On Behalf Of Neil Greenwood Sent: 28 January 2006 05:39 To: easymock@yahoogroups.com Subject: Re: [easymock] AssertionFailedError appears but doesn't cause the test to fail Tom, This is a threading issue rather than a problem with Easymock or JUnit. Throwables thrown on the other thread will bubble up the stack trace of that thread. The default behaviour is to output them to the console and kill the thread (which sounds like what you're seeing). The test doesn't fail because the Throwable never reaches the thread running the test. I haven't tested this, but rather than try This should execute the separate thread's code on the test's thread (Did that make sense?!). Then the test will see the AssertionFailedError. This is still a valid test, since it executes all of your code but skips the platform threading support. It might not work if your code depends on multithreading; the solution to that is going to be more involved, and I can't think of it at the moment... HTH, Neil.</body>
  </mail>
  <mail>
    <header>Re: Implementing a method stub?</header>
    <body>I'm bumping this because right now I'm using both EasyMock and jmock together to accomplish what I want, and it's messy.  I'd like to use just EasyMock. expect(mockCmi.getObjectIdRefFor(isA(Identified.class))).andStubInvocation(new</body>
  </mail>
  <mail>
    <header>Invocation class can not handle variable argument calls</header>
    <body>// got Index Outof Bound exception for next statement if the mocked method has variable arguments.</body>
  </mail>
  <mail>
    <header>Argument Matching with anyBoolean</header>
    <body>I'm not sure if I am using this correctly, but here is my situation... I have a inteface with: when I use the following everything works: when I try to use anyBoolean like the following: EasyMock.expect(accountDAO.findById(accountName,EasyMock.anyBoolean())).andRetur\ I get a stack trace: java.lang.IllegalStateException: 2 matchers expected, 1 recorded. at org.easymock.internal.ExpectedInvocation.createMissingMatchers(ExpectedInvocatio\ n.java:41) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:33) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:26) at org.easymock.internal.RecordState.invoke(RecordState.java:63) at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:24\ ) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:45) at $Proxy1.findById(Unknown Source) at org.orderDisorder.account.AccountDAOTest.testDAO(AccountDAOTest.java:20) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:196) Am I doing this all wrong? TIA Neil Hart</body>
  </mail>
  <mail>
    <header>Re: Argument Matching with anyBoolean</header>
    <body>Hello Henri, hello Neil, as far as I have looked into it, it is not a bug. [Henri] From the EasyMock 2 Documentation: "If you would like to use matchers in a call, So the test should look like - Tammo</body>
  </mail>
  <mail>
    <header>Re: Re: Implementing a method stub?</header>
    <body>OK, well, I guess I'll chalk it up as a permanent limitation of easymock. nitoring+software&amp;amp;w2=Software&amp;amp;w3=Free+computer+monitoring+software&amp;amp;c=3&amp;amp;s=87&amp;amp;.sig\ =BLOE7J96RLBnVsB5e7TctA =Software&amp;amp;w3=Free+computer+monitoring+software&amp;amp;c=3&amp;amp;s=87&amp;amp;.sig=HV0n2f2UunJvQZaXuHH\ fTg er+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Free+computer+monitoring+software&amp;amp;c=3&amp;amp;s=87\ &amp;amp;.sig=DJmqg_nwg_3F1rZAxNUPUQ</body>
  </mail>
  <mail>
    <header>Re: Argument Matching with anyBoolean</header>
    <body>Am 04.02.2006 um 01:47 schrieb Henri Tremblay: Short answer: I could not find a good way. Long answer: In some cases it is possible to guess the positions of variables, using the return values of the matcher methods. For example, for if we let contains() return the object given as parameter, it may work, since we would have However, there are a bunch of cases in which such a strategy fails. One example: notNull() always returns null, since we cannot simply instanciate a replacement object. So we get the calls and we cannot map the position of the matcher call to an argument position in the method. This really gets ugly when refactoring, as method reordering may break the mapping. As an example: If we let gt() returns its parameter, we may get the calls which allows us to map the matchers to the second and third argument. However, reordering the parameters would lead to Here we would get the calls and it would not be possible to map the matcher calls to the arguments. As refactoring-safety is a core feature of EasyMock, this is not acceptable. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Implementing a method stub?</header>
    <body>Hello Andy, this is not supported at the moment, and it won't be in the core of EasyMock, unless someone finds a refactoring-safe, elegant way to incorporate it. However, that does not mean there is no way to get it in as an extension. I contacted Henri to see whether he thinks it will be a good fit in the class extension. If so, I'll provide the hooks he needs in the internals of EasyMock. - Tammo Am 26.01.2006 um 17:31 schrieb depue99:</body>
  </mail>
  <mail>
    <header>Re: Implementing a method stub?</header>
    <body>Thanks for your response! I look forward to being able to move exclusively to EasyMock. :) nitoring+software&amp;amp;w2=Software&amp;amp;w3=Free+computer+monitoring+software&amp;amp;c=3&amp;amp;s=87&amp;amp;.sig\ =BLOE7J96RLBnVsB5e7TctA =Software&amp;amp;w3=Free+computer+monitoring+software&amp;amp;c=3&amp;amp;s=87&amp;amp;.sig=HV0n2f2UunJvQZaXuHH\ fTg er+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Free+computer+monitoring+software&amp;amp;c=3&amp;amp;s=87\ &amp;amp;.sig=DJmqg_nwg_3F1rZAxNUPUQ</body>
  </mail>
  <mail>
    <header>Re: Argument Matching with anyBoolean</header>
    <body>Am 07.02.2006 um 23:49 schrieb Henri Tremblay: You are right, nothing is known on that. Although it looks like the matchers get passed to the method arguments, it is not the case. Giving the argument positions in the API would break when reordering parameters, since the argument positions won't change when refactoring. - Tammo</body>
  </mail>
  <mail>
    <header>Method not called expectation failure message improvement request</header>
    <body>During Control.verify, when an expected was not called we get the message: Expectation failure on verify: This message would be much more helpful if at least the class was indicated, and even more helpful if the instance could be identified (even just the raw object ID so it can traced down in the debugger). I will admit that generally its obvious where the problem lies, but with the current problem I'm having -- finalize() is expected -- I have no idea what's going on. -barry</body>
  </mail>
  <mail>
    <header>Mocking more than 1 dependency</header>
    <body>I have a ClassUnderTest which has a method that depends on two collaborators...so.....should I create two mocks to test the method? where could I find some example in which this happens? It could be a design error? thxs!</body>
  </mail>
  <mail>
    <header>using generics for mocked interfaces?</header>
    <body>Hi, Is there a way to create a mock like the following without the need to add SuppressWarnings("unchecked)? I use eclipse 3.1.2</body>
  </mail>
  <mail>
    <header>java.lang.IllegalStateException with Matchers and EasyMock 2.0</header>
    <body>When I create a mock for an interface that I use in different unit tests, in different test classes, I get a stack trace like the one below depending on the order in which the test cases are run. It seems that the matcher from the previously run unit test is being picked up and compared against the new new call to expect and generating an error. If I run my unit tests seperately (not in a suite) then everything works fine. The problem only occurs when they are all run as part of a suite (i.e. in the same JVM instance). Beneath the stack trace I have included the test code that causes this. In this case it is a single test class with 2 different test methods that use the same mock. I also get this behavior when the test cases are in 2 different classes. java.lang.IllegalStateException: 3 matchers expected, 4 recorded. at org.easymock.internal.ExpectedInvocation.createMissingMatchers(ExpectedInvocatio\ n.java:41) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:33) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:26) at org.easymock.internal.RecordState.invoke(RecordState.java:63) at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:24\ ) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:45) at $Proxy0.takeIfExists(Unknown Source) at ngna.jini.TicketDispenserTest.testReset(TicketDispenserTest.java:54) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:90) /** * @author */ anyLong())) anyLong())) (Transaction)isNull(), anyLong())).andReturn(new</body>
  </mail>
  <mail>
    <header>Re: java.lang.IllegalStateException with Matchers and EasyMock 2.0</header>
    <body>Am 27.02.2006 um 17:24 schrieb Clark: There is one call too much in andReturn() here: Just use andReturn(null), andReturn(new Lease()) or something similar. That should fix the problem. :) Please use matchers in expected calls only. HTH, Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: using generics for mocked interfaces?</header>
    <body>As far as I know, it is not possible, as it is a limitation in the java generics. If anyone knows a workaround, please let me know. - Tamo Freese</body>
  </mail>
  <mail>
    <header>Mock within a mock?</header>
    <body>Hi, tools to create test cases for an application that has been in production awhile now. EasyMock was one of the tools suggested to me. I've been playing with it for about a week now and I have managed to get it to work in simple cases and in conjunction with another testing tool called httpUnit. However, I am having problems with a slightly more complicated case. It may be that I am trying to do something that cant be done. I thought I would post it here in the hope that someone can enlighten me. I am testing a simple servlet used for collecting, validating and inserting patient info to an Oracle database. If the user enters invalid data on the screen they get the usual errors. For specific error types a help message is displayed. It is the retrieval of the help message that I am trying to mock. Here is what the line looks like in the servlet. aOutputParameters.addParameter(CDMProperties.HELP_VIEW,new HelpView (HelpDataService.selectPageHelp The HelpDataService.selectPageHelp is the database object that retrieves the help message. The returned message is loaded into the HelpView bean which in turn is inserted into the aOutputParameters obect.  I have mocked the aOutputParameters, HelpDataService and aConn objects (and now that I think of it I probably need to mock the HelpView object as well). I am unsure exactly how I indicate to easymock the order of methods that will be fired. Do I break it down into several statements or just one, ie mockHelpDS.selectPageHelp(CDMHelpConstants.PATIENT_INSERT,mockConn, And when I call the servlet I am passing it the mock aOutputParameters and mock aConn objects. The problem always tends to be the Connection object. No matter what I do I get a null object error. So can anyone tell me what I am doing wrong.</body>
  </mail>
  <mail>
    <header>Re: Mock within a mock?</header>
    <body>Ok, after stepping through my code in debug mode I think i have found the problem but I dont understand it. It appears as if the actual selectPageHelp method is being called and it is failing with a null exception because the callable statement is null (obviously since my connection object is null). Why is the REAL method being called anyway? Doenst a mock object imply that I am MOCKING the call to selectPageHelp. Or have I set up my mock object incorrectly. Here is what I have. controlOutParms = MockClassControl.createControl controlConn     = MockClassControl.createControl controlHelpDS   = MockClassControl.createControl me. hope aConn aOutputParameters doing</body>
  </mail>
  <mail>
    <header>Re: Mock within a mock?</header>
    <body>Here is what I have so far 2) PatientView lPatientView = new PatientView 3) mockOutParms.addParameter(CDMProperties.PATIENT_VIEW, 5)       mockOutParms.addParameter(CDMProperties.HELP_VIEW,new and then I call the servlet which performs the actual method call mentioned below. 10)     ViewErrorList lViewErrorList = PIH.doAction(hsr, When I started I only had lines 1-4,9 and 10 and it worked fine. When I added the rest it started to fail on line 5 with that null error. I tried breaking down line 5 into chunks like below but it didnt make a difference. --- In easymock@yahoogroups.com, "Clark D. Richey, Jr." where you Behalf found controlOutParms.getMock testing a the specific the looks HelpView the (CDMHelpConstants.PATIENT_INSERT,mockConn, what Service</body>
  </mail>
  <mail>
    <header>Re: Mock within a mock?</header>
    <body>Nullpointer. When I step through the code in debug mode I notice that it takes me into the ACTUAL selectPageHelp method when I run line 5. THe nullpointer occurs when that method tries to set the parameters for the callable statement. The callable statement is created from my mock COnnection object. where aCon is the mockConn object being passed in. But why is this method being called anyway? I thought that easymock was only supposed to check IF the method of the mocked object was called with the appropriate parameters and return values. I didnt think it would actually run the method of the object being mocked. --- In easymock@yahoogroups.com, "Clark D. Richey, Jr." the error Behalf When On null my to managed another with do and enters aOutputParameters and of t=ms&amp;amp;k=Computer+monitoring+software&amp;amp;w1=Compute r+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4 =Free+ t=ms&amp;amp;k=Software&amp;amp;w1=Computer+monitoring+softwar e&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+software&amp;amp;w4=Free+computer+monit oring+ t=ms&amp;amp;k=Computer+and+internet+software&amp;amp;w1=Compu w4=Fre and t=ms&amp;amp;k=Free+computer+monitoring+software&amp;amp;w1=Co mputer+monitoring+software&amp;amp;w2=Software&amp;amp;w3=Computer+and+internet+softwa re&amp;amp;w4= Free+computer+monitoring+software&amp;amp;c=4&amp;amp;s=123&amp;amp;.sig=RishPPW2ja69fF9T9jDp4 Service</body>
  </mail>
  <mail>
    <header>Re: problem using easymock</header>
    <body>Hello Sachin, [...] please provide an example of the problem that I can run and debug here. To track down the problem, I need to understand what's going on. - Tammo</body>
  </mail>
  <mail>
    <header>Re: problem using easymock</header>
    <body>Hi, I'm trying to reproduce the problem in a testcase, but its difficult to do so independently. I'll send it across when I can. I'll try to explain the whole scenario for now. Context - When we start our application, a controller starts up and initializes all the services (This is the part which we want to execute only once for the tester class). Now the test cases are written for one of the services (which uses other services instantiated/started by the Controller). To achieve this thing we have created a testing framework like - class NewTestCase extends TestCase started by the controller, which is used by the test cases. extends now out tester class will be - /* Tester class */ Class MyTester extends NewTestCase services say S1,S2 etc instanceted by the NewTestCase.*/ Now when I run the testcase (keeping only one method in MyTester) then it works fine If I run the testcase(keeping both methods in MyTester), the first test method(newTest1) succeeds and the second(newTest2) fails. Here I'm using my own matcher where I print the value of expected and actual parameters. In the second(newTest2) method, the first method call in mock object i.e mock.write("Second Call".getBytes() ); calls the matcher properly and returns true, but just after the matcher call, it checks again for the other call of mock.write() method (which is actually not getting called). Debugcalls from the matcher class ERROR - Exception in test java.lang.AssertionError: write(java.nio.DirectByteBuffer[pos=238 lim=238 cap=256] (empty)): cap=238] (empty)): expected: 1, actual: 0 (+1) at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:29\ ) at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:45) at $Proxy5.write(Unknown Source) at com.geodesiconline.mims.io.MIMSIoSession.write(MIMSIoSession.java:128) As we use java 5, I tried this with both easymock1.1 and 2.0 RC . Second way ---------- I tried this by using junit.extensions.TestSetup class on Junit, but using it, we'll not get the references of all the services started by the controller in the tester class. So to overcome this we defined a class with the static references of all the services started by the controller, The controller will be started from the TestSetUp.setUp(), which sets all the static references of the services. But this also causes the same problem. Regards, Sachin * .oooO                                * * (   )   Oooo. Only those who will    * *  \ (    (   )    risk going too far, * *   \_)    ) /  Can possibly find out  * *         (_/      how far one can go! * happiness is journey and not destination __________________________________________________________ Enjoy this Diwali with Y! India Click here</body>
  </mail>
  <mail>
    <header>Improper behaviour while using mockobject</header>
    <body>Hi, I'm using easymock for all our testing. But i facing a problem which i'm unable to trace. So please help me in tracing the problem. I'm explaining the whole scenario below. Context - When we start our application, a controller starts up and initializes all the services (This is the part which we want to execute only once for the tester class). Now the test cases are written for one of the services (which uses other services instantiated/started by the Controller). To achieve this thing we have created a testing framework like - class NewTestCase extends TestCase // references of all the instances of the services started by the controller, which is used by the test cases. protected void setUp() throws Exception //the code to start controller goes here. protected void tearDown() throws Exception // the code to stop controller goes here public void test() throws Exception //all the testcases in the tester class which extends //NewTestCase and starts with "newTest" will be //executed one by one, using the reflection api. now out tester class will be - /* Tester class */ Class MyTester extends NewTestCase /* the testcases will use the references of the services say S1,S2 etc instanceted by the NewTestCase.*/ public void newTest1() throws Exception MockControl ctrl = //actual method called here. public void newTest2() throws Exception MockControl ctrl = //actual method called here. Now when I run the testcase (keeping only one method in MyTester) then it works fine If I run the testcase(keeping both methods in MyTester), the first test method(newTest1) succeeds and the second(newTest2) fails. Here I'm using my own matcher where I print the value of expected and actual parameters. In the second(newTest2) method, the first method call in mock object i.e mock.write("Second Call".getBytes() ); calls the matcher properly and returns true, but just after the matcher call, it checks again for the other call of mock.write() method (which is actually not getting called). Debugcalls from the matcher class DEBUG - expect : Second Call DEBUG - actual : Second Call ERROR - Exception in test java.lang.AssertionError: Unexpected method call write(java.nio.DirectByteBuffer[pos=238 lim=238 cap=256] (empty)): write(java.nio.HeapByteBuffer[pos=238 lim=238 cap=238] (empty)): expected: 1, actual: 0 (+1) at org.easymock.internal.MockInvocationHandler.invoke (MockInvocationHandler.java:29\ ) at org.easymock.internal.ObjectMethodsFilter.invoke (ObjectMethodsFilter.java:45) at $Proxy5.write(Unknown Source) at com.geodesiconline.mims.io.MIMSIoSession.write(MIMSIoSession.java:128) As we use java 5, I tried this with both easymock1.1 and 2.0 RC . Second way ---------- I tried this by using junit.extensions.TestSetup class on Junit, but using it, we'll not get the references of all the services started by the controller in the tester class. So to overcome this we defined a class with the static references of all the services started by the controller, The controller will be started from the TestSetUp.setUp(), which sets all the static references of the services. But this also causes the same problem. Thanks and Regards, Sachin</body>
  </mail>
  <mail>
    <header>Re: Improper behaviour while using mockobject</header>
    <body>Hi Sachin, unfortunately, I cannot reproduce the problem, so I cannot track it down. From what you sent, I tried to build a self-contained test scenario that reproduces the error. I attached my code below. It runs fine, showing no unexpected behavior. Please modify this code so that I will be able to reproduce the problem here. For example, your test code uses byte arrays, but the error message hints that you use NIO byte buffers. - Tammo @Override @Override Am 15.12.2005 um 07:50 schrieb Sachin Khandelwal:</body>
  </mail>
  <mail>
    <header>Problem with EasyMockClassExtension 2.0_Pre-Release</header>
    <body>I am having a problem with EMCE, that I reported before and thought was fixed.  I encountered in in 1.2, and changed to 2.0PR to see if it is fixed there, but it is not. I am trying to create two mocks for the same class (Yes, I am still using the 1.2 syntax): Later, I try to set behavior on both mocks: When the test runs, I get: java.lang.IllegalStateException: method call needed on the mock before setting return value It looks like the method call for one of the mocks is getting recorded on the other one. Henri, could you take a look at this?  I can convert to the new syntax, if that would help, but I am really tight on time at the moment and would really prefer not to do so. Thank you. -- Jim McMaster mailto:jim.mcmaster@...</body>
  </mail>
  <mail>
    <header>Re: Problem with EasyMockClassExtension 2.0_Pre-Release</header>
    <body>Am 20.12.2005 um 18:48 schrieb Jim McMaster: Hello Jim, thanks for your problem report.I tried to reproduce the problem you described, but with no success. I attached a test case below. Please let me know whether this test case succeeds in your configuration, and if so, please modify it so that it demonstrates the problem you described. Thanks for your help, Tammo Freese MockControl&amp;lt;Category&amp;gt; categoryControl1 = MockClassControl MockControl&amp;lt;Category&amp;gt; categoryControl2 = MockClassControl</body>
  </mail>
  <mail>
    <header>Re: More meaningful exception messages</header>
    <body>Hello Selim, [...] The message is "missing behavior definition", as you can either specify a return value, or an exception that should be thrown. [...] :) - Tammo</body>
  </mail>
  <mail>
    <header>Mock a final class using EasyMock 2.0 Class Extension</header>
    <body>Hello! The EasyMock 2.0 Class Extension is very impressive. One line of code to create a mock object of a class. However, will it be possible to mock final classes? If you need help I would like to invest some time in order to implement that feature. Regards,</body>
  </mail>
  <mail>
    <header>Re: Mock a final class using EasyMock 2.0 Class Extension</header>
    <body>Am 24.01.2006 um 11:08 schrieb mburger313: As far as I know, it won't, since you cannot subclass final classes. Maybe you should introduce a layer of abstraction that isolates your code from the final class that you are trying to mock. Can you give us any details why it is necessary to mock a final class? - Tammo</body>
  </mail>
  <mail>
    <header>Re: Mock a final class using EasyMock 2.0 Class Extension</header>
    <body>You can remove the "final" modifier in byte code. I would like to mock third-party classes that are final. At the moment I am using Javassist to remove the "final" modifier of all classes in a given JAR. It would be very cool if I could create mock objects of such classes on-the-fly - without having to modify JARs. Regards, Martin</body>
  </mail>
  <mail>
    <header>Re: Re: Mock a final class using EasyMock 2.0 Class Extension</header>
    <body>Am 25.01.2006 um 09:16 schrieb mburger313: OK, then it is a non-final class, and EasyMock Class Extension can generate a mock for it. :) Is it really necessary to replace the library directly? I would prefer to hide the concrete third-party implementation behind an interface, and use mock objects for this interface. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Mock a final class using EasyMock 2.0 Class Extension</header>
    <body>Exactly! :-) Sorry, introducing interfaces is no option. I really need to mock "final" classes. Regards Martin</body>
  </mail>
  <mail>
    <header>Bug report: Cause of test failure not being properly reported</header>
    <body>SUMMARY: EasyMock is prematurely exiting my method under test when it encounters an unexpected method call, and then doesn't report the error properly. DESCRIPTION:  I'm testing an object that has to iterate through two different collections, so I've mocked the collections and also their iterators. The mock control is expecting the first collection's iterator() method to be called once. However, it was being called twice. On the second invokation the mock control threw an exception and ended the run. However, when verify() is called on the controls, it doesn't report that the method was called too many times. Instead, the other controls report that they weren't called as often as expected. I spent an hour trying to figure out the problem before realizing what it was because EasyMock was hiding the real problem from me. Can EasyMock be retooled to *not* thrown an exception on excessive method calls and instead just report over-calling in the same way that it reports under-calling of methods? -- Darryl L. Pierce, Sr. Software Engineer/Consultant ResolvIT Resources @ Redhat/GIS, (919) 754-4383 "Bury me next to my wife. Nothing too fancy, though." - Ulysses S. Grant</body>
  </mail>
  <mail>
    <header>RE: Bug report: Cause of test failure not being properly reported</header>
    <body>The fix for this is to not call verify in tearDown, but at the end of the test method.</body>
  </mail>
  <mail>
    <header>Implementing a method stub?</header>
    <body>Is it possible with EasyMock to actually "implement" a method?  For example, I have this in one of my test cases: It would be so much easier if I could just do something like this: expect(mockCmi.getObjectIdRefFor(isA(Identified.class))).andStubInvocation(new Note that I invented a mythical "Invocation" interface for the sake of this example. The question is, why don't I just create a custom implementation of this interface?  The thing EasyMock brings to the table in this situation is that 1) I don't have to implement all the interface's methods, and 2) If any unexpected method call is made, then EasyMock will catch that and fail the test case (which is what I want). Ideas, comments?</body>
  </mail>
  <mail>
    <header>Re: Bug report: Cause of test failure not being properly reported</header>
    <body>Hello Darryl, This is one of the core features of Mock Objects - to fail as early as possible, to make it easy to track down from where the unexpected method call came. Can you explain why this is not a proper report of the error? This is correct. The error has already been reported by the first exception, and since the call wasn't expected, it hasn't been recorded as an actual call. I don't get why the verify() is reached in your scenario. Normally, the test case should not continue after the first exception is thrown. This may be achieved by extending EasyMock, but I think it is not a good idea, since it takes away an important feature of EasyMock, and Mock Objects in general. HTH, - Tammo Freese</body>
  </mail>
  <mail>
    <header>RE: Bug report: Cause of test failure not being properly reported</header>
    <body>He probably is calling verify() in tearDown(). Exceptions thrown in tearDown() hide those thrown in the test method. Regards, Ilja</body>
  </mail>
  <mail>
    <header>Re: Bug report: Cause of test failure not being properly reported</header>
    <body>But, it didn't. The output didn't report that a method had been called too many times: it only complained that the other mocks weren't called enough times. Say I have two mocks, mock1 and mock2. Mock1 is expected to have its foo() method called once, mock2 is expecting it's bar() method to be called twice. If the code calls mock1.foo() a second time, mock1 throws an exception. The output displayed says that mock2.bar() was called only once but was expecting two calls, and says nothing about mock1.foo() getting called too many times. And that has masked the actual problem. By not reporting that an unexpected call was made, the program now has to start digging and stepping through the unit tests to find the actual problem. That defeats one point of using mock objects. -- Darryl L. Pierce, Sr. Software Engineer/Consultant ResolvIT Resources @ Redhat/GIS, (919) 754-4383 "Bury me next to my wife. Nothing too fancy, though." - Ulysses S. Grant</body>
  </mail>
  <mail>
    <header>Re: Bug report: Cause of test failure not being properly reported</header>
    <body>That is correct, all verify() methods are invoked in the tearDown() method and not in each test case since that sort of code duplication would be unacceptable. -- Darryl L. Pierce, Sr. Software Engineer/Consultant ResolvIT Resources @ Redhat/GIS, (919) 754-4383 "Bury me next to my wife. Nothing too fancy, though." - Ulysses S. Grant</body>
  </mail>
  <mail>
    <header>Re: Bug report: Cause of test failure not being properly reported</header>
    <body>Okay. Thanks for the pointer. -- Darryl L. Pierce, Sr. Software Engineer/Consultant ResolvIT Resources @ Redhat/GIS, (919) 754-4383 "Bury me next to my wife. Nothing too fancy, though." - Ulysses S. Grant</body>
  </mail>
  <mail>
    <header>AssertionFailedError appears but doesn't cause the test to fail</header>
    <body>Hi, I'm using Easymock 1.2. I've written a unit test that mocks a single interface. I record some method invocations using the mock object, then run the piece of code that I'm testing, then call the verify method of the mock control. At the moment there is a deliberate mistake in my code, so the test should fail. However, when I run the test, an AssertionFailedError is displayed to the console, but the test passes instead of failing. Does anyone know what would cause this to happen? The code that I am testing runs in its own thread. Here is the test code: --- --- Many thanks for any suggestions, Tom</body>
  </mail>
  <mail>
    <header>RE: Bug report: Cause of test failure not being properly reported</header>
    <body>Alternatively, you can override the runBare method: Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Reg. adding a cookie to the HttpRequest mock object</header>
    <body>Hi, Can somebody post a sample code of creating a mock HttpServletRequest object and adding cookies to it. Rgds, Muru __________________________________________________ Do You Yahoo!? Tired of spam?  Yahoo! Mail has the best spam protection around</body>
  </mail>
  <mail>
    <header>Re: Possible Bug in EasyMock2.0 Pre-Release</header>
    <body>Am 27.09.2005 um 07:42 schrieb tm jee: I hope to release a release candidate the next weekend, or the weekend after that. Depending on bug reports with this release candidate, I target the 2.0 release between end of october and middle of november. - Tammo</body>
  </mail>
  <mail>
    <header>Compile error using EasyMockClassExtension 1.2 with Eclipse 3.1</header>
    <body>I have been using EasyMockClassExtension 1.2 with Eclipse 3.1 for awhile. All of a sudden, after applying an Eclipse update, the eclipse compiler is giving me an error : The method createControl(Class) is ambiguous for the type MockClassControl Looking at the code, I cannot see why this is happening.  Anyone else know what to do about it? -- Jim McMaster mailto:jim.mcmaster@...</body>
  </mail>
  <mail>
    <header>Re: Compile error using EasyMockClassExtension 1.2 with Eclipse 3.1</header>
    <body>Could it be that there is a conflict with MockClassControl from easymock and easymock-classextension? Maybe FQCN is needed? --------------------------------- I have been using EasyMockClassExtension 1.2 with Eclipse 3.1 for awhile. All of a sudden, after applying an Eclipse update, the eclipse compiler is giving me an error : The method createControl(Class) is ambiguous for the type MockClassControl Looking at the code, I cannot see why this is happening.  Anyone else know what to do about it? -- Jim McMaster mailto:jim.mcmaster@... --------------------------------- easymock-unsubscribe@yahoogroups.com Terms of Service. --------------------------------- ___________________________________________________________ How much free photo storage do you get? Store your holiday snaps for FREE with Yahoo! Photos</body>
  </mail>
  <mail>
    <header>Re: Compile error using EasyMockClassExtension 1.2 with Eclipse 3.1</header>
    <body>Am 10.10.2005 um 03:23 schrieb Jim McMaster: This sounds quite strange, since 1.2 is out there for around three months without any bug reports so far (unless this one is the first ;)). I have looked at Henri's class extension implementation (Class Extension 1.2 for Java 5), and there are four createControl() methods, but all of them have different parameter count:  src/org/easymock/classextension/MockClassControl.java? only_with_tag=EasyMockClassExtension1_2&amp;amp;view=markup - Is it Eclipse-specific, or do you get the same problem using the javac compiler? - Can you boil down a small example showing the problem? compiler - Which versions of EasyMock and EasyMock Class Extension are you using? - Tammo</body>
  </mail>
  <mail>
    <header>Re: Compile error using EasyMockClassExtension 1.2 with Eclipse 3.1</header>
    <body>Am 10.10.2005 um 21:15 schrieb Jim McMaster: Maybe we need two versions of the class extension here, one for Java 1.3, and one for Java 1.5. However, since you are on Java 1.5, I would suggest a switch to EasyMock 2 Pre-Release. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Compile error using EasyMockClassExtension 1.2 with Eclipse 3.1</header>
    <body>Am 11.10.2005 um 00:24 schrieb Jim McMaster: This is why EasyMock 2 is called a pre-release, and not a release candidate: It is lacking documentation. :/ There *is* a compatibility layer, so you don't have to change your tests! The only differences that you may notice are - AssertionErrors are thrown instead of AssertionFailedError (or TestNG). - some error messages have changed. And as you seem to use the class extension: There is a Pre-Release of the Class Extension as well. - Tammo</body>
  </mail>
  <mail>
    <header>can't refactor some mock code. getting weird exception</header>
    <body>I have the following code which I use it 2 consecutive junit tests. On the second line in the second test i get the error '1 matcher expected, 2 recorded'. I can run the code just fine if it's only in one test. However, if i pull the code out into a createMessages() method i get the same exception. Any ideas? (I'm using the latest version of the classextension because of another class i'm mocking). expect(messages.format((String)anyObject(), expect(messages.format((String)anyObject(), anyObject())).andReturn(" -- Dan Adams Software Engineer Interactive Factory</body>
  </mail>
  <mail>
    <header>Re: can't refactor some mock code. getting weird exception</header>
    <body>Hello Dan, have you called replay(messages) in both test methods? If so, would you please provide the full source of the failing test case? This would help me to find the error. - Tammo</body>
  </mail>
  <mail>
    <header>Re: can't refactor some mock code. getting weird exception</header>
    <body>Yeah I always call replay. I get this error in many places. I stepped into the easymock code and something weird is happening. If I do createMock(someclass.class) in one test case and add matchers and then in another test testcase do createMock(someclass.class) it creates a mock but it has the same matcher (exactly the same object) as the previous matcher. So then when the second test case adds it's matchers it ends up having 2 matchers instead of one. Anyway, here's some code. This fails with '1 matchers expected, 2 recorded': I was able to get around it in another test case by reusing the exact same object in multiple tests but this workaround will not work in most cases. Thanks. -- Dan Adams Software Engineer Interactive Factory</body>
  </mail>
  <mail>
    <header>Mocking pass by reference calls</header>
    <body>I am trying to mock calls to an external class that uses pass by reference to change the values of two of the parameters (to indicate success and the actual result). Ideally I'd like to be able to set an expectation that it would be called with a set of parameters and after the call some of those parameters have different values. Is there a way to change parameter values on mock calls? Thanks</body>
  </mail>
  <mail>
    <header>Private method throws an exception</header>
    <body>Hey, My method under test calls a private method in the same class which throws an exception during the unit test.  Is there anything EasyMock can do to help with this situation? Any other suggestions? Thanks.</body>
  </mail>
  <mail>
    <header>Simulate a timeout</header>
    <body>Hi, I am pretty new to easymock and was hoping I might be able to get some help from this group. Basically, I have some functionality that calls a webservice. This has to functionality is handling a timeout on the webservice ie. if it does not respond in x amount of time an exception is thrown. However I can not see any way to simulate this behaviour in easymock. Specifically, I need to be able to tell a method to take x amount of time to execute. Any ideas or suggestions would be greatly appreciated. Regards, Johnny</body>
  </mail>
  <mail>
    <header>Re: Simulate a timeout</header>
    <body>Henri, That looks like it will do the trick. I will give it a try and let you know. Many thanks for the help. Regards, Johnny --- In easymock@yahoogroups.com, Henri Tremblay which is make the will tested class hack to make more than sounds really method. get some This has it easymock. amount of</body>
  </mail>
  <mail>
    <header>Creating a mock generic Collection or Iterator</header>
    <body>The only way I've been able to create a mock of a generic collection is this: // function call // Wrapper function: where control is an IMocksControl @SuppressWarnings("unchecked") public &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; createMockCollection( Class&amp;lt;T&amp;gt; clazz ) Is there a way to do this without the @SuppressWarnings? I also have a createMockIterator( Class ) function that does the same thing for generic Iterators.</body>
  </mail>
  <mail>
    <header>RE: Digest Number 213</header>
    <body>Hi, Would it be possible to have an additional 1.x version (supporting the JDK1.4) with the new callback and stub behavior added to 2.0? This is very useful, and would be great to have available for those of us in corporate land that won't be moving to the JDK 1.5 for quite some time. Thanks,</body>
  </mail>
  <mail>
    <header>Re: Creating a mock generic Collection or Iterator</header>
    <body>As far as I know, it is a limitation of Java 5.0, and I have not found a better workaround for it. - Tammo</body>
  </mail>
  <mail>
    <header>problem using easymock</header>
    <body>Hi, Im facing a problem using the easymock. We have created a testcase environment where the setup() and teardown() is called only once for every tester class (set of test cases in a class ). Given below is the overview of my testcase environment NewTestCase and a example tester class MyTester using it. class NewTestCase extends TestCase //the code to start server goes here. // the code to stop server goes here //all the testcases in the tester class which extends be //executed one by one, using the reflection api. /* Tester class */ Class MyTester extends NewTestCase //actual method called here. //actual method called here. When I run the testcases separately it runs successfully. But when I run both the test cases in one go the first test case get succeeded and the second one get failed. Here Im using my own matcher where I print the value of expected and actual parameters. For first test case the value of both the argument is proper, but for second it gives - The message is expected  : java.nio.HeapByteBuffer[pos=238 lim=238 cap=238] (empty) actual      : java.nio.DirectByteBuffer[pos=238 lim=238 cap=256] (empty) here the empty indicates that the byte[] sending as argument to write method is empty, which is not case as Im sending hello11.getBytes(). Also it gives the error  write(java.nio.DirectByteBuffer[pos=238 lim=238 cap=256] (empty)): as we are using java 5, I tried this with both easymock1.1 and 2.0RC . When I tried it without using our framework , it runs fine. Thus mu guss is there is some problem with the static members of the easymock. Which might be keeping the same object between two testcases. please help me in this regard. It has become a blocker for me. As bcoz of this problem I have to restart the server for every testcase which I dont want as it takes too much time. Regards, Sachin I. Khandelwal * .oooO                                * * (   )   Oooo. Only those who will    * *  \ (    (   )    risk going too far, * *   \_)    ) /  Can possibly find out  * *         (_/      how far one can go! * happiness is journey and not destination __________________________________________________________ Enjoy this Diwali with Y! India Click here</body>
  </mail>
  <mail>
    <header>Re: problem using easymock</header>
    <body>Hi, Would you provide boiled-down running example with a TestCase that shows the problem? It is very hard to guess what is going wrong without running code. In EasyMock 1.1, there is no state attached to static fields. And it occurs with EasyMock 1.1 as well? I wonder why you use an own implementation to start the server once. In JUnit, there is the class TestSetup which allows to do this quite easily. See  - Tammo</body>
  </mail>
  <mail>
    <header>problems mocking class</header>
    <body>Okay, I've used the classextension with no problems before but I'm having some problems now. HtmlUnit has a class called HtmlAnchor. I tried to create a mock object with it and then call ancher.getHrefAttribute(). when I do: it actually calls the real method causing ultimately a null pointer exception. am i doing something wrong? i thought it should only call the proxy and never call the real method? -- Dan Adams Software Engineer Interactive Factory</body>
  </mail>
  <mail>
    <header>Re: problem using easymock</header>
    <body>Hi, Thanks Tammo I tried the way u suggested using TestSetUp. but the problem remains the same . i'm telling u the way i tried. basically i want to start the server once, but also need some of the references which are instanciated by the server in the testcases.so for this i made all those instance variables as static and started the server (also instanciate all the instance variables ) from the setup() of TestSetUp class. one thing is missing there in link that how to run the AllTestsOneTimeSetup class. so for that is extend AllTestsOneTimeSetup by TestCase. but then also the only first testcase runs successfully and the second testcase fails for the first call on the mockobject. for more detail, the on the call of mock object the matcher called successfully , but just after that i get the AssertionError saying Unexpected call of the same method. but when i try to run the test case separaterly, they runs fine. plz help as i'm unable to track the problem. regards sachin   * .oooO                                * * (   )   Oooo. Only those who will    * *  \ (    (   )    risk going too far, * *   \_)    ) /  Can possibly find out  * *         (_/      how far one can go! * happiness is journey and not destination __________________________________________________________ Enjoy this Diwali with Y! India Click here</body>
  </mail>
  <mail>
    <header>Re: MockClassControl</header>
    <body>and it programming). and used to bytecode, it prevent No problem, thank you for your answer.</body>
  </mail>
  <mail>
    <header>Incompatible return type</header>
    <body>Hello, I am having slight difficulty debugging a supposedly simple problem.  I am encountering the error "incompatible return type" when trying to "expect" a method call that is going to return a primitive boolean value. The method call is something as follows: ... There are plenty of ways to write this, but I found this form the easiest to understand. I broke this down to: ... expect(objA.equals(objB).andReturn(true); &amp;lt;-- error occurs here ... I am guessing that I might need to know a bit more about the internals of easy mock to debug this problem, or maybe not.  Some help? thanks in advance</body>
  </mail>
  <mail>
    <header>Re: Incompatible return type</header>
    <body>Am 15.09.2005 um 20:04 schrieb jonxboy01: IN EasyMock, you cannot set expectations or change the behavior of java.lang.Object's methods equals(), hashCode() and toString(). So mock1.equals(mock2) if and only if mock1 == mock2. The error message you get can be explained - remember call someObj.getB() - set return value objA to last method call. - remembers *no* method call, since equals() is not recorded - set return value true to last method call. I hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>testing DAO using JDBC</header>
    <body>Hello, I was interested in testing a DAO that uses JDBC and was interested in people's experiences. I will be mocking up a Connection object, ResultSet object and a CallableStatement object etc. Would this be rather easy to do? Is there some code that other members of this group has written on this subject? thanks in advance.</body>
  </mail>
  <mail>
    <header>Re: Incompatible return type</header>
    <body>Thank you Tammo, I appreciate the help.  It helped a lot. -Jon __________________________________ Yahoo! Mail - PC Magazine Editors' Choice 2005</body>
  </mail>
  <mail>
    <header>Re: Odd Behavior with matchers</header>
    <body>Hello, I resolved my own problem. I apologize.  I had accidently used an argument matcher while in the record state.  Thanks anyways. org.easymock.internal.ExpectedInvocation.createMissingMatchers(ExpectedInvocatio\ n.java:41) org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:33) org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:26) org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:24\ ) org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:45)</body>
  </mail>
  <mail>
    <header>Re: testing DAO using JDBC</header>
    <body>A long time ago I wrote an article about testing jdbc clients by mocking the api, I'm now less convinced than I used to be. I think it's worth writing a smallish number of mock-based tests to develop a clean module that handles all that stuff for your application. You can use the mocks to check things like the sequence of events and making sure that failures are handled properly. What you get out of this is a set of helper classes that implement an approach to persistence appropriate /for your application/. Then write a set of tests that exercise against a small clean installation of a real database, to make sure the queries work properly too. S.</body>
  </mail>
  <mail>
    <header>Wierd Behavior in the ordering of the tests</header>
    <body>Hello everyone, I had a quick issue I was hoping to pose to the group. I am relatively new with EasyMock so please be gentle :)  My problem is that I have created 3 easymock tests, but depending on how the tests are ran, I get the error: java.lang.IllegalStateException: 0 matchers expected, 1 recorded. at org.easymock.internal.ExpectedInvocation.createMissingMatchers(ExpectedInvocatio\ n.java:41) at org.easymock.internal.ExpectedInvocation.&amp;lt;init&amp;gt;(ExpectedInvocation.java:33) .. .. .. If I run the tests in a different order, I get the same error but the line number of the error changes.  Once and a while, I will get lucky and I will find an ordering that allows all the tests to run successful. I thought it was an issue with the state of the mock objects, so in the tearDown(), I make sure to reset() all the mock objects back to the original state. Feel free to leave any suggestions. Thank you.</body>
  </mail>
  <mail>
    <header>EasyMock.isA(..) and isNull() issue</header>
    <body>Hi all - I've been using EasyMock lately and I really like it.  But now I've run into a problem with EasyMock.isA(Class).  It is inconvenient to use properly, because it is specified with a type parameter that will not allow for implicit type argument inference when the method is used in an expression. The method looks like For the compiler to allow you to use an invocation of isA(Class) as the argument to another method, its return type must match that of the called method's parameter.  So if you wanted to say where printLabel looks like you would need your invocation of isA(Class) to have a return type of String.  The problem is that the compiler doesn't have any way to infer the type argument for T from this invocation.  Although you are passing in String.class, there is no reference to the type parameter T in the method parameter list of isA(Class), so there's no way for the compiler to infer that the type String is the type argument for the type parameter T.  Instead, the compiler decides that for this invocation of isA(Class), the return type is Object.  (Presumably it will always do that for any invocation of isA(Class)). That doesn't match the type of printLabel's parameter, and your program doesn't compile. There are two ways to make this work, then.  One way is rarely used and cumbersome.  The other requires a very small EasyMock code change. For the rarely used and cumbersome method, call isA(Class) and explicitly specify the type argument like this: This will compile and work.  Note however that the JLS does not allow you to specify a method type argument without explicitly specifying either the type to which the method belongs, or the instance receiving the invocation.  It's a quirk of the language spec.  So you can't say ... ... It just won't compile. However, as I said, a small code change to EasyMock will make this easy.  Declare the method like this: Note the reference to the type parameter T in the type of method's parameter.  Now when you pass in String.class, the compiler will determine its type - Class&amp;lt;String&amp;gt; - and infer that the type argument for the type parameter T is the type String.  And that will match the type of printLabel's parameter, and the compiler will compile your program. A similar issue exists for isNull(). This method has a similar type parameter usage to isA(Class), but no method parameter.  To fix this, you could add a method parameter, so that it looks like: And I haven't tried it, but notNull() should have the same problem and solution as isNull().  And so should anyObject(), but given how that method might be used, it might not be a problem. BTW, I know this stuff can be confusing; I've just had the "good fortune" to be messing around a lot with Java generics and how java.lang.Class is now java.lang.Class&amp;lt;?&amp;gt; and what that means, so I know how it works.  A few months ago, I would have found this message I've just typed to be as baffling as anyone who reads this might find it. Larry</body>
  </mail>
  <mail>
    <header>Enforcing the order constraint</header>
    <body>Hello, I was wondering where I would be able to find more information about the checkOrder method call? to be more specific, how the mock object would function if I were to intermittingly turn on checkOrder(..) and turn off checkOrder(..). For example: How would the ordering constraint be enforced in this simple code listed below: ---- ----- so I am assuming that method call C must come before D, but how do the method calls B and E factor into the equation? thank you for your help.</body>
  </mail>
  <mail>
    <header>Re: Enforcing the order constraint</header>
    <body>Am 24.09.2005 um 00:38 schrieb jonxboy01: I assumed it is in the docs. It isn't at least not for single mocks. I will fix that in the Release Candidate. Yes, you are right. Order checking there is unordered, however, as you only expect *one* call, order checking makes no difference. Perhaps this example clarifies how it works: 1) Expect calls to B and F, in any order, 2) after that, expect calls to C and D, in that order, 3) after that, Expect calls to E and G, in any order. Hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>Re: Wierd Behavior in the ordering of the tests</header>
    <body>Am 23.09.2005 um 19:35 schrieb jonxboy01: This is due to a matcher that gets recorded, although it is not suitable for the next method call. It may be an error in your test, it may be a bug in EasyMock 2. Could you provide a simple test case that leads to this exception? You should not need to do this. reset() is a relict of EasyMock 1. Maybe it should be deprecated. - Tammo</body>
  </mail>
  <mail>
    <header>Re: EasyMock.isA(..) and isNull() issue</header>
    <body>Am 23.09.2005 um 22:09 schrieb ledelste: That's nice to hear :) [...] I had intended to do it this way, but missed the &amp;lt;T&amp;gt; for the parameter. It will be fixed in the next release. For the moment, adding an explicit cast will solve the problem. [...] You are right. When writing EasyMock 2, I hoped that would lead Java to use the right type for T. Unfortunately, it does not work that way. Although the tests have 100% code coverage, they do not point to this issue. :( I came up with three solutions here: ( example, ) 1) public static &amp;lt;T&amp;gt; T isNull(Class&amp;lt;T&amp;gt; clazz) The mock code would look like: 2) public static &amp;lt;T&amp;gt; T isNull() (no change) The mock code would look like: 3) public static Object isNull() The mock code would look like: With the current release, 2) works. In the next release, I will switch to 3), because a) the calling mock code is shorter than in 1) b) and compatible with 2) c) it eliminates the useless generic type paremeter in 2). Thanks for pointing me to the flaws of the generic stuff, Tammo</body>
  </mail>
  <mail>
    <header>Possible Bug in EasyMock2.0 Pre-Release</header>
    <body>Hi, I think there might be a bug in EasyMock 2.0 PreRelease version. For example the following is not working as expected. public static void main(String[] args) throws MyInterface myi = (MyInterface) Throws me an exception saying that it expects MyEventOne to twice... which is not true as the second time a MyEventTwo should be expected. This is due to when MockBehavior decides to add a behavior (UnorderedBehavior) to its list, it checks its last UnorderedBehavior in its list and ask if it is ok to add another ExpectedInvocation to it. UnorderedBehavior determines if it should do so (one of the conditions) by asking for equality between its last ExpectedInvocation and the 'to-be-added' ExpectedInvocation. ExpectedInvocation does equality comparison by (one of the condition) by comaparing the equality of its arguments. This is where the problem comes in. In the above case, EasyMock.isA(...) is used which always return a null, hence for the above to call before replay, both are assumed to be equal because their argument are equal (null == null is true) but they are actually expecting MyEventOne and MyEventTwo (siblings of parent MyEvent). The quick (not good) solution, i figured out is to have Invocation's equalArguments(Object[] arguments) method does another check if both arguments are null, then both invocation should not be considered equal hence treated separately. // === start changes === // === end changes === Another solution that I could figure out is to have create a IArgumentMatcher that explicitly returns an instance of the event (MyEventOne or MyEventTwo) such that Invocation's equality comparison will regard them separate instance. EasyMock.reportMatcher(new Attached is a zip of the above code I tried out. If the attachement doesn't get through.... I could be reacheable at tm_jee(at)yahoo.co.uk, and could always send the copy of zip file to your email account. I'd like to know what others thing about this. Is it a bug? or is it a feature? regards tmjee ___________________________________________________________ To help you stay safe and secure online, we've developed the all new Yahoo! Security Centre.</body>
  </mail>
  <mail>
    <header>Re: Enforcing the order constraint</header>
    <body>Thank you, I appreciate the help.  I was curious how the constraint would be enforced though if they were different mock objects rather than one mock object such as: so I am guessing that at the top, mock1.B() and mock2.B() could be called in any order, then, mock1.F() must come before mock1.D(), but mock2.C() could be called in any order, and in the last section, mock2.E() and mock1.G() could be called in any order, is this correct? thanks again for the help</body>
  </mail>
  <mail>
    <header>Re: Re: Enforcing the order constraint</header>
    <body>Am 26.09.2005 um 20:10 schrieb jonxboy01: [...] Checking order of calls between mocks works only if they are constructed using the same IMocksControl. Please read "Checking Method Call Order Between Mocks" in the EasyMock documentation. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Possible Bug in EasyMock2.0 Pre-Release</header>
    <body>Am 25.09.2005 um 05:41 schrieb tm jee: [...] It's a bug. The class ExpectedInvocation should take the ArgumentMatcher list into account in equals(). However, it does not do this yet. Thanks for pointing it out. I'll fix it in the next release. - Tammo</body>
  </mail>
  <mail>
    <header>Re: EasyMock.isA(..) and isNull() issue</header>
    <body>[...] Hmm - are you saying that there's no real point to isNull(), other than it being syntactic sugar?  Just curious.  And BTW I'm all for syntactic sugar. Anyway, glad I could help.  Keep up the good work! -Larry</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock.isA(..) and isNull() issue</header>
    <body>Am 27.09.2005 um 00:12 schrieb ledelste: There is a point to isNull(). As an example, let's take the method IN EasyMock 2, there are two types of specifying expectations: 1) By giving arguments directly: 2) By using argument matchers: In the second case, *all* arguments have to be given as constraints. Otherwise it would not be possible to match constraints to arguments. So isNull() is needed for the cases where you would like to specify a constraint for one argument, and another should be null at the same time. For the same reason, there is a constraint eq(). :) I will. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Possible Bug in EasyMock2.0 Pre-Release</header>
    <body>Thanks for the reply Tammo. I'll patch my current local copy. Is there a road map for EasyMock as to roughtly when will the next release be available?  :o) Cheers! regards, tmjee --------------------------------- Am 25.09.2005 um 05:41 schrieb tm jee: second [...] a It's a bug. The class ExpectedInvocation should take the ArgumentMatcher list into account in equals(). However, it does not do this yet. Thanks for pointing it out. I'll fix it in the next release. - Tammo Computer monitoring software Computer and internet software monitoring software --------------------------------- easymock-unsubscribe@yahoogroups.com Terms of Service. --------------------------------- ___________________________________________________________ How much free photo storage do you get? Store your holiday snaps for FREE with Yahoo! Photos</body>
  </mail>
  <mail>
    <header>Verifying a value object</header>
    <body>Hi all, I am fairly new to testing and am trying to implement mocks in our unit tests. Easy Mocks looks very promising as I don't have to extend any classes like one of the other more popular products. I do have one issue that is preventing me from implementing easy mocks. I am using struts and am using Struts TestCase as my testing framework. My Actions call business delegates that perform the real work, and I am not interested in testing those, as they have their own test (or atleast will soon enough). My issue is that I send data to the action via a post and my action builds a value object/DTO which is then passed to the business delegate. I want to verify the values of that Value Object. My current methodology is to create my own simple custom mock/stub object that stores the value object which I then retrieve and assert it holds the correct values. I Don't see a way of retrieving an object I passed to the EasyMock mock object. I can compare if I have a reference, but my problem is that the action created a value object to store the values I passed in. Did I over look something? Should I be using a different methodology in order to use mocks? Thanks for any advice. Tom</body>
  </mail>
  <mail>
    <header>Re: Verifying a value object</header>
    <body>Hello Tom, [...] If I understand correctly, you have a data transfer object for which you would like to check some values. Storing the objects and checking values later is not a good idea, as the test will not fail when the error (the wrong call) occurs, but later. The mock object should be configured so that it checks the DTO given as an argument directly. If you are using EasyMock 2 Preview Release, you may introduce your own Argument Matcher for your value objects. It is described in the chapter "Defining own Argument Matchers" in the EasyMock 2 documentation. Using your own argument matcher, you may write expectations like Hope that helps, Tammo</body>
  </mail>
  <mail>
    <header>Re: Verifying a value object</header>
    <body>Hi Tammo, Thanks for the information. I'll look at that documentation. I take it that I can interagate the Dto (storeCustomerData) to get to the individual properties (hasFirstName). This would indeed work. This approach may not make for the best testing, but as the data is comming from a web request and the delgegate requires a dto, I have little choice. Some data can get quite large when informatin is edited or what have you. The point of being able to create a course grain object and populate it with data to pass on to a business delegate seems like a good approach, except maybe for testing via mocks ; ) Anyways, Thanks for the info. Tom</body>
  </mail>
  <mail>
    <header>Re: Re: Verifying a value object</header>
    <body>Hi Tom, I believe you could mock a concrete class. (If your value object is concrete) and expect it to return the expected values. Easy mock have a class extension version (just an additional jar file) to be added to the classpath and also cglib as it uses it for dynamic class generation. So in this case, you don't need to write IArgumentMatcher extensions, but specify the method from the Value Object of yours and what behaviour it is expected to exhibit. Not sure it this is what you want. Hope this helps. regards tmjee --------------------------------- Hi Tammo, Thanks for the information. I'll look at that documentation. I take it that I can interagate the Dto (storeCustomerData) to get to the individual properties (hasFirstName). This would indeed work. This approach may not make for the best testing, but as the data is comming from a web request and the delgegate requires a dto, I have little choice. Some data can get quite large when informatin is edited or what have you. The point of being able to create a course grain object and populate it with data to pass on to a business delegate seems like a good approach, except maybe for testing via mocks ; ) Anyways, Thanks for the info. Tom object for which objects and checking not fail checks the introduce your described in the EasyMock 2 expectations like --------------------------------- easymock-unsubscribe@yahoogroups.com Terms of Service. --------------------------------- ___________________________________________________________ To help you stay safe and secure online, we've developed the all new Yahoo! Security Centre.</body>
  </mail>
  <mail>
    <header>Catching exceptions in other threads</header>
    <body>I'm sorry if this is a FAQ, but as far as I could see it wasn't answered before. I currently have a unit test that tests a class that spawns a background thread to do some processing. The processing itself uses some mock objects. The problem I have is that if a call to a mock object in this thread fails, an exception is thrown and I see a nice stack trace on the console, but the test still "succeeds". Is it somehow possible to make the test fail in such a scenario? I was hoping that the call to "verify()" would have remembered that something went wrong, but it doesn't. I have made sure that the exception in the other thread occurs well before verify() is called. Greetings, Marcel</body>
  </mail>
  <mail>
    <header>Re: Catching exceptions in other threads</header>
    <body>Hello Marcel, Let's say the exception would be thrown by a real implementation, and *not* by EasyMock. How would your application know that the calculation went wrong? EasyMock matches expected and actual calls. Whenever an unexpected call occurs, an exception is thrown, and the call does not get recorded. verify() just checks whether all expected calls were recorded. Usually this is not a problem, since your test should fail at the first exception. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Catching exceptions in other threads</header>
    <body>In this case, the code is deployed in a headless embedded device and the exception gets logged. So what I'm actually doing is mocking the log service (since with a normal flow, nothing will get logged, so each log message is essentially an error). Yes, but since it does not "pick up" exceptions thrown in other threads, this is a problem for me. For each test I use an IMocksControl which I use to create all mocks and I was hoping I could somehow query this control object after the test to check if anything went wrong. Greetings, Marcel</body>
  </mail>
  <mail>
    <header>EasyMock 1.2 RC2 available</header>
    <body>Hello all, release candidates of EasyMock 1.2 RC2 available on SourceForge:  News since 1.1: - EasyMock is released in two versions: Changes in both versions: - order of arguments for ArgumentsMatcher is like in EasyMock 1.0 now - stack traces are now only cut if the exception is thrown from EasyMock - convenience methods expectAndDefaultReturn() and expectAndDefaultThrow() code - hashCode() implementation is changed for better performance - added Clover coverage reports New features in the Java 1.5 version: - support for VarArgs - type safety: expectAndReturn() and expectAndDefaultReturn() for Objects - MockControl uses generics now, the mock object needs not to be casted anymore - Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: EasyMock and HiveMind</header>
    <body>Hello Howard, I am a big fan of Tapestry and hope it continues to grow in industry usage. There is a MockControlCombiner extension class that should provide the functionality described in two of your paragraphs. It provides the ability to invoke replay(), verify(), or reset() on several controls with one method call and the ability to verify the exact order of operations across several different mocks. The MockControlCombiner (mockcontrolcombiner-0.5.zip) is available for download in the Files section. The source is available for your use and if the functionality does not quite meet your requirements I would be glad to develop it further. Jake Belew</body>
  </mail>
  <mail>
    <header>MockControlCombiner</header>
    <body>Hi Jake, Please could you provide a link to the MockControlCombiner download page. I can't seem to find it on the EasyMock or SourceForge sites, and Google isn't coming up with the goods either. Thanks a lot, Tom -----Original Message----- From: easymock@yahoogroups.com [mailto:easymock@yahoogroups.com] On Behalf Of tms54x Sent: 01 August 2005 04:38 To: easymock@yahoogroups.com Subject: [easymock] Re: EasyMock and HiveMind Hello Howard, I am a big fan of Tapestry and hope it continues to grow in industry usage. There is a MockControlCombiner extension class that should provide the functionality described in two of your paragraphs. It provides the ability to invoke replay(), verify(), or reset() on several controls with one method call and the ability to verify the exact order of operations across several different mocks. The MockControlCombiner (mockcontrolcombiner-0.5.zip) is available for download in the Files section. The source is available for your use and if the functionality does not quite meet your requirements I would be glad to develop it further. Jake Belew href=" /D=groups/S=1705007181:TM/Y=YAHOO/EXP=1122874696/A=2894361/R=0/SIG=13jmebhbo /* &amp;amp;cmpgn=GRP&amp;amp;RTP= not own computers. At Network for Good, help bridge the Digital Yahoo! Groups Links</body>
  </mail>
  <mail>
    <header>RE: MockControlCombiner</header>
    <body>Hi Tom, You could also try the MockControlFactory frorm the XConf toolbox. You can have a look at its API on  ctory.html and download the toolbox from  Tom. Send instant messages to your online friends</body>
  </mail>
  <mail>
    <header>RE: RE: MockControlCombiner</header>
    <body>Henri and Tom, Thanks for sending the links. Tom -----Original Message----- From: easymock@yahoogroups.com [mailto:easymock@yahoogroups.com] On Behalf Of Tom Czarniecki Sent: 07 August 2005 01:48 To: easymock@yahoogroups.com Subject: [easymock] RE: MockControlCombiner Hi Tom, You could also try the MockControlFactory frorm the XConf toolbox. You can have a look at its API on  olFactory.html and download the toolbox from  02 Tom. Send instant messages to your online friends href=" /D=groups/S=1705007181:TM/Y=YAHOO/EXP=1123382887/A=2894321/R=0/SIG=11dvsfulr /* "&amp;gt;Fair play? Video games influencing politics. Click and talk Yahoo! Groups Links</body>
  </mail>
  <mail>
    <header>[ANN] EasyMock 1.2 available</header>
    <body>Hello all, as there were no bug reports for EasyMock 1.2 RC2, I released EasyMock 1.2 yesterday. Tammo Freese</body>
  </mail>
  <mail>
    <header>ParameterMatcher</header>
    <body>I have to verify the mutiple Parameters when invoking the method on a mock object.  However, the api available is control.setMatcher will allow us to set only 1 parameter. How do I set several Parameter Matcher. Example - I have created a mock object of BankTransactionManager which has a methods creditBalance(Account acc, Transaction tran). Here I need to verify the Account object and Trasaction Object. Could you please advice. thanks</body>
  </mail>
  <mail>
    <header>Re: ParameterMatcher</header>
    <body>The API of EasyMock 1.2 allows to set an ArgumentsMatcher. This one - gets an array of objects that contains all arguments - is used for every call to the method. It does not explicitely allow to check single arguments, since this would break when refactoring. In EasyMock 2.0 Preview, it is possible - to match single arguments - per method call. With some work, you may do something like The documentation of EasyMock 2 Preview explains how to achieve this in the section "Defining own Argument Matchers". - Tammo Freese</body>
  </mail>
  <mail>
    <header>setReturnValue for primitive int</header>
    <body>hi, I am new to easyMock .. am using easyMock_1.2_Java_1.3 I am a bit confused with the way setReturnValue works. There are several methods avaialble to setReturnType. My mock object returns primitive type int. I did not find a method to setReturnType(int value). So I tried to set the ReturnType to object Integer. I expected this not to work as the object interface returns a primitive int. BUT to my suprise, it worked. Could someone please explain. thanks</body>
  </mail>
  <mail>
    <header>Réf. : setReturnValue for primitive int</header>
    <body>There is a setReturnValue(long). So if you pass an int, it's this method that will be called. Which is perfect for what you need. Passing an Integer also works because internally we keep an Integer so easymock doesn't make any difference between Integer and int internally. It's simpler and sufficient. Regards, Henri Extranet kumargopalani@...@yahoogroups.com - 17/08/2005 16:25 Veuillez répondre à easymock@yahoogroups.com Envoyé par :      easymock@yahoogroups.com Pour : easymock cc : Objet :     [easymock] setReturnValue for primitive int hi, I am new to easyMock .. am using easyMock_1.2_Java_1.3 I am a bit confused with the way setReturnValue works. There are several methods avaialble to setReturnType. My mock object returns primitive type int. I did not find a method to setReturnType(int value). So I tried to set the ReturnType to object Integer. I expected this not to work as the object interface returns a primitive int. BUT to my suprise, it worked. Could someone please explain. thanks Yahoo! Groups Links This message and any attachments (the "message") is intended solely for the addressees and is confidential. If you receive this message in error, please delete it and immediately notify the sender. Any use not in accord with its purpose, any dissemination or disclosure, either whole or partial, is prohibited except formal approval. The internet can not guarantee the integrity of this message. BNP PARIBAS (and its subsidiaries) shall (will) not therefore be liable for the message if modified. Ce message et toutes les pieces jointes (ci-apres le "message") sont etablis a l'intention exclusive de ses destinataires et sont confidentiels. Si vous recevez ce message par erreur, merci de le detruire et d'en avertir immediatement l'expediteur. Toute utilisation de ce message non conforme a sa destination, toute diffusion ou toute publication, totale ou partielle, est interdite, sauf autorisation expresse. L'internet ne permettant pas d'assurer l'integrite de ce message, BNP PARIBAS (et ses filiales) decline(nt) toute responsabilite au titre de ce message, dans l'hypothese ou il aurait ete modifie.</body>
  </mail>
  <mail>
    <header>Re: EasyMock and HiveMind</header>
    <body>Hello ! &amp;gt; I have a base TestCase class, HiveMindTestCase, that provides support &amp;gt; along these lines. Here's a variation on the theme I can share, that I have been using for a while, centered on extending a JUnit TestCase in order to provide easier EasyMock integration :  Case.html It's quite basic however it indeed saves a lot of typing when writing tests. The test case is :  kTestCaseTest.html And here are a few examples of real use :  tworkAcceptorTest.html putTest.html ity/LoginHandlerTest.html Anyway it seems there is quite a need for such an extension ! I just cannot imagine going back to the regular TestCase anymore... Regards, MAT.</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock and HiveMind</header>
    <body>Hello Mathieu, please take a look at EasyMock 2 Preview. It contains an IMocksControl that can be used - to specify behavior for multiple mock objects, - to record/replay/reset all mocks created by it, and - to check call order between mocks. - Tammo Freese Am 18.08.2005 um 00:12 schrieb Mathieu Champlon:</body>
  </mail>
  <mail>
    <header>Problems instantiating FileOutputStream and BufferedWriter</header>
    <body>Hi all, I'm using easymock 1.2 for Java 1.3 and easymockclassextension 1.2, on Sun's JDK 1.3.1_12, Windows 2000. When I try to create a mock control for either java.io.FileOutputStream, I get a RuntimeException with a message saying "failed to instantiate &amp;lt;classname&amp;gt;: null". I think this is happening because of a NullPointerException in the constructor that is called, because it's passing in an empty string (to FileOutputStream(String)). Is there an easy way around this? I tried using the deprecated createControl methods that used to allow you to choose a constructor to call, but they no longer work. Regards, Neil Greenwood.</body>
  </mail>
  <mail>
    <header>Problems with expect() in PreRelease 2.0</header>
    <body>Hi All. I'm just getting started with Mock Objects and this version 2.0 of EasyMock seems the simplest and most flexible of those I've seen so far so I thought I'd do a small project with it to try it out! I use NetBeans 4.1 with JDK 5.0r4 pm is the Mock Specifically, while works perfectly, fails on compile with ...: 'void' type not allowed here 1 error Now, from what I can see this is actually because pm.add() returns void (assumption that is not clear in the docs). If so, it's a shame to loose the expect() syntax which I am using for throwing exceptions. All views &amp;amp; observations are welcome.</body>
  </mail>
  <mail>
    <header>Re: Problems with expect() in PreRelease 2.0</header>
    <body>Hello, Am 25.08.2005 um 21:51 schrieb tecopen: it is nice to hear that. :) Unfortunately, we cannot change this in EasyMock, since it is in the Java Specification. A void method does not return any method, so does not compile. expect(...) does only work for methods that return a value. The EasyMock way of writing the expectation is I hope that answers your question. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Problems with expect() in PreRelease 2.0</header>
    <body>Thanks for the confirmation!  I've been battling with it for most of today and actually noticed the pattern while writing the email. Thanks again.</body>
  </mail>
  <mail>
    <header>java.lang.IllegalStateException: Unknown callback class</header>
    <body>Hi, I try to mock a method on a class, but get a cglib IllegalStateException (I use sdk1.4.2_02, easymock 1.2 (+ ext) and cglib-nodep-2.1_2). It's thrown on the createControl method (the "myMethod" method is not final, nor does it use private methods, it calls a default access method of an interface) : MockControl control = MockClassControl.createControl(clazz, new // * bang * java.lang.IllegalStateException: Unknown callback class org.easymock.classextension.internal.ClassProxyFactory$1 at net.sf.cglib.proxy.CallbackUtils.getGenerator( CallbackUtils.java:102) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:314) at net.sf.cglib.proxy.Enhancer.createClass(Enhancer.java:278) at org.easymock.classextension.internal.ClassProxyFac tory.createProxy(ClassProxyFactory.java:98) at org.easymock.MockControl.&amp;lt;init&amp;gt;(MockControl.java:133) at org.easymock.classextension.MockClassControl.&amp;lt;init at org.easymock.classextension.MockClassControl.creat eControl(MockClassControl.java:52) at be.ringring.momagw.np.NumberPortabilityHandlerTest s.testGetProviderList(NumberPortabilityHandlerTests.java:135) Probably something I overlooked, but I spent a lot of time searching, anybody can help ? ps just to note, I had to test the method like this (it's not bad design ;-)) Thx, Q</body>
  </mail>
  <mail>
    <header>Re: java.lang.IllegalStateException: Unknown callback class</header>
    <body>your exist in classpath and Aha ! You were right :-) I was fooled by IntelliJ, project I wrote the test in was dependant on another project which used cglib 2.0. Thx for your quick answer, Q</body>
  </mail>
  <mail>
    <header>Réf. : Comparing parameters using easymock</header>
    <body>You should use MockControl.ARRAY_MATCHER instead of the default matcher which, as you said, only do equals. Cheers, Henri Extranet kamalbabutom79@...@yahoogroups.com - 31/08/2005 12:20 Veuillez répondre à easymock@yahoogroups.com Envoyé par :      easymock@yahoogroups.com Pour : easymock cc : Objet :     [easymock] Comparing parameters using easymock Hi,     I'am using easymock to mock my Session Bean.One of the method in the bean has an array of Long objects as it's input parameter.I record this method as mockBean.methodname(arr).When the test case is executed, it is giving me an assertion failue which says the actual input object received is different from what was declared. I think this is because the easymock framework check the equals() method of the array and not it contents.Is there some way we can override this behaviour of the easymock? Are there any settings which says easymock not to check for the input variable. Thanks, Kamal Start your day with Yahoo! - make it your home page YAHOO! GROUPS LINKS This message and any attachments (the "message") is intended solely for the addressees and is confidential. If you receive this message in error, please delete it and immediately notify the sender. Any use not in accord with its purpose, any dissemination or disclosure, either whole or partial, is prohibited except formal approval. The internet can not guarantee the integrity of this message. BNP PARIBAS (and its subsidiaries) shall (will) not therefore be liable for the message if modified. Ce message et toutes les pieces jointes (ci-apres le "message") sont etablis a l'intention exclusive de ses destinataires et sont confidentiels. Si vous recevez ce message par erreur, merci de le detruire et d'en avertir immediatement l'expediteur. Toute utilisation de ce message non conforme a sa destination, toute diffusion ou toute publication, totale ou partielle, est interdite, sauf autorisation expresse. L'internet ne permettant pas d'assurer l'integrite de ce message, BNP PARIBAS (et ses filiales) decline(nt) toute responsabilite au titre de ce message, dans l'hypothese ou il aurait ete modifie.</body>
  </mail>
  <mail>
    <header>Re: Comparing parameters using easymock</header>
    <body>Hello, In EasyMock 2,you may specify matchers - per call - *inside* in the call. To match Arrays, it is simply In EasyMock 1.2, you may set the Matcher - for all calls to one method by invoking control.setMatcher(...) after the first call to the method. - for the whole mock by invoking  control.setDefaultMatcher(...). - Tammo</body>
  </mail>
  <mail>
    <header>MockClassControl</header>
    <body>Hi, is there a way to test expectations on a protected method of a superclass while calling a specific method of the subclass ? The mocking of the protected method is not the problem, it's that I don't immediately see how I can call the method I mocked. Because it's protected obviously I cannot call it from the subclass. If I provide the superclass for class mocking so I can call it, I have the wrong mock instance, so I seem to be stuck here. Again, all this to avoid test code duplication (I wonder if I'm not overdoing that sometimes). An exampe to clarify : So the question is if easymock testing is possible for the method doSomething() of class A, so I can set expectations on it in the test of class B (instead of retesting A's doSomething). KR, Q</body>
  </mail>
  <mail>
    <header>Re: MockClassControl</header>
    <body>Just to make sure, with "because it's protected obviously I cannot call it from the subclass" I meant the subclass instance ;-)</body>
  </mail>
  <mail>
    <header>EasyMock and TestNG</header>
    <body>Hi Tammo! I have prepared one distro (for JDK1.4) which doesn't rely on AssertionFailureError (is using as i explained before the AssertionError). Pls drop me a line as where I can send you the distro (aprox. 210k). tia, --:alex |.::the_mindstorm::.| ps: i am doing now exactly the same for the JDK 1.5. Pls let me know what do you think.</body>
  </mail>
  <mail>
    <header>Re: Problem using ClassMockControl</header>
    <body>Which version of easymockclassextension are you using? And which version of cglib? Which JDK? I'm guessing here that you are using an old easymockclassextension (not the 1.2 one) or a JDK under 1.4. And finally that there is code in BaseObject default constructor. Cheers, Henri net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:220) org.easymock.classextension.MockClassControl$ClassProxyFactory.createProxy(MockC\ lassControl.java:81) org.easymock.classextension.MockClassControl.createControl(MockClassControl.java\ :216)</body>
  </mail>
  <mail>
    <header>Re: a matcher has already been set...</header>
    <body>call MockControl.setMatcher before calling setReturnValue - that should do it. /rasmus org.epoline.portal.applications.sample.SendActionTest.testDoAction(SendActionTes\ t.java:112) -- /rasmus</body>
  </mail>
  <mail>
    <header>Re: Problem using ClassMockControl</header>
    <body>thkns , As you suggested the problem is caused by the constructor of the class BaseObject : there was a call to a method when i had commented the code, everything runs well. I want to know if there is no other solution to the problem of the call of method inside the constructor? Regards,</body>
  </mail>
  <mail>
    <header>Problem setting return value for mocks of same class</header>
    <body>-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 I am trying to create two unique mocks of a single class.  I have: MockControl transition1Control = MockControl transition2Control = Later, I have: java.lang.IllegalStateException: method call on the mock needed before setting return value Inspecting the controls shows the "getName" method call was recorded in transition2Control instead of transaction1Control. First, is what I am doing legal?  If not, what is the alternative? - -- Jim McMaster mailto:jim.mcmaster@... -----BEGIN PGP SIGNATURE----- Version: PGP 8.1 iQA/AwUBQoo5lmaP5l7/atSJEQIRJwCgsR9K6aPeSX+lAaZGms189KDS11gAnige GIwmKCMUIZQSQDwX5wl/4/wq =v07+ -----END PGP SIGNATURE-----</body>
  </mail>
  <mail>
    <header>Re: Checking the ordering of method calls between separate mocks</header>
    <body>After a long period of code burnout, I finally sat down this weekend and coded a state implementation of my initial prototype. It is quite brute force with a lot of easymock code duplication at this point, and I am sure it contains some bugs, but I hope to continue and get it fully functional and refined. all the done when we on its jMock, specifying</body>
  </mail>
  <mail>
    <header>Re: Problem setting return value for mocks of same class</header>
    <body>It doesn't look like your doing something wrong. Looks like a nasty bug. I'm able to reproduce but I'm pretty short in time this week. I'll look into it as soon as possible. - Henri</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. the same cglib interceptor You can access this file at the URL:  To learn more about file sharing for your group, please visit:  Regards,</body>
  </mail>
  <mail>
    <header>Re: Problem setting return value for mocks of same class</header>
    <body>Hi! There was indeed a bug when creating two mocks of the same class. I found it today and it's now fixed in CVS. I've also uploaded a new packaging on the yahoo group named easymockclassextension1.2_RC2.zip. Tammo, maybe it could replace the current 1.2 RC as the official release. You should also probably think about releasing the official 1.2 soon. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: help for mocking beans in EJB</header>
    <body>Hi, From what I can see, there is no problem mocking what you need. The only thing is where the jndiContext comes from. (the answer might be obvious, I'm not really fond of entity beans... much more an hibernate guy...) If there is a some setJNDIContext on the agent bean, then you're fine. You just need to mock the Context contextCtrl. expectAndDefaultReturn(ctx.lookup("java:comp/env/ejb/CruiseHomeLocal"), You just need to set the mocked context to your agent bean and everything should be fine :-) Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: help for mocking beans in EJB</header>
    <body>That's obvious. If you can inject the mock (the context in this case) to the tested object... then you just can't use it... Creating mocks all over the place without using them could not magically work. There was a thread about on the easymock mailing list some time ago. Talking about wrapping the JNDI to be able to have it returning mocks and about hacking the JNDI to put your stuff in it. That's something I read in JUnit in Action. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: Strange test behaviour using EasyMock</header>
    <body>Hi, Matchers need to be reflexive. You can see discussion on this in the yahoo group. Tammo has explained it. It's a feature or limitation depending on the point of view. So my guess is that yours is not. And since the equals method used to the one from Object, depending on memory allocation you will get different results. From what I saw, you matcher is reflexive except for : which should be something like I didn't try. That's just my guess from reading the code. Hope I got it right, Henri</body>
  </mail>
  <mail>
    <header>Mocking final class</header>
    <body>Hi I know that mocking final class by EasyMock is not possible. But maybe somebody knows any tricks (maybe something with reflection?) that make it possible? Thanks for answers :) Woland</body>
  </mail>
  <mail>
    <header>avoiding code duplication on test suite</header>
    <body>I like easymock, it serves me wel :-) But there is a case I run into code duplication on my tests and I'm not sure if it indicated refactoring or not. The case is simple, imagine a class A with methods 'callerMethod()' and 'calledMethod()', as you could guess the logic of callerMethod consists of calling calledMethod(), regardless of other collaborators it is using. So I write the tests for calledMethod, no problem there. I write the tests for callerMethod, and I run into code duplication in my test because the logic of calledMethod() will be retested again (in combination with that of callerMethod(). I'm wondering if this tells me I should refactor calledMethod to another interface or if there are other ways of testing this properly. Regards, M</body>
  </mail>
  <mail>
    <header>Re: Strange test behaviour using EasyMock</header>
    <body>Does this remove the requirement that matches be reflexive? (Please, please!) -- barry kaplan groups1@...</body>
  </mail>
  <mail>
    <header>Re: Strange test behaviour using EasyMock</header>
    <body>Thank you very much! Knowing this pitfall and how to avoid it will greatly improve my confidence in (continuing) working with EasyMock! It would be nice with a fix of course. A quick fix may also be to update the javadoc of the current version with the requirements of an ArgumentMatcher's argumentToString-implementation. Cheers! -Tor</body>
  </mail>
  <mail>
    <header>Re: Strange test behaviour using EasyMock</header>
    <body>Am 14.06.2005 um 00:23 schrieb Barry Kaplan: Hello Henri, hello Barry, as far as I remember, the reflexivity of the ArgumentsMatcher and the derived Comparable have been a source of most of the problems that were reported in the last months. So yes, you are right, this feature should be removed. Henri, if you have some time to provide a patch, it would be great! - Tammo</body>
  </mail>
  <mail>
    <header>EasyMock and HiveMind</header>
    <body>Just like to introduce myself to the list and developers; I'm Howard Lewis Ship, the creator of Tapestry and of HiveMind, and a fanatical user of EasyMock. Alas, I only just discovered this mailing list, so I probably missed any discussions of upcoming features, but I thought I'd share some of my experiences with EasyMock. One thing I find in my (very aggressive) testing, is that I often need to manage many different control/mock pairs, often 3 or 5, occasionally far more than that.  I think 3 - 5 mock objects is a reasonable number, the large volumes usually reflect tests retrofitted to older, more monolithic code. I have a base TestCase class, HiveMindTestCase, that provides support along these lines. I manages an internal list of MockControl instances. There's a conviencience method, MockControl newMock(Class), that creates a new MockControl, adds it to the internal list, and returns it.  I tend to favor the very strict controls. Additional methods replayControls() and verifyControls() iterate over all the controls, invoking methods replay() and verify() + reset() on each. Further, in many cases, my test case never has to see the control, it can just see the mock; there a Object newMock(Class) method that creates a control and returns its mock. Again, the point of these are to support more complex tests.  It often means I can create base classes that create a control, obtain the mock, and train it before returning it.  This makes the test code much, much, MUCH, simpler to follow. One of my associates has been looking into spinning off this functionality into something that can be reused on its own and/or provided as a base TestCase class; this will be available soon, and I'd be interested to know where it can be contributed to. Some other minor refinements I've made: A system for providing custom matching behavior for just one parameter of a method invocation.  This is a ArgumentMatcher (note the singlular) interface that is paired up with an AggregateArgumentsMatcher (which extends org.easymock.AbstractMatcher). HiveMindTestCase unfiies MockControl.createStringControl() and MockClassControl.createStrictControl() when the easymockclassextension is present. A few additional ideas I've had for EasyMock: I have the most trouble when a piece of code creates a non-comparable object and passes it to a mock.  It would be nice if I could do the following: . . . assertEquals("foo", something.getBar()) ... that is, make it easy to "capture" an object created in this way, so that I can obtain it after the mock phase of my tests, to verify that it was created properly. In fact, generally, it would be nice to optionally attach a "callback" to each method invocation (potentially as an inner class); that might allow me to perform the above kind of checks in line: Maybe just a bit Ruby-esque :-) Often, I'm concerned with the exact order of operations across several different mocks. As I understand it, each control stores a "script". I would like the ability to have a single "script" contains the behavior of several related controls, and ensure not only that each mock follows its own script (invoking each method in the specified order, as strict mocks do today), but that all the method invocations, across the whole set of objects, are invoked in the exact order they were "trained" for. Does that make sense? Sorry if that's too much at once! -- Howard M. Lewis Ship Independent J2EE / Open-Source Java Consultant Creator, Jakarta Tapestry Creator, Jakarta HiveMind Professional Tapestry training, mentoring, support and project work.</body>
  </mail>
  <mail>
    <header>Re: EasyMock and HiveMind</header>
    <body>I'm a relative newbie as far as using easymock. And I was looking for as Howard describes, "A system for providing custom matching behavior for just one parameter" I googled and found hivemind's AggregateArgumentsMatcher that I used as a basis for my own AggregateArgumentsMatcher. Found it very helpful. I'll have to investigate the other Hivemind classes used with easymock. thanks howard, hivemind and easymock. Tom Dyer</body>
  </mail>
  <mail>
    <header>Re: EasyMock and HiveMind</header>
    <body>ass="smalltype"&gt; Tue Jun 14, 2005 10:24 pm    Good to see you here Howard. Some of the things you mention I have already done (as I'm sure many others have as well). EasymockContainer (found in the files section on yahoo, albeit a bit out of date from the latest) is similar to your base case, but works as a helper instead of using up the signle precious base case. The jdk5 version of easymockcontainer provides a Mock&amp;lt;&amp;gt; class that holds both the control and mock parts of the mock. I like you idea of having a method that can return just the mock as I often need just a dummy argument. Again, I also have built a matcher to capturing arguments, and also a "slicing" matcher that is an aggregrate that allows individual matchers for eacah argument. (This was primarly motivated by the need to capture one argument to call, while doing the standard matching for the others.) However, I would much rather have first class support capturing arguments, like your example " "something")". assigned by invocation, nor can they be assigned per argument. These are areas where jmock excels. Another annoyance with matchers is there need to be reflexive. For this I created an abstract matcher that hooks into the easymockcontainer "lifecycle" of replay/verify/reset to determine if it is being called in replay mode or verify  mode so the expected/actuals can be swapped accordingly. The good news is that reflexive matchers will finally be done away with and I can trash all these brittle workarounds. It seems that most people do not use the files/extension posted on the yahoo. Maybe you would like to host an extensions site/cvs..... ;-) -barry Just like to introduce myself to the list and developers; I'm Howard Lewis Ship, the creator of Tapestry and of HiveMind, and a fanatical user of EasyMock. Alas, I only just discovered this mailing list, so I probably missed any discussions of upcoming features, but I thought I'd share some of my experiences with EasyMock. One thing I find in my (very aggressive) testing, is that I often need to manage many different control/mock pairs, often 3 or 5, occasionally far more than that.  I think 3 - 5 mock objects is a reasonable number, the large volumes usually reflect tests retrofitted to older, more monolithic code. I have a base TestCase class, HiveMindTestCase, that provides support along these lines. I manages an internal list of MockControl instances. There's a conviencience method, MockControl newMock(Class), that creates a new MockControl, adds it to the internal list, and returns it.  I tend to favor the very strict controls. Additional methods replayControls() and verifyControls() iterate over all the controls, invoking methods replay() and verify() + reset() on each. Further, in many cases, my test case never has to see the control, it can just see the mock; there a Object newMock(Class) method that creates a control and returns its mock. Again, the point of these are to support more complex tests.  It often means I can create base classes that create a control, obtain the mock, and train it before returning it.  This makes the test code much, much, MUCH, simpler to follow. One of my associates has been looking into spinning off this functionality into something that can be reused on its own and/or provided as a base TestCase class; this will be available soon, and I'd be interested to know where it can be contributed to. Some other minor refinements I've made: A system for providing custom matching behavior for just one parameter of a method invocation.  This is a ArgumentMatcher (note the singlular) interface that is paired up with an AggregateArgumentsMatcher (which extends org.easymock.AbstractMatcher). HiveMindTestCase unfiies MockControl.createStringControl() and MockClassControl.createStrictControl() when the easymockclassextension is present. A few additional ideas I've had for EasyMock: I have the most trouble when a piece of code creates a non-comparable object and passes it to a mock.  It would be nice if I could do the following: . . . Something something = (Something) assertEquals("foo", something.getBar()) ... that is, make it easy to "capture" an object created in this way, so that I can obtain it after the mock phase of my tests, to verify that it was created properly. In fact, generally, it would be nice to optionally attach a "callback" to each method invocation (potentially as an inner class); that might allow me to perform the above kind of checks in line:   public void callback(Object[] parameters) Maybe just a bit Ruby-esque :-) Often, I'm concerned with the exact order of operations across several different mocks. As I understand it, each control stores a "script". I would like the ability to have a single "script" contains the behavior of several related controls, and ensure not only that each mock follows its own script (invoking each method in the specified order, as strict mocks do today), but that all the method invocations, across the whole set of objects, are invoked in the exact order they were "trained" for. Does that make sense? Sorry if that's too much at once! -- Howard M. Lewis Ship Independent J2EE / Open-Source Java Consultant Creator, Jakarta Tapestry Creator, Jakarta HiveMind Professional Tapestry training, mentoring, support and project work. </body>
  </mail>
  <mail>
    <header>Re: EasyMock and HiveMind</header>
    <body>#: by Barry Kaplan's words the mind was *winged* :# have date of Sorry to intervene in the middle of the discussion. Some time ago I have proposed a JUnit free version of EasyMock. This + TestNG will free you up of the above mentioned constrained. And in many testing scenarios this is a very important `freedom´. :alex |.::the_mindstorm::.| mock. need "slicing" of verify --------------------------------------------------------------------------------</body>
  </mail>
  <mail>
    <header>RE: Calling verify</header>
    <body>You need to somewhere remember the controls and call verify on them. There is no way around it. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: Calling verify</header>
    <body>Hi Thomas. Thomas Saxtoft schrieb: You could do something like this, using instance variables (just written down, not checked by compiler): number of inserted MockControls I'd prefer to split the getMocks()-method in the next refactoring step, because of separation of concerns: getMocks() gets the mocks from the mockControls _and_ sets the expected return value. But for now that's enough for answering your question I think. Maybe that's what you're looking for? Now my question: why do you want to have ten equal mocks in one list? What are you going to test? Bernd</body>
  </mail>
  <mail>
    <header>RE: Calling verify</header>
    <body>As an aside, calling verify in tearDown has one big drawback, in my experience: it gets called even when the test already failed, is then likely to fail too, and will therefore hide the original problem. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>RE: Calling verify</header>
    <body>It was just made as an example. Thomas</body>
  </mail>
  <mail>
    <header>Re: Calling verify</header>
    <body>In the files section on yahoo, there is a package called easymockcontainer, which seems to do what you are asking. See   -- barry kaplan groups1@...</body>
  </mail>
  <mail>
    <header>Re: Calling verify</header>
    <body>To do this better, I have overriden TestCase.runBase like so: And then implement verify by verifying all the controls. Incidentially, this is what jMock does in its MockObjectTestCaseWhatever (implemented in org.jmock.core.VerifyingTestCase As this seems to be the only reasonable thing to do in an MockObjectTestCase, I don't really think it is worth the bother to add such a class to EasyMock, though. ~Johannes</body>
  </mail>
  <mail>
    <header>Easy Mock Class Extension throws Stack Overflow Exception</header>
    <body>I can successfully mock the DynamoHttpSerlvetRequest class which is an ATG class.  However when I go to call the serviceRequest method, which has itself as one of the parameters, I get a Stack Overflow Exception. (Trace at end) I am using EasyMock 1.1, EasyMockClassExtension 1.1, cglib-full-2.0.1 and jdk1.3.1. Next when I tried to create a very simple example for the above I am getting, what look to me as, odd errors.  The method I am testing is MyClass.myMethod( MyClass myClass ) but the assert failure I get back tells me : Unexpected method call myMethod(EasyMock for class java.lang.Object): Unexpected method call equals(EasyMock for class java.lang.Object): equals(EasyMock for class java.lang.Object): expected: 0, actual: 1 myMethod(EasyMock for class java.lang.Object): expected: 1, actual: 0 I am creating the mock using : Any ideas? Here is the stack trace for the first problem: java.lang.StackOverflowError at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:44) at org.easymock.classextension.MockClassControl$2.intercept(MockClassControl.java:6\ 7) at atg.servlet.DynamoHttpServletRequest$$EnhancerByCGLIB$$1e8f18ed.toString(&amp;lt;genera\ ted&amp;gt;) at java.lang.String.valueOf(String.java:2013) at java.lang.StringBuffer.append(StringBuffer.java:365) at org.easymock.AbstractMatcher.argumentToString(AbstractMatcher.java:42) at org.easymock.AbstractMatcher.toString(AbstractMatcher.java:112) at org.easymock.internal.Arguments.toString(Arguments.java:28) at org.easymock.internal.MethodCall.toString(MethodCall.java:52) at org.easymock.internal.RecordState.closeVoidMethod(RecordState.java:208) at org.easymock.internal.RecordState.replay(RecordState.java:45) at org.easymock.MockControl.replay(MockControl.java:171) ... Thanks, David</body>
  </mail>
  <mail>
    <header>Re: Easy Mock Class Extension throws Stack Overflow Exception</header>
    <body>I feel shame.  Both issues are fixed in EasymockClassExtension 1.2 RC . Sorry for bothering you :) David --- In easymock@yahoogroups.com, "david_r_mulligan" org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:44) org.easymock.classextension.MockClassControl$2.intercept(MockClassControl.java:6\ 7) atg.servlet.DynamoHttpServletRequest$$EnhancerByCGLIB$$1e8f18ed.toString(&amp;lt;genera\ ted&amp;gt;) org.easymock.AbstractMatcher.argumentToString(AbstractMatcher.java:42)</body>
  </mail>
  <mail>
    <header>Re: Re: Checking the ordering of method calls between separate mocks</header>
    <body>You can add your files on the yahoo group so people can try it. And for me to study it and see how and if it can be integrated :-)</body>
  </mail>
  <mail>
    <header>how to combine mocks and easymock</header>
    <body>Hi, I'm new to mock testing, used easymock immediately w/o practising on normal mock objects. Maybe that's the reason why I'm confused sometimes when writing easymock tests. It happens that I encounter situations where I can only easymock part of the interface I want to test, e.g. I was had a mock control on the HttpServletResponse interface, using it to expect that at some point it's PrintWriter was used properly. Trouble is, I could only test if the response.getWriter() was called properly, not if it wrote the right content. So I got stuck right there, maybe I'm missing something basic here. It's not the first time I encounter things like "damn, this is a class, I can forget about mocks now" (especially on badly written 3rd partu classes I cannot bypass). So the question is really : when shouldn't I consider dynamick mocking and use different approaches, and how should 3rd party classes be mocked ? Hope it isn't a stupid question.</body>
  </mail>
  <mail>
    <header>Re: how to combine mocks and easymock</header>
    <body>Have the response return a mock for the writer. Then you can set expectations on what should be written to the writer. (disclaimer: I wrote this in the email composer) Control mockResponse = ... Control mockWriter = ... mockResponse.expectAndReturn( ... -- barry kaplan groups1@...</body>
  </mail>
  <mail>
    <header>Re: Introduction</header>
    <body>NoClassDefFound means that class is not on your classpath.  Ensure that the junit jar is on your classpath.  It probably doesn't have anything to do with 1.5, it's probably some other classpath config you changed. -- Chad /S=1705007181:HM/EXP=1109906398/A=2593423/R=0/SIG=11el9gslf/*http://www.netflix.\ com/Default?mqso=60190075</body>
  </mail>
  <mail>
    <header>Unable to use EasyMockClassExtension1.2_RC missing Clover</header>
    <body>-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 I am trying to use the class extension (Just downloaded a fresh copy from SourceForge), but getting an error indicating it cannot find Clover.  This is understandable since I do not have a Clover license. There seems to be a fix for this in CVS, but SourceForge is rejecting my attempts at anonymous CVS access.  Would it be possible for someone to, (a) tell me how to gain CVS access, (b) update the 1/30/05 download to include the Clover fix or (c) send me a copy of the jar with the fix? Thank you for any assistance. - -- Jim McMaster mailto:jim.mcmaster@... -----BEGIN PGP SIGNATURE----- Version: PGP 8.1 iQA/AwUBQl0M3GaP5l7/atSJEQIAFgCfTI3cMDGb4ZMFrbPwQ6wPciwlHzwAoKrr ekthqtLNvNjMgZG2WtTfa29v =zdwu -----END PGP SIGNATURE-----</body>
  </mail>
  <mail>
    <header>Re: Unable to use EasyMockClassExtension1.2_RC missing Clover</header>
    <body>Hello Jim, That is strange. It has been a bug in the EasyMock Class Extension 1.2 RC, however I replaced the download with a version built with Henri's fixed build.xml. I have just downloaded it and ran the tests with EasyMock 2 RC 1.3, cglib-full-2.0.2.jar and junit 3.8.1. I got 44 right and one error in testAbstractClass (maybe due to the fact that I ran it on an old Java 1.4.1 on Mac OS X 10.2.8). However, no reports that Clover is missing. The fixed version shows "Documentation for release 1.2_RC (February 7 2005)" in the Documentation.html. If you have a version with an older date, please try to download from another mirror. - Tammo Freese</body>
  </mail>
  <mail>
    <header>RE: Unable to use EasyMockClassExtension1.2_RC missing Clover</header>
    <body>-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 Strange...I just looked at Extension 1.2 RC d=118267&amp;amp;release_id=301195&amp;gt;  download has a date of January 30, 2005, a week before your fix.  Where can I get the latest code? - -- Jim McMaster mailto:jim.mcmaster@... ________________________________ From: freese@... [mailto:freese@...] Sent: Wednesday, April 13, 2005 4:39 PM To: easymock@yahoogroups.com Subject: Re: [easymock] Unable to use EasyMockClassExtension1.2_RC missing Clover Hello Jim, &amp;gt; I am trying to use the class extension (Just downloaded a fresh copy &amp;gt; from SourceForge), but getting an error indicating it cannot find &amp;gt; Clover.  This is understandable since I do not have a Clover license. That is strange. It has been a bug in the EasyMock Class Extension 1.2 RC, however I replaced the download with a version built with Henri's fixed build.xml. I have just downloaded it and ran the tests with EasyMock 2 RC 1.3, cglib-full-2.0.2.jar and junit 3.8.1. I got 44 right and one error in testAbstractClass (maybe due to the fact that I ran it on an old Java 1.4.1 on Mac OS X 10.2.8). However, no reports that Clover is missing. The fixed version shows "Documentation for release 1.2_RC (February 7 2005)" in the Documentation.html. If you have a version with an older date, please try to download from another mirror. - Tammo Freese ________________________________ Yahoo! Groups Links * To visit your group on the web, go to:  * To unsubscribe from this group, send an email to: easymock-unsubscribe@yahoogroups.com * Your use of Yahoo! Groups is subject to the Yahoo! Terms of -----BEGIN PGP SIGNATURE----- Version: PGP 8.1 iQA/AwUBQl2pLGaP5l7/atSJEQKcsACg3uGwBOV/e0KXF8YXpsleNTBxxA8AoNqa QfYgRh6f4RfJxaoV26V8bqCc =KcC9 -----END PGP SIGNATURE-----</body>
  </mail>
  <mail>
    <header>Re: Introduction</header>
    <body>Hi Chad, That's not the problem. I use netbeans where I can set the library used, which automatically also sets the classpath. Now, if I leave the classpath the same and I only change the jdk, then jdk 1.4 works and jdk1.5 doesn't work. So, it's not the classpath. Anyway, if you read the thread, you will see I already concluded that my configuration of the jdk must be wrong, because other people can not reproduce the problem. I will leave it at that. In June, when fedora core 4 is published, I will reinstall java anyways. If it is a configuration issue, it should be solved after reinstalling linux and java. For the time being I just work with jdk1.4..... Guus. -- A.J. Bonnema, Leiden The Netherlands, user #328198 (Linux Counter</body>
  </mail>
  <mail>
    <header>Re: Unable to use EasyMockClassExtension1.2_RC missing Clover</header>
    <body>Jim, I would bet that one or more of the sourceforge mirrors is or was out of date.  I downloaded the class extension 2 weeks ago and it worked for me. David</body>
  </mail>
  <mail>
    <header>Re: Unable to use EasyMockClassExtension1.2_RC missing Clover</header>
    <body>Am Donnerstag, 14.04.05 um 01:20 Uhr schrieb Jim McMaster: The latest build is available on SourceForge. The date of the fixed version still shows January 30, 2005, although it was built on Februray 7th. Please look into the Documentation.html of your download for the correct build date. - Tammo Freese</body>
  </mail>
  <mail>
    <header>RE: Re: Unable to use EasyMockClassExtension1.2_RC missing Clover</header>
    <body>-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 I just tried again.  I am new to linux, and file-roller -&amp;gt; extract apparently was not overwriting the old copy.  I extracted, looked at the jar, and saw clover classes.  Then I erased the first copy, re-extracted, and got a version of the jar without clover.  Now, though, when I run my test, I get: - -- Jim McMaster mailto:jim.mcmaster@... ________________________________ From: david_r_mulligan [mailto:mulligan_david@...] Sent: Wednesday, April 13, 2005 11:35 PM To: easymock@yahoogroups.com Subject: [easymock] Re: Unable to use EasyMockClassExtension1.2_RC missing Clover Jim, I would bet that one or more of the sourceforge mirrors is or was out of date.  I downloaded the class extension 2 weeks ago and it worked for me. David &amp;gt; -----BEGIN PGP SIGNED MESSAGE----- &amp;gt; Hash: SHA1 &amp;gt; Strange...I just looked at  &amp;gt; Extension 1.2 RC &amp;gt; d=118267&amp;amp;release_id=301195&amp;gt;  download has a date of January 30, 2005, &amp;gt; a week before your fix.  Where can I get the latest code? &amp;gt; - -- &amp;gt; Jim McMaster &amp;gt; mailto:jim.mcmaster@c... &amp;gt; ________________________________ &amp;gt;       From: freese@a... [mailto:freese@a...] &amp;gt;       Sent: Wednesday, April 13, 2005 4:39 PM &amp;gt;       To: easymock@yahoogroups.com &amp;gt;       Subject: Re: [easymock] Unable to use EasyMockClassExtension1.2_RC &amp;gt; missing Clover &amp;gt;       Hello Jim, &amp;gt;       &amp;gt; I am trying to use the class extension (Just downloaded a fresh &amp;gt; copy &amp;gt;       &amp;gt; from SourceForge), but getting an error indicating it cannot find &amp;gt;       &amp;gt; Clover.  This is understandable since I do not have a Clover &amp;gt; license. &amp;gt;       That is strange. It has been a bug in the EasyMock Class Extension &amp;gt; 1.2 &amp;gt;       RC, &amp;gt;       however I replaced the download with a version built with Henri's &amp;gt; fixed &amp;gt;       build.xml. &amp;gt;       I have just downloaded it and ran the tests with EasyMock 2 RC 1.3, &amp;gt;       cglib-full-2.0.2.jar and junit 3.8.1. &amp;gt;       I got 44 right and one error in testAbstractClass (maybe due to the &amp;gt; fact &amp;gt;       that I ran it on an old Java 1.4.1 on Mac OS X 10.2.8). However, no &amp;gt;       reports &amp;gt;       that Clover is missing. &amp;gt;       The fixed version shows &amp;gt;       "Documentation for release 1.2_RC (February 7 2005)" &amp;gt;       in the Documentation.html. If you have a version with an older date, &amp;gt;       please try to download from another mirror. &amp;gt;       - &amp;gt;       Tammo Freese &amp;gt; ________________________________ &amp;gt;       Yahoo! Groups Links &amp;gt;       *      To visit your group on the web, go to: &amp;gt;       *      To unsubscribe from this group, send an email to: &amp;gt;             easymock-unsubscribe@yahoogroups.com &amp;gt;       *      Your use of Yahoo! Groups is subject to the Yahoo! Terms of &amp;gt; -----BEGIN PGP SIGNATURE----- &amp;gt; Version: PGP 8.1 &amp;gt; iQA/AwUBQl2pLGaP5l7/atSJEQKcsACg3uGwBOV/e0KXF8YXpsleNTBxxA8AoNqa &amp;gt; QfYgRh6f4RfJxaoV26V8bqCc &amp;gt; =KcC9 &amp;gt; -----END PGP SIGNATURE----- ________________________________ Yahoo! Groups Links * To visit your group on the web, go to:  * To unsubscribe from this group, send an email to: easymock-unsubscribe@yahoogroups.com * Your use of Yahoo! Groups is subject to the Yahoo! Terms of -----BEGIN PGP SIGNATURE----- Version: PGP 8.1 iQA/AwUBQl6NPWaP5l7/atSJEQKbNQCfV27iO3g9z6+dCMfgY7Of9xnpj/UAoMYk lfTK3LXy2YILvlw/wPDIgRD5 =GuEi -----END PGP SIGNATURE-----</body>
  </mail>
  <mail>
    <header>RE: Re: Unable to use EasyMockClassExtension1.2_RC missing Clover</header>
    <body>-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 I don't know what deleted my stack trace...I will try again.  When I run my tests now, I get: java.lang.IllegalStateException: Unknown callback class org.easymock.classextension.internal.ClassProxyFactory$1 at net.sf.cglib.proxy.CallbackUtils.getGenerator (CallbackUtils.java:102) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:314) at net.sf.cglib.proxy.Enhancer.createClass(Enhancer.java:278) at org.easymock.classextension.internal.ClassProxyFactory.createProxy (ClassProxyFactory.java:96) at org.easymock.MockControl.&amp;lt;init&amp;gt;(MockControl.java:133) at org.easymock.classextension.MockClassControl.&amp;lt;init&amp;gt;(MockClassControl.j ava:189) at org.easymock.classextension.MockClassControl.&amp;lt;init&amp;gt;(MockClassControl.j ava:194) at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:36) at com.aptas.papyrus.DodsOrfFeedHelperDescendantTest.setUp (DodsOrfFeedHelperDescendantTest.java:123) at junit.framework.TestCase.runBare(TestCase.java:125) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests (RemoteTestRunner.java:474) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run (RemoteTestRunner.java:342) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main (RemoteTestRunner.java:194) - -- Jim McMaster mailto:jim.mcmaster@... -----BEGIN PGP SIGNATURE----- Version: PGP 8.1 iQA/AwUBQl6Z5maP5l7/atSJEQLmdQCcCSXQznL5AzgXKnk8Oi9f6P598OYAoLJ1 6qx/4sE4f+XvcTZyBUchbHoY =vJjj -----END PGP SIGNATURE-----</body>
  </mail>
  <mail>
    <header>RE: Re: Unable to use EasyMockClassExtension1.2_RC missing Clover</header>
    <body>-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 On Thursday, April 14, 2005 10:27 AM, Jim McMaster Does anyone have an idea what could be going wrong here?  I am getting pretty desperate. - -- Jim McMaster mailto:jim.mcmaster@... -----BEGIN PGP SIGNATURE----- Version: PGP 8.1 iQA/AwUBQmQfbGaP5l7/atSJEQJUcgCg/sMzndzoL5zguAGrXyZDa39Tb+AAoIkA bCDbR5+7b7dfQd72dn5hV3a4 =56lH -----END PGP SIGNATURE-----</body>
  </mail>
  <mail>
    <header>Re: how to combine mocks and easymock</header>
    <body>Wait a minute, java.io.Writer is an abstract class, not an interface. That's the root of my problem, or am I missing something here ? Regards, Q</body>
  </mail>
  <mail>
    <header>Re: how to combine mocks and easymock</header>
    <body>Ah, I think I know now what you meant. You were referring to the MockWriter class of the mockobjects library, right ? :-) I'm sorry for the miscomprehension, but so far I never used that lib, mostly because I thought easymock covers it all, which was naïve I have to admit. It seems this is a very good solution and I also have an answer to the question how easymock should be combined with mocks. Q</body>
  </mail>
  <mail>
    <header>Re: Calling verify</header>
    <body>then likely You can get around this problem by creating an abstract test that all of your tests inherit from.  It overrides runBare() from JUnit. Then, in your tearDown, only verify your mocks if shouldVerify() returns true. Jonathan /** * @see junit.framework.TestCase#runBare() */ // if we throw an exception on the test, // we need to turn verification off</body>
  </mail>
  <mail>
    <header>Re: Re: how to combine mocks and easymock</header>
    <body>If Writer is an abstract class then you should use easymock class extension to mock it. Regards, Henri</body>
  </mail>
  <mail>
    <header>Re: Re: Unable to use EasyMockClassExtension1.2_RC missing Clover</header>
    <body>I'm suspecting your cglib version. Which version are you using? (mine is 2.0.2)</body>
  </mail>
  <mail>
    <header>RE: Re: Unable to use EasyMockClassExtension1.2_RC missing Clover</header>
    <body>-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 I was using cglib-2RC.  I installed cglib-2.1 today, and that fixed the problem. - -- Jim McMaster mailto:jim.mcmaster@... ________________________________ From: easymock@yahoogroups.com [mailto:easymock@yahoogroups.com] On Behalf Of Henri Tremblay Sent: Thursday, April 21, 2005 6:38 PM To: easymock@yahoogroups.com Subject: Re: [easymock] Re: Unable to use EasyMockClassExtension1.2_RC missing Clover I'm suspecting your cglib version. Which version are you using? (mine is 2.0.2) &amp;gt; -----BEGIN PGP SIGNED MESSAGE----- &amp;gt; Hash: SHA1 &amp;gt; On Thursday, April 14, 2005 10:27 AM, Jim McMaster &amp;gt; &amp;gt; When I run my tests now, I get: &amp;gt; &amp;gt; java.lang.IllegalStateException: Unknown callback class &amp;gt; &amp;gt; org.easymock.classextension.internal.ClassProxyFactory$1 &amp;gt; &amp;gt;       at net.sf.cglib.proxy.CallbackUtils.getGenerator &amp;gt; &amp;gt;       (CallbackUtils.java:102) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:314) &amp;gt; &amp;gt; at net.sf.cglib.proxy.Enhancer.createClass(Enhancer.java:278) &amp;gt; &amp;gt; at org.easymock.classextension.internal.ClassProxyFactory.createProxy &amp;gt; &amp;gt; (ClassProxyFactory.java:96) at &amp;gt; &amp;gt;       org.easymock.MockControl.&amp;lt;init&amp;gt;(MockControl.java:133) &amp;gt; &amp;gt; at org.easymock.classextension.MockClassControl.&amp;lt;init&amp;gt;(MockClassControl &amp;gt; &amp;gt; .j &amp;gt; &amp;gt;       ava:189) at org.easymock.classextension.MockClassControl.&amp;lt;init&amp;gt;(MockClassControl &amp;gt; &amp;gt; .j &amp;gt; &amp;gt;       ava:194) at &amp;gt; &amp;gt;       org.easymock.classextension.MockClassControl.createControl &amp;gt; &amp;gt;       (MockClassControl.java:36) at &amp;gt; &amp;gt;       com.aptas.papyrus.DodsOrfFeedHelperDescendantTest.setUp &amp;gt; &amp;gt;       (DodsOrfFeedHelperDescendantTest.java:123) at &amp;gt; &amp;gt;       junit.framework.TestCase.runBare(TestCase.java:125) at &amp;gt; &amp;gt;       junit.framework.TestResult$1.protect(TestResult.java:106) at &amp;gt; &amp;gt; junit.framework.TestResult.runProtected(TestResult.java:124) at &amp;gt; &amp;gt;       junit.framework.TestResult.run(TestResult.java:109) at &amp;gt; &amp;gt;       junit.framework.TestCase.run(TestCase.java:118) at &amp;gt; &amp;gt; junit.framework.TestSuite.runTest(TestSuite.java:208) at &amp;gt; &amp;gt; junit.framework.TestSuite.run(TestSuite.java:203)       at &amp;gt; &amp;gt; org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests &amp;gt; &amp;gt; (RemoteTestRunner.java:474) at &amp;gt; &amp;gt; org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run &amp;gt; &amp;gt; (RemoteTestRunner.java:342) at &amp;gt; &amp;gt; org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main &amp;gt; &amp;gt; (RemoteTestRunner.java:194) &amp;gt; Does anyone have an idea what could be going wrong here?  I am &amp;gt; getting pretty desperate. &amp;gt; - -- &amp;gt; Jim McMaster &amp;gt; mailto:jim.mcmaster@... &amp;gt; -----BEGIN PGP SIGNATURE----- &amp;gt; Version: PGP 8.1 &amp;gt; iQA/AwUBQmQfbGaP5l7/atSJEQJUcgCg/sMzndzoL5zguAGrXyZDa39Tb+AAoIkA &amp;gt; bCDbR5+7b7dfQd72dn5hV3a4 &amp;gt; =56lH &amp;gt; -----END PGP SIGNATURE----- &amp;gt; Yahoo! Groups Links ________________________________ Yahoo! Groups Links * To visit your group on the web, go to:  * To unsubscribe from this group, send an email to: easymock-unsubscribe@yahoogroups.com * Your use of Yahoo! Groups is subject to the Yahoo! Terms of -----BEGIN PGP SIGNATURE----- Version: PGP 8.1 iQA/AwUBQmhO/maP5l7/atSJEQJ2ZwCdHxoxh8fiWnpsQzige/vG3sGTTZMAnju6 7UWz2Bp6+n0jxf3TZTzg93Ek =9Owc -----END PGP SIGNATURE-----</body>
  </mail>
  <mail>
    <header>Easymock and TestNG</header>
    <body>Hi! My name is Alexandru Popescu and I am one of the TestNG ( I would like to ask you 2 things :-) 1/ where can I access the Easymock codebase repository? (CVS,SVN - I couldn't find this info on site) 2/ what is your opinion about having an Easymockck distro for TestNG, this meaning to remove all references to JUnit. After a quick look at the sources and I think I can do it by my own, but I would like to know your opinion before starting. Supporting JUnit extensions in TestNG is our next goal and I consider that mocks represent one of the most needed extensions. thanking you in advance for your answers, --:alex |.::the_mindstorm::.|</body>
  </mail>
  <mail>
    <header>Re: Easymock and TestNG</header>
    <body>easymock@yahoogroups.com schrieb am 26.04.05 08:03:44: 1) Click the SourceForge.NET logo on the EasyMock home page 2) Click "CVS" :-) JUnit is by far the most commonly used testing framework. EasyMock uses the AssertionFailedError class so that EasyMock failures appear as failures in JUnit, not as errors. I do not see a simple way to remove all references to JUnit, since this feature needs the AssertionFailedError class. You may replace the AssertionFailedError with the failure exception class of your framework, and then you would have an adapted version for your framework. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Easymock and TestNG</header>
    <body>Thanks. Missed that picture - I guess the eye is so used to seeing it as the synapsis aren't working correctly all the time. I agree with you, but I can say that TestNG has a lot of good reviews too ;-). class of I do not intend to use our own exception (as we don't have one ;-)), but using the JDK1.4 AssertionError. About being easy or not, if you allow me to do the port I will let you know how simple/complex this move was ;-). cheers, --:alex |.::the_mindstorm::.|</body>
  </mail>
  <mail>
    <header>RE: An experiment in call recording</header>
    <body>Hi Michael, Really cool idea, I think it will be very useful. I have two suggestions: 1) Other outputs: 1.1) XML: more specifically, executable XML. The format used by JavaBeans XMLEncoder is designed to be "replayed" so it could be used to "program" the EasyMocks, similarly to what you did with generated Java code. 1.2) Sequence diagrams: check the very simple syntax used by the SEQUENCE tool ( 2) UML output in your maven page: You can customize the dotuml plugin to create links from your class diagrams back to the respecive pages in javadoc or xref. Use the properties maven.dotuml.apidocmap and maven.dotuml.apidocroot. Regards,</body>
  </mail>
  <mail>
    <header>Re: An experiment in call recording</header>
    <body>Hi Nascif, This could be part of a declarative notation for pre-recording EasyMocks. In general, I think that is a better idea than generating Java code, as I'm currently doing. For some reason I didn't think of the XML serialization provided by the JDK. Maybe other options, such as XMLBeans and XStreams are even better, I don't know enough about them to be sure. The whole recording idea originated when I was pondering ways to use EasyMock for testing apps using the Spring framework. There I use a different set of application context for testing where some of the beans are actually EasyMock-generated mocks. I have a helper class that inserts a mock and its control into an application context. But this mock still needs to be prepared programmatically. My original idea was that I'd like to do this declaratively in the XML application context configuration. Unfortunately, the syntax is not easily extensible (despite the "X"). I think I'll look into this again. Is it integrated with maven? If not, I'd prefer to use dotuml/UMLGraph. But most likely I'll leave this to movitated others... Thanks for pointing this out. I've tried it now, but don't seem to get it to work. Seeing that you are the author of that feature, could you please send me a simple example map file by private mail? Michael -- Michael Schuerig                  There is no matrix, mailto:michael@...        only reality.</body>
  </mail>
  <mail>
    <header>RE: An experiment in call recording</header>
    <body>Hi Michael, Those are the files that I use for the dotuml configuration. Regards,</body>
  </mail>
  <mail>
    <header>Introduction</header>
    <body>Hi all, I have just started to discover the advantages of upfront testing in a tight test-develop cycle using the book "test-driven development (A practical guide)" of David Astels. This book drives the tdd-theorie from an example. During the development of this example David uses easymock extensively, so I had a chance to meet with this incredibly flexible tool. Really, testing upfront using things like mock objects is completely new to me. I find both tdd and easymock quite intuitive, even though sometimes I have to bend my intuition backwards (from years of waterfall method application, I am afraid). Now, I'd like to finish my intro with the first problem I encountered using easymock and I'd like to find out whether anyone else has seen this problem or can reproduce it. When I started testing and developing from the example of David Astels book, I started out comparing Netbeans and eclipse for ease of use etc. So I entered the source in both, doing exactly what the book showed. I first encountered strange problems in Netbeans (a NoClassDefFound for one of my own classes), so I quit using Netbeans. It seemed like an environmental problem, but I could not find out what it was, so I let it be. Then I got a problem in Eclipse where I got a java.lang.NoClassDefFound for the class junit/framework/AssertionFailedError. To determine whether the problem was my own, I then took the source of easymock and found the same problem. It was in UsageVerifyTest.testTwoReturns that I got the same error. As the error was in junit, something outside of easymock was wrong. Now I suspected the JDK was the problem so I switched from JDK1.5.0 to JDK1.4.2 and the problem vanished. Has anyone encountered this problem? Is there a remedy for it? Could it be, that junit was developed and generated from a 1.4-environment and using it from a 1.5-environment doesn't work? Guus. -- A.J. Bonnema, Leiden The Netherlands, user #328198 (Linux Counter</body>
  </mail>
  <mail>
    <header>ArgumentsMatcher still broke in 1.2?</header>
    <body>I've just written a matcher and find that the expected/actual are reversed. This came up ages ago. Are there any plans to finally fix this? -barry</body>
  </mail>
  <mail>
    <header>What to make fo this exception trace?</header>
    <body>Something is badly wrong either in my test or easymock 1.2. But how to know which, as there is no useful stack trace? I believe this was one of the improvements in 1.2, which in general should be good. But with  the content-free error that is provided below, how I am to determine the problem without spending hours stepping thru easymock code. Any suggestions would be much appreciated. ----- junit.framework.AssertionFailedError: null at org.easymock.container.EasymockContainer.verify(EasymockContainer.java:96) at org.drools.semantics.spring.factory.PojoRuleBuilderTest.testBuildRule(PojoRuleBu\ ilderTest.java:283) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:474) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :342) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:194)</body>
  </mail>
  <mail>
    <header>RE: ArgumentsMatcher still broke in 1.2?</header>
    <body>As far as I remember, Tammo intended to "fix" this by renaming the variables, not by making it actually work the way they are named now. Don't remember the reason, though. But this is an open source project, so if this "bug" were important to me, I'd take a look at wether I could fix it myself. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: What to make fo this exception trace?</header>
    <body>Hello memelet, It is. At least I hope so ;-) Stack traces in EasyMock are now only cut if the exception is thrown by EasyMock. For other errors (like exceptions when calling toString() or equals() of objects used as method arguments), the full stack trace is given. [...] The exception is thrown by EasymockContainer, which is *not* part of EasyMock?! - Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: ArgumentsMatcher still broke in 1.2?</header>
    <body>Am Donnerstag, 03.03.05 um 16:36 Uhr schrieb Ilja Preuss: ArgumentsMatchers are used to allow objects to be equal even if their equals() methods disagree. - Tammo Freese</body>
  </mail>
  <mail>
    <header>Re: ArgumentsMatcher still broke in 1.2?</header>
    <body>Tammo, I don't understand what this means with regard to swapping the expected/actual in ArgumentsMatcher. -- barry kaplan groups1@...</body>
  </mail>
  <mail>
    <header>Re: What to make fo this exception trace?</header>
    <body>No, the EasymockContainer invoked MockControl.verify() down to ResultListMap.addActual() which thru a NPE at: I don't understand why yet. For this type of situation, being able to configure easymock to always include its own stack trace elements would be very helpful. -- barry kaplan groups1@...</body>
  </mail>
  <mail>
    <header>Easy way to match maps?</header>
    <body>Hi, a database caller method? Do I have to write a custom matcher for this? TIA, Vamsee. -- Lassen Sie Ihren Gedanken freien Lauf... z.B. per FreeSMS GMX bietet bis zu 100 FreeSMS/Monat:</body>
  </mail>
  <mail>
    <header>Re: Easy way to match maps?</header>
    <body>Hi Vamsee. Vamsee Kanakala schrieb: No, you don't have to. EasyMock uses the equal-Method in HashMap, which is inherited from AbstractMap (see  ang.Object) ). If you don't like the behaviour of this equal implementation you have to write your own custom matcher. Hope this helps,</body>
  </mail>
  <mail>
    <header>RE: ArgumentsMatcher still broke in 1.2?</header>
    <body>I understand that the equals method needs to be symmetric. Not sure wether that really has to mean that ArgumentsMatcher needs to be, too... Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: Easy way to match maps?</header>
    <body>Hi Bernd, But why doesn't easyMock recognize two maps as being the same when both of them objects are hashmaps and have the same keys&amp;amp;values? That is, easyMock says "unexpected call..." and lists the maps as such: Both thse objects should be matched by default, right? TIA, Vamsee. -- SMS bei wichtigen e-mails und Ihre Gedanken sind frei ... Alle Infos zur SMS-Benachrichtigung:</body>
  </mail>
  <mail>
    <header>Re: Easy way to match maps?</header>
    <body>On Sat, 5 Mar 2005 11:11:41 +0100 (MET), Vamsee Kanakala Hi, Vamsee The comparison of HashMaps should work. I have testet it out in EasyMock 1.1 and 1.2 (see attached file). What it looks like in your code, however is that you are using an object as the key in the HashMap. HashMap.equals calls the equals method on its contents. Have you implemented this equals correctly? If you need help with implementing your own equals-method correctly, take a look at the GSBase library ( which has a conveinient EqualsTester ( ester.html Hope this helps, ~Johannes</body>
  </mail>
  <mail>
    <header>createControl(xxx.class) can deliver a false negative; createStrict --&amp;gt; false positive</header>
    <body>Hi, As a new user of easymock I have a problem. Using the tdd book of David Astels I enter source and test as the text goes. This works up to a point (some source is based on version 0.8 so should be changed). However, in one example (chapter 11, test 16), the example did not work. Extensive checking revealed the source to be correct, except for the call to createControl. This call had to be replaced by createStrictControl for the test to pass. Now, as I read the documentation for createControl, the order of the call will not be checked. From the docs: "On a Mock Object returned by a MockControl created with MockControl.createControl(), the order of method calls is not checked. If you would like a "strict" Mock Object that checks the order of method calls, use MockControl.createStrictControl() to create its MockControl." However, it turns out they are checked, but in an order that is not in control. Would not this be a false negative? Should not every order be accepted by control, if the non-strict creator is used? The second issue is, that even using strict version may give a false positive, or "no problem" where a problem was expected. I checked the easymock source, but I'm afraid this is not for mere mortal (and if it is, by inference, I must be non-mortal ;-). So I will give some more information about the calls. The specification in this case is two calls to the same method with different parameters. What happens when testing with createControl was the following: Now movies and newMovies differ by the second movie (Star Trek i.e. Star Trek I). The calls are made in the sequende movies, followed by newMovies. ==== using createConctrol ===== Using createControl(xxx.class) I get an error showing: init: deps-jar: compile: Compiling 1 source file to /home/abonnema/projects/nbmovielist/build/test/classes compile-test-single: Testsuite: movielist.TestGui Tests run: 4, Failures: 1, Errors: 0, Time elapsed: 0.086 sec Testcase: testUpdating(movielist.TestGui):    FAILED junit.framework.AssertionFailedError: org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:44) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) Now this is strange. The setMovies call is listed twice.... It turns out, if I reverse the calls before the replay, the calls are accepted without a problem. ==== using createStrictConctrol ===== If I use the above sequence with createStrictControl(xxx.class) I have no problem either. However, if I now use movies for both calls, I also have no problem, which is a false positive! Seems more serious to me. I wonder whether anyone can explain this from the features of easymock as is, or whether real proof is necessary, i.e. would this be an error or not? Guus. -- A.J. Bonnema, Leiden The Netherlands, user #328198 (Linux Counter</body>
  </mail>
  <mail>
    <header>Re: createControl(xxx.class) can deliver a false negative; createStrict --&amp;gt; false positive</header>
    <body>Hi, I was pretty sure it would work be still I tried your test. In fact I did this: ---------------------------- Test ----------------------------------- --------------------------------- Mocked interface -------------------------------- -------------------------------- Movie ------------------------------------------------- --------------------------------------------------------------------------------\ -- Works perfectly. My guess is that either your equals or hashCode method on Movie is not implemented or implemented correctly. Which would explain why you are getting a random behavior. If this is the case the issue comes from your code. Remember that hashCode should always be implemented to be coherent with equals otherwise you will get a random behavior when your object is inserted in a Map or Set (which is what easymock do). While we are into code revision, I would also consider using List (which is an interface) instead of Vector in your code. And to use ArrayList instead of Vector. Vector is terribly slow since it's synchronized (it should be deprecated just like Hashtable). To get a synchronized list you always can do: Collections.synchronizedList(list). I didn't read the book. And maybe all these examples are coming out of it. So it's not your fault. If so, the book would need an updated edition :-( even if it has the great idea of using easymock. :-) Hope it helps, Cheers, Henri sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25)</body>
  </mail>
  <mail>
    <header>Re: createControl(xxx.class) can deliver a false negative; createStrict --&amp;gt; false positive</header>
    <body>Hi Henry, Thanks for having a look. I very much appreciate it. I will send you the code, just so you can see what I did. Indeed, the author (David Astels), did implement toString(), Equals(Object o) and hashCode() into Movie and tested the equals thingy with EqualsTester (some gargoyle). Furthermore, the movie uses a List interface with ArrayList implementation. Why David chose to use Vector in the method arguments, I really don't know. So, this appears not to be the error. I will enclose the code, so you can have a go. I don't know whether you have unix or windows, so I include both a tar.gz and a zipfile. [Besides my code, I tried the official download from  to change some ant-classpath parameters) and got the same error in the same test. All other tests ran fine. So I concluded the problem was not in de code but possibly in the supporting code.] Guus. --- ava:25) -- A.J. Bonnema, Leiden The Netherlands, user #328198 (Linux Counter</body>
  </mail>
  <mail>
    <header>Re: createControl(xxx.class) can deliver a false negative; createStrict --&amp;gt; false positive</header>
    <body>Wow, that was a tricky one. It comes from the fact that the code is renaming one of the movies. It's done in MovieListEditor.update. This movie that is renamed is the same movie that is in the Vector passed as an argument to setMovies() during the recording phase. What happens is that the movie is rename from "Star Trek I" to "Star Trek". So the two Vector arguments passed at recording now contains the exact same thing. But easymock is not aware of that. So in the list of arguments easymock is keeping internally, it takes the first one matching the passed one and since the setMovies method was called already once for it, it throws an assertion. This doesn't occur when we use a strict control because the implementation is different. Since the calls should be ordered, we just progress along the arguments array in the same order as they were recorded. There is no need to try to find a matching one in the list of all recorded arguments. So, what can we do from there? About the test. Movie wasn't mocked probbly because it was considered too simple to be. But since the object is mutable, it could have been worthy to do so. Also, since Movies are mutable, it's not a really good idea to put the same movies in the movieList and in the recording. So the way the test is done is not really safe. But then, what can easymock do... I'm seeing some possibilities: 1- Copy the arguments passed to easymock to make sure they are not modified -&amp;gt; Not possible, they might not be cloneable. 2- Put a limitation that the arguments passed during recording to easymock shouldn't be modified later on for easymock to work correctly. -&amp;gt; Not bad, I don't think it is such a big limitation and in fact it might improves the test quality. Would be nice if we can detect these cases to throw a meaningful exception (possibly check the arguments, if we find two equals one, return a different exception) 3- Do an arguments pack before each call to make sure newly equals ones are kept together. -&amp;gt; Maybe not as easy as it seems to implement and possibly not the behavior we want. It will also slow down the tests' execution. At first sight, I like 2. Maybe 3 is also not that bad. Tammo, what do you think? Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: ArgumentsMatcher still broke in 1.2?</header>
    <body>I quite agree it's pretty anoying.. The sad thing being I can't see a solution yet. When everything is ordered, there is no issue. I don't know if it currently works (I think it doesn't but only because of lastMethodCallEqualTo in addExptected which is not necessary I think) but it would be possible to have a matcher doing whatever it likes. The problem occurs when ordering is not wished. The matcher is used at recording to keep same (in a matchable way) arguments together and the at replay to try to find a matching call where equals is called inside a TreeMap. Now I'm thinking... Maybe we could forget about the TreeMap and perform equals by ourselves in a List of arguments. And also stop using the matcher during the recording. That way it would be called only at replay and in the expected order. That should work nicely. The only issue is when two arguments in the list can be considered as equals according to the matcher. You will end with the problem I talked about in a mail yesterday (the Movie thing). Same as for yesterday, if we manage to return a meaninful error so the developer can fix the test to prevent it, then we might be in business. - Henri</body>
  </mail>
  <mail>
    <header>java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError</header>
    <body>Hi all, The error in the subject line, appears when using easymock, in the call to MockControl.createControl() downto MockControl.createBehaviour(). It only appears when working from jdk1.5. The junit testset runs without errors, so I suspect this to be a problem with easymock. Both my (toy) project and the testset of easymock show the same error. As soon as I change the environment in netbeans to jdk1.5, the error shows. It doesn't matter whether I use the standard junit3.8.1, one I compiled from jdk1.4 or one I compiled from jdk1.5. I include the trace when running the complete set of tests below my message. Can anyone confirm this error? Guus. -- A.J. Bonnema, Leiden The Netherlands, user #328198 (Linux Counter init: deps-jar: compile: compile-test-single: Created dir: /usr/local/java/easymock1.1/build/test/results Testsuite: org.easymock.tests.AllTests Tests run: 291, Failures: 0, Errors: 267, Time elapsed: 0.505 sec Testcase: testSetMatcherBeforeCallingMethods(org.easymock.tests.RecordStateInvalidMatcherT\ est): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) Testcase: testSetMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) Testcase: testSetMatcherTwice2(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) Testcase: testSetSameMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) Testcase: testSetReturnValueWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsageTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testSetExpectedVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInva\ lidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testOpenVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsag\ eTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testSetWrongReturnValueBoolean(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testSetWrongReturnValueShort(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testSetWrongReturnValueChar(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testSetWrongReturnValueInt(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testSetWrongReturnValueLong(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testSetWrongReturnValueFloat(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testSetWrongReturnValueDouble(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testSetWrongReturnValueObject(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Testcase: testEqualsBeforeActivation(org.easymock.tests.ObjectMethodsTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testEqualsAfterActivation(org.easymock.tests.ObjectMethodsTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testHashCodeBeforeActivation(org.easymock.tests.ObjectMethodsTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testHashCodeAfterActivation(org.easymock.tests.ObjectMethodsTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testToStringBeforeActivation(org.easymock.tests.ObjectMethodsTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testToStringAfterActivation(org.easymock.tests.ObjectMethodsTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testToStringForClasses(org.easymock.tests.ObjectMethodsTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testTwoReturns(org.easymock.tests.UsageVerifyTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testAtLeastTwoReturns(org.easymock.tests.UsageVerifyTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testTwoThrows(org.easymock.tests.UsageVerifyTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testActivateWithoutReturnValue(org.easymock.tests.RecordStateInvalidStateChangeT\ est): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) Testcase: testVerifyWithoutActivation(org.easymock.tests.RecordStateInvalidStateChangeTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) Testcase: testByteReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) Testcase: testShortReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVa\ lueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) Testcase: testCharReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) Testcase: testIntReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnValu\ eTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) Testcase: testLongReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) Testcase: testThrowNull(org.easymock.tests.RecordStateInvalidThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) Testcase: testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) Testcase: testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidThrowableTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) Testcase: testThrowAfterThrowable(org.easymock.tests.RecordStateInvalidThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) Testcase: testSetOpenCallCountTwice(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) Testcase: testSetIllegalMinimumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) Testcase: testSetIllegalMaximumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) Testcase: testSetMinimumBiggerThanMaximum(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) Testcase: testExactCallCountByLastCall(org.easymock.tests.UsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testOpenCallCountByLastCall(org.easymock.tests.UsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testExactCallCountByLastThrowable(org.easymock.tests.UsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testOpenCallCountByLastThrowable(org.easymock.tests.UsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testMoreThanOneArgument(org.easymock.tests.UsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testUnexpectedCallWithArray(org.easymock.tests.UsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testWrongArguments(org.easymock.tests.UsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testArgumentsOrdered(org.easymock.tests.UsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testDefaultReturnValueBoolean(org.easymock.tests.NiceMockControlTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testDefaultReturnValueFloat(org.easymock.tests.NiceMockControlTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testDefaultReturnValueDouble(org.easymock.tests.NiceMockControlTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testDefaultReturnValueObject(org.easymock.tests.NiceMockControlTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testThrowAfterThrowable(org.easymock.tests.LegacyBehaviorTests): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.LegacyBehaviorTests.testThrowAfterThrowable(LegacyBehaviorTes\ ts.java:18) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) Testcase: testSetBooleanReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodC\ allMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetLongReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCall\ MissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetFloatReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetDoubleReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetObjectReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMis\ singTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMissin\ gTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetBooleanReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetLongReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMetho\ dCallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetFloatReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMeth\ odCallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetDoubleReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetObjectReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetVoidCallableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetThrowableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCallM\ issingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetBooleanDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordState\ MethodCallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetLongDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetFloatDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetDoubleDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetObjectDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetDefaultVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethod\ CallMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testSetDefaultThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) Testcase: testDefaultName(org.easymock.tests.MockNameTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) Testcase: testReturnFloat(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) Testcase: testReturnDouble(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) Testcase: testThrowNull(org.easymock.tests.RecordStateInvalidDefaultThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) Testcase: testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidDefaultThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) Testcase: testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidDefaultThrow\ ableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) Testcase: testDefaultMatcher(org.easymock.tests.DefaultMatcherTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testFailInReplayState(org.easymock.tests.DefaultMatcherTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testFailIfDefaultMatcherSetTwice(org.easymock.tests.DefaultMatcherTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testFailIfDefaultMatcherSetTooLate(org.easymock.tests.DefaultMatcherTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testOverloading(org.easymock.tests.UsageOverloadedMethodTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) Testcase: testNullReturnValue(org.easymock.tests.UsageOverloadedMethodTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) Testcase: testMoreThanOneResultAndOpenCallCount(org.easymock.tests.UsageOverloadedMethodTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) Testcase: testUnexpectedCallWithArray(org.easymock.tests.UsageStrictMockTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testOrderedCallsSucces(org.easymock.tests.UsageStrictMockTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testUnorderedCallsFailure(org.easymock.tests.UsageStrictMockTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testTooManyCallsFailure(org.easymock.tests.UsageStrictMockTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testTooFewCallsFailure(org.easymock.tests.UsageStrictMockTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testDifferentMethods(org.easymock.tests.UsageStrictMockTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testRange(org.easymock.tests.UsageStrictMockTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testDefaultBehavior(org.easymock.tests.UsageStrictMockTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testMockWithNoExpectedCallsPassesWithNoCalls(org.easymock.tests.UsageCallCountTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testMockWithNoExpectedCallsFailsAtFirstCall(org.easymock.tests.UsageCallCountTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testMockWithOneExpectedCallFailsAtVerify(org.easymock.tests.UsageCallCountTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testMockWithOneExpectedCallPassesWithOneCall(org.easymock.tests.UsageCallCountTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testMockWithOneExpectedCallFailsAtSecondCall(org.easymock.tests.UsageCallCountTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testTooFewCalls(org.easymock.tests.UsageCallCountTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testCorrectNumberOfCalls(org.easymock.tests.UsageCallCountTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testTooManyCalls(org.easymock.tests.UsageCallCountTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testNoUpperLimitWithoutCallCountSet(org.easymock.tests.UsageCallCountTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testOverloading(org.easymock.tests.UsageOverloadedDefaultValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) Testcase: testDefaultThrowable(org.easymock.tests.UsageOverloadedDefaultValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) Testcase: testSetInvalidDefaultBooleanReturnValue(org.easymock.tests.RecordStateInvalidDef\ aultReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) Testcase: testSetInvalidDefaultLongReturnValue(org.easymock.tests.RecordStateInvalidDefaul\ tReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) Testcase: testSetInvalidDefaultFloatReturnValue(org.easymock.tests.RecordStateInvalidDefau\ ltReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) Testcase: testSetInvalidDefaultDoubleReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) Testcase: testSetInvalidObjectDefaultReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) Testcase: testExpectAndThrowObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ : Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ : Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ : Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndThrowBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageT\ est): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ : Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ : Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testExpectAndReturnBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetDefaultMatcher(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ : Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetThrowableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetVoidCallableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetMatcher(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetDefaultReturnValueObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetDefaultReturnValueDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetDefaultReturnValueFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetDefaultReturnValueLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetDefaultReturnValueBoolean(org.easymock.tests.ReplayStateInvalidUsageTest)\ : Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetDefaultThrowable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetDefaultVoidCallable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ : Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetThrowableWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetVoidCallableWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ : Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetThrowableWithCount(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetVoidCallableWithCount(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetReturnValueBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetThrowable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testSetVoidCallable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testReplay(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Testcase: testBoolean(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testLong(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testFloat(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testDouble(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testObject(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testBooleanAndRange(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testLongAndRange(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testFloatAndRange(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testDoubleAndRange(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testObjectAndRange(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testBooleanAndCount(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testLongAndCount(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testFloatAndCount(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testDoubleAndCount(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testObjectAndCount(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testBooleanAndMinMax(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testLongAndMinMax(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testFloatAndMinMax(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testDoubleAndMinMax(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testObjectAndMinMax(org.easymock.tests.UsageExpectAndReturnTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndReturnTest.setUp(UsageExpectAndReturnTest.java:\ 16) Testcase: testDefaultReturnValueBoolean(org.easymock.tests.UsageDefaultReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageDefaultReturnValueTest.setUp(UsageDefaultReturnValueTest\ .java:16) Testcase: testDefaultThrowable(org.easymock.tests.UsageDefaultReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageDefaultReturnValueTest.setUp(UsageDefaultReturnValueTest\ .java:16) Testcase: testDefaultReturnValue(org.easymock.tests.UsageDefaultReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageDefaultReturnValueTest.setUp(UsageDefaultReturnValueTest\ .java:16) Testcase: testDefaultVoidCallable(org.easymock.tests.UsageDefaultReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageDefaultReturnValueTest.setUp(UsageDefaultReturnValueTest\ .java:16) Testcase: testExpectedArgumentsDelegatedToMatcher(org.easymock.tests.ArgumentsMatcherTest)\ : Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ArgumentsMatcherTest.setUp(ArgumentsMatcherTest.java:20) Testcase: testExpectedArgumentsDelegatedToMatcher2(org.easymock.tests.ArgumentsMatcherTest\ ): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ArgumentsMatcherTest.setUp(ArgumentsMatcherTest.java:20) Testcase: testErrorString(org.easymock.tests.ArgumentsMatcherTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ArgumentsMatcherTest.setUp(ArgumentsMatcherTest.java:20) Testcase: testSettingTheSameMatcherIsOk(org.easymock.tests.ArgumentsMatcherTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ArgumentsMatcherTest.setUp(ArgumentsMatcherTest.java:20) Testcase: testAbstractMatcher(org.easymock.tests.ArgumentsMatcherTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.ArgumentsMatcherTest.setUp(ArgumentsMatcherTest.java:20) Testcase: testSetInvalidBooleanReturnValue(org.easymock.tests.RecordStateInvalidReturnValu\ eTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testSetInvalidLongReturnValue(org.easymock.tests.RecordStateInvalidReturnValueTe\ st): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testSetInvalidFloatReturnValue(org.easymock.tests.RecordStateInvalidReturnValueT\ est): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testSetInvalidDoubleReturnValue(org.easymock.tests.RecordStateInvalidReturnValue\ Test): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testSetInvalidObjectReturnValue(org.easymock.tests.RecordStateInvalidReturnValue\ Test): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testSetInvalidBooleanReturnValueCount(org.easymock.tests.RecordStateInvalidRetur\ nValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testSetInvalidLongReturnValueCount(org.easymock.tests.RecordStateInvalidReturnVa\ lueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testSetInvalidFloatReturnValueCount(org.easymock.tests.RecordStateInvalidReturnV\ alueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testSetInvalidDoubleReturnValueCount(org.easymock.tests.RecordStateInvalidReturn\ ValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testSetInvalidObjectReturnValueCount(org.easymock.tests.RecordStateInvalidReturn\ ValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testSetReturnValueForVoidMethod(org.easymock.tests.RecordStateInvalidReturnValue\ Test): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.RecordStateInvalidReturnValueTest.setUp(RecordStateInvalidRet\ urnValueTest.java:16) Testcase: testZeroOrMoreNoCalls(org.easymock.tests.UsageRangeTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testZeroOrMoreOneCall(org.easymock.tests.UsageRangeTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testZeroOrMoreThreeCalls(org.easymock.tests.UsageRangeTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testCombination(org.easymock.tests.UsageRangeTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testNoUpperLimit(org.easymock.tests.UsageThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testThrowRuntimeException(org.easymock.tests.UsageThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testThrowSubclassOfRuntimeException(org.easymock.tests.UsageThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testThrowError(org.easymock.tests.UsageThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testThrowSubclassOfError(org.easymock.tests.UsageThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testThrowCheckedException(org.easymock.tests.UsageThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testThrowSubclassOfCheckedException(org.easymock.tests.UsageThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testThrowAfterReturnValue(org.easymock.tests.UsageThrowableTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError Testcase: testMessage(org.easymock.tests.UsageUnorderedTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageUnorderedTest.testMessage(UsageUnorderedTest.java:19) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) Testcase: testReturnByte(org.easymock.tests.UsageLongCompatibleReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageLongCompatibleReturnValueTest.setUp(UsageLongCompatibleR\ eturnValueTest.java:20) Testcase: testReturnShort(org.easymock.tests.UsageLongCompatibleReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageLongCompatibleReturnValueTest.setUp(UsageLongCompatibleR\ eturnValueTest.java:20) Testcase: testReturnChar(org.easymock.tests.UsageLongCompatibleReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageLongCompatibleReturnValueTest.setUp(UsageLongCompatibleR\ eturnValueTest.java:20) Testcase: testReturnInt(org.easymock.tests.UsageLongCompatibleReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageLongCompatibleReturnValueTest.setUp(UsageLongCompatibleR\ eturnValueTest.java:20) Testcase: testReturnLong(org.easymock.tests.UsageLongCompatibleReturnValueTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageLongCompatibleReturnValueTest.setUp(UsageLongCompatibleR\ eturnValueTest.java:20) Testcase: testBoolean(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testLong(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testFloat(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testDouble(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testObject(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testBooleanAndRange(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testLongAndRange(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testFloatAndRange(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testDoubleAndRange(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testObjectAndRange(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testBooleanAndCount(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testLongAndCount(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testFloatAndCount(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testDoubleAndCount(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testObjectAndCount(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testBooleanAndMinMax(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testLongAndMinMax(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testFloatAndMinMax(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testDoubleAndMinMax(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Testcase: testObjectAndMinMax(org.easymock.tests.UsageExpectAndThrowTest): Caused an ERROR junit/framework/AssertionFailedError java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError org.easymock.tests.UsageExpectAndThrowTest.setUp(UsageExpectAndThrowTest.java:17\ ) Test org.easymock.tests.AllTests FAILED /usr/local/java/easymock1.1/nbproject/build-impl.xml:417: Some tests failed; see details above. BUILD FAILED (total time: 4 seconds)</body>
  </mail>
  <mail>
    <header>Re: java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError</header>
    <body>Hi, It's the first time I see this error. On eclipse, the complete easymock test set is running smootly on JDK 1.5. I would suspect a problem with Netbeans JDK 1.5 support... Or maybe a build clean that is not done correctly. Something like that. Because otherwise it doesn't really make sense. Regards, Henri testSetMatcherBeforeCallingMethods(org.easymock.tests.RecordStateInvalidMatcherT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice2(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetSameMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetReturnValueWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetExpectedVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInva\ lidUsageTest):        Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testOpenVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsag\ eTest):       Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueBoolean(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueShort(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueChar(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueInt(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueLong(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueFloat(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueDouble(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueObject(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR an ERROR ERROR an ERROR ERROR testActivateWithoutReturnValue(org.easymock.tests.RecordStateInvalidStateChangeT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testVerifyWithoutActivation(org.easymock.tests.RecordStateInvalidStateChangeTest\ ):    Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testByteReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testShortReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVa\ lueTest):     Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testCharReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testIntReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnValu\ eTest):       Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testLongReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidThrowableTes\ t):   Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowAfterThrowable(org.easymock.tests.RecordStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testSetOpenCallCountTwice(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMinimumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMaximumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetMinimumBiggerThanMaximum(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) an ERROR an ERROR Caused an ERROR Caused an ERROR an ERROR an ERROR ERROR ERROR testDefaultReturnValueBoolean(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueDouble(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueObject(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) Caused an ERROR org.easymock.tests.LegacyBehaviorTests.testThrowAfterThrowable(LegacyBehaviorTes\ ts.java:18) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testSetBooleanReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodC\ allMissingTest):      Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCall\ MissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMis\ singTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMissin\ gTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMetho\ dCallMissingTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMeth\ odCallMissingTest):   Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCallM\ issingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordState\ MethodCallMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethod\ CallMissingTest):     Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) ERROR sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testReturnFloat(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testReturnDouble(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testThrowNull(org.easymock.tests.RecordStateInvalidDefaultThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidDefaultThrowableTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidDefaultThrow\ ableTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) an ERROR an ERROR testFailIfDefaultMatcherSetTwice(org.easymock.tests.DefaultMatcherTest): Caused an ERROR testFailIfDefaultMatcherSetTooLate(org.easymock.tests.DefaultMatcherTest): Caused an ERROR Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testMoreThanOneResultAndOpenCallCount(org.easymock.tests.UsageOverloadedMethodTe\ st):  Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) testMockWithNoExpectedCallsPassesWithNoCalls(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR testMockWithNoExpectedCallsFailsAtFirstCall(org.easymock.tests.UsageCallCountTes\ t):   Caused an ERROR testMockWithOneExpectedCallFailsAtVerify(org.easymock.tests.UsageCallCountTest): Caused an ERROR testMockWithOneExpectedCallPassesWithOneCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR testMockWithOneExpectedCallFailsAtSecondCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR an ERROR Caused an ERROR an ERROR testNoUpperLimitWithoutCallCountSet(org.easymock.tests.UsageCallCountTest): Caused an ERROR Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testDefaultThrowable(org.easymock.tests.UsageOverloadedDefaultValueTest): Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testSetInvalidDefaultBooleanReturnValue(org.easymock.tests.RecordStateInvalidDef\ aultReturnValueTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultLongReturnValue(org.easymock.tests.RecordStateInvalidDefaul\ tReturnValueTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultFloatReturnValue(org.easymock.tests.RecordStateInvalidDefau\ ltReturnValueTest):   Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultDoubleReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidObjectDefaultReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testExpectAndThrowObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageT\ est): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultMatcher(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetThrowableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetVoidCallableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueBoolean(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultThrowable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultVoidCallable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetThrowableWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetVoidCallableWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR</body>
  </mail>
  <mail>
    <header>Re: java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError</header>
    <body>Hi, Well, actually I tested it both from netbeans and using ant and my default 1.5 java jdk (which netbeans uses too). So it should not be netbeans. Also remarkable is the fact that the complete test of junit runs flawlessly. What I am looking for is a way to attack the problem. What can I do to isolate the problem? Maybe I should check the jdk1.5 installation, which is a stock-sun install. (Although the only option I see is changing to a different version of 1.5: I am using version 1.5.0_01 (with _b08 attached for the build and hotSpot client VM). Otherwise, I have no idea how to isolate the problem. Guus. testSetMatcherBeforeCallingMethods(org.easymock.tests.RecordStateInvalidMatcherT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice2(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetSameMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetReturnValueWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetExpectedVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInva\ lidUsageTest):        Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testOpenVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsag\ eTest):       Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueBoolean(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueShort(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueChar(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueInt(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueLong(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueFloat(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueDouble(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueObject(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR an ERROR ERROR an ERROR ERROR testActivateWithoutReturnValue(org.easymock.tests.RecordStateInvalidStateChangeT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testVerifyWithoutActivation(org.easymock.tests.RecordStateInvalidStateChangeTest\ ):    Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testByteReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testShortReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVa\ lueTest):     Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testCharReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testIntReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnValu\ eTest):       Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testLongReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidThrowableTes\ t):   Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowAfterThrowable(org.easymock.tests.RecordStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testSetOpenCallCountTwice(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMinimumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMaximumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetMinimumBiggerThanMaximum(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) an ERROR an ERROR Caused an ERROR Caused an ERROR an ERROR an ERROR ERROR ERROR testDefaultReturnValueBoolean(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueDouble(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueObject(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) Caused an ERROR org.easymock.tests.LegacyBehaviorTests.testThrowAfterThrowable(LegacyBehaviorTes\ ts.java:18) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testSetBooleanReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodC\ allMissingTest):      Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCall\ MissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMis\ singTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMissin\ gTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMetho\ dCallMissingTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMeth\ odCallMissingTest):   Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCallM\ issingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordState\ MethodCallMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethod\ CallMissingTest):     Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) ERROR sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testReturnFloat(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testReturnDouble(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testThrowNull(org.easymock.tests.RecordStateInvalidDefaultThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidDefaultThrowableTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidDefaultThrow\ ableTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) an ERROR an ERROR testFailIfDefaultMatcherSetTwice(org.easymock.tests.DefaultMatcherTest): Caused an ERROR testFailIfDefaultMatcherSetTooLate(org.easymock.tests.DefaultMatcherTest): Caused an ERROR Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testMoreThanOneResultAndOpenCallCount(org.easymock.tests.UsageOverloadedMethodTe\ st):  Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) testMockWithNoExpectedCallsPassesWithNoCalls(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR testMockWithNoExpectedCallsFailsAtFirstCall(org.easymock.tests.UsageCallCountTes\ t):   Caused an ERROR testMockWithOneExpectedCallFailsAtVerify(org.easymock.tests.UsageCallCountTest): Caused an ERROR testMockWithOneExpectedCallPassesWithOneCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR testMockWithOneExpectedCallFailsAtSecondCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR an ERROR Caused an ERROR an ERROR testNoUpperLimitWithoutCallCountSet(org.easymock.tests.UsageCallCountTest): Caused an ERROR Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testDefaultThrowable(org.easymock.tests.UsageOverloadedDefaultValueTest): Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testSetInvalidDefaultBooleanReturnValue(org.easymock.tests.RecordStateInvalidDef\ aultReturnValueTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultLongReturnValue(org.easymock.tests.RecordStateInvalidDefaul\ tReturnValueTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultFloatReturnValue(org.easymock.tests.RecordStateInvalidDefau\ ltReturnValueTest):   Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultDoubleReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidObjectDefaultReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testExpectAndThrowObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageT\ est): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultMatcher(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetThrowableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetVoidCallableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueBoolean(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultThrowable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultVoidCallable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetThrowableWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetVoidCallableWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR -- A.J. Bonnema, Leiden The Netherlands, user #328198 (Linux Counter</body>
  </mail>
  <mail>
    <header>Re: java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError</header>
    <body>Which easymock version are you using? When you launch with ant, you mean the easymock unit tests or your own? testSetMatcherBeforeCallingMethods(org.easymock.tests.RecordStateInvalidMatcherT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice2(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetSameMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetReturnValueWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetExpectedVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInva\ lidUsageTest):        Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testOpenVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsag\ eTest):       Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueBoolean(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueShort(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueChar(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueInt(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueLong(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueFloat(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueDouble(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueObject(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Caused an ERROR Caused an ERROR testHashCodeBeforeActivation(org.easymock.tests.ObjectMethodsTest):   Caused an ERROR Caused an ERROR testToStringBeforeActivation(org.easymock.tests.ObjectMethodsTest):   Caused an ERROR Caused an ERROR Caused an ERROR ERROR Caused an ERROR ERROR testActivateWithoutReturnValue(org.easymock.tests.RecordStateInvalidStateChangeT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testVerifyWithoutActivation(org.easymock.tests.RecordStateInvalidStateChangeTest\ ):    Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testByteReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testShortReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVa\ lueTest):     Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testCharReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testIntReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnValu\ eTest):       Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testLongReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidThrowableTes\ t):   Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowAfterThrowable(org.easymock.tests.RecordStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testSetOpenCallCountTwice(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMinimumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMaximumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetMinimumBiggerThanMaximum(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR ERROR ERROR testDefaultReturnValueBoolean(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueFloat(org.easymock.tests.NiceMockControlTest):  Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueDouble(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueObject(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) Caused an ERROR org.easymock.tests.LegacyBehaviorTests.testThrowAfterThrowable(LegacyBehaviorTes\ ts.java:18) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testSetBooleanReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodC\ allMissingTest):      Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCall\ MissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMis\ singTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMissin\ gTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMetho\ dCallMissingTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMeth\ odCallMissingTest):   Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCallM\ issingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordState\ MethodCallMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethod\ CallMissingTest):     Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) ERROR sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testReturnFloat(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testReturnDouble(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testThrowNull(org.easymock.tests.RecordStateInvalidDefaultThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidDefaultThrowableTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidDefaultThrow\ ableTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) testFailIfDefaultMatcherSetTwice(org.easymock.tests.DefaultMatcherTest): Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) testFailIfDefaultMatcherSetTooLate(org.easymock.tests.DefaultMatcherTest): Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testMoreThanOneResultAndOpenCallCount(org.easymock.tests.UsageOverloadedMethodTe\ st):  Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testUnexpectedCallWithArray(org.easymock.tests.UsageStrictMockTest):  Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) testMockWithNoExpectedCallsPassesWithNoCalls(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithNoExpectedCallsFailsAtFirstCall(org.easymock.tests.UsageCallCountTes\ t):   Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallFailsAtVerify(org.easymock.tests.UsageCallCountTest): Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallPassesWithOneCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallFailsAtSecondCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testNoUpperLimitWithoutCallCountSet(org.easymock.tests.UsageCallCountTest): Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testOverloading(org.easymock.tests.UsageOverloadedDefaultValueTest):  Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testDefaultThrowable(org.easymock.tests.UsageOverloadedDefaultValueTest): Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testSetInvalidDefaultBooleanReturnValue(org.easymock.tests.RecordStateInvalidDef\ aultReturnValueTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultLongReturnValue(org.easymock.tests.RecordStateInvalidDefaul\ tReturnValueTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultFloatReturnValue(org.easymock.tests.RecordStateInvalidDefau\ ltReturnValueTest):   Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultDoubleReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidObjectDefaultReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testExpectAndThrowObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageT\ est): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultMatcher(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetThrowableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetVoidCallableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueBoolean(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultThrowable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultVoidCallable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR</body>
  </mail>
  <mail>
    <header>Re: java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError</header>
    <body>I have found the same problem with easymock 1.1 and 1.2. Both appear to display the same behaviour. I use the build.xml of easymock. But the same problem occurs both in the easymock builds and my own projects. In the meantime I switched back to 1.4, because I just couldn't get any work done with 1.5. Guus. testSetMatcherBeforeCallingMethods(org.easymock.tests.RecordStateInvalidMatcherT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice2(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetSameMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetReturnValueWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetExpectedVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInva\ lidUsageTest):        Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testOpenVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsag\ eTest):       Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueBoolean(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueShort(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueChar(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueInt(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueLong(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueFloat(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueDouble(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueObject(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) Caused an ERROR Caused an ERROR testHashCodeBeforeActivation(org.easymock.tests.ObjectMethodsTest):   Caused an ERROR Caused an ERROR testToStringBeforeActivation(org.easymock.tests.ObjectMethodsTest):   Caused an ERROR Caused an ERROR Caused an ERROR ERROR Caused an ERROR ERROR testActivateWithoutReturnValue(org.easymock.tests.RecordStateInvalidStateChangeT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testVerifyWithoutActivation(org.easymock.tests.RecordStateInvalidStateChangeTest\ ):    Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testByteReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testShortReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVa\ lueTest):     Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testCharReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testIntReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnValu\ eTest):       Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testLongReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidThrowableTes\ t):   Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowAfterThrowable(org.easymock.tests.RecordStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testSetOpenCallCountTwice(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMinimumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMaximumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetMinimumBiggerThanMaximum(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR ERROR ERROR testDefaultReturnValueBoolean(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueFloat(org.easymock.tests.NiceMockControlTest):  Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueDouble(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueObject(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) Caused an ERROR org.easymock.tests.LegacyBehaviorTests.testThrowAfterThrowable(LegacyBehaviorTes\ ts.java:18) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testSetBooleanReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodC\ allMissingTest):      Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCall\ MissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMis\ singTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMissin\ gTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMetho\ dCallMissingTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMeth\ odCallMissingTest):   Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCallM\ issingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordState\ MethodCallMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethod\ CallMissingTest):     Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) ERROR sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testReturnFloat(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testReturnDouble(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testThrowNull(org.easymock.tests.RecordStateInvalidDefaultThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidDefaultThrowableTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidDefaultThrow\ ableTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) testFailIfDefaultMatcherSetTwice(org.easymock.tests.DefaultMatcherTest): Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) testFailIfDefaultMatcherSetTooLate(org.easymock.tests.DefaultMatcherTest): Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testMoreThanOneResultAndOpenCallCount(org.easymock.tests.UsageOverloadedMethodTe\ st):  Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testUnexpectedCallWithArray(org.easymock.tests.UsageStrictMockTest):  Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) testMockWithNoExpectedCallsPassesWithNoCalls(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithNoExpectedCallsFailsAtFirstCall(org.easymock.tests.UsageCallCountTes\ t):   Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallFailsAtVerify(org.easymock.tests.UsageCallCountTest): Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallPassesWithOneCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallFailsAtSecondCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testNoUpperLimitWithoutCallCountSet(org.easymock.tests.UsageCallCountTest): Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testOverloading(org.easymock.tests.UsageOverloadedDefaultValueTest):  Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testDefaultThrowable(org.easymock.tests.UsageOverloadedDefaultValueTest): Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testSetInvalidDefaultBooleanReturnValue(org.easymock.tests.RecordStateInvalidDef\ aultReturnValueTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultLongReturnValue(org.easymock.tests.RecordStateInvalidDefaul\ tReturnValueTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultFloatReturnValue(org.easymock.tests.RecordStateInvalidDefau\ ltReturnValueTest):   Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultDoubleReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidObjectDefaultReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testExpectAndThrowObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageT\ est): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultMatcher(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetThrowableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetVoidCallableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueBoolean(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultThrowable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultVoidCallable(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR -- A.J. Bonnema, Leiden The Netherlands, user #328198 (Linux Counter</body>
  </mail>
  <mail>
    <header>Re: java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError</header>
    <body>I am deeply sorry but absolutly unable to reproduce your problem. Everything is running fine here when compiled and ran with JDK 1.5... so I have no idea what you can do. Somebody have an idea? message. testSetMatcherBeforeCallingMethods(org.easymock.tests.RecordStateInvalidMatcherT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice2(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetSameMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetReturnValueWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetExpectedVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInva\ lidUsageTest):        Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testOpenVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsag\ eTest):       Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueBoolean(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueShort(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueChar(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueInt(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueLong(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueFloat(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueDouble(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueObject(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testEqualsBeforeActivation(org.easymock.tests.ObjectMethodsTest):     Caused an ERROR org.easymock.tests.ObjectMethodsTest.setUp(ObjectMethodsTest.java:22) Caused an ERROR org.easymock.tests.ObjectMethodsTest.setUp(ObjectMethodsTest.java:22) testHashCodeBeforeActivation(org.easymock.tests.ObjectMethodsTest):   Caused an ERROR org.easymock.tests.ObjectMethodsTest.setUp(ObjectMethodsTest.java:22) testHashCodeAfterActivation(org.easymock.tests.ObjectMethodsTest):    Caused an ERROR org.easymock.tests.ObjectMethodsTest.setUp(ObjectMethodsTest.java:22) testToStringBeforeActivation(org.easymock.tests.ObjectMethodsTest):   Caused an ERROR org.easymock.tests.ObjectMethodsTest.setUp(ObjectMethodsTest.java:22) testToStringAfterActivation(org.easymock.tests.ObjectMethodsTest):    Caused an ERROR org.easymock.tests.ObjectMethodsTest.setUp(ObjectMethodsTest.java:22) Caused an ERROR org.easymock.tests.ObjectMethodsTest.setUp(ObjectMethodsTest.java:22) ERROR Caused an ERROR ERROR testActivateWithoutReturnValue(org.easymock.tests.RecordStateInvalidStateChangeT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testVerifyWithoutActivation(org.easymock.tests.RecordStateInvalidStateChangeTest\ ):    Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testByteReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testShortReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVa\ lueTest):     Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testCharReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testIntReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnValu\ eTest):       Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testLongReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testThrowNull(org.easymock.tests.RecordStateInvalidThrowableTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidThrowableTes\ t):   Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowAfterThrowable(org.easymock.tests.RecordStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testSetOpenCallCountTwice(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMinimumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMaximumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetMinimumBiggerThanMaximum(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR ERROR ERROR testDefaultReturnValueBoolean(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueFloat(org.easymock.tests.NiceMockControlTest):  Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueDouble(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueObject(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) Caused an ERROR org.easymock.tests.LegacyBehaviorTests.testThrowAfterThrowable(LegacyBehaviorTes\ ts.java:18) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testSetBooleanReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodC\ allMissingTest):      Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCall\ MissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMis\ singTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMissin\ gTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMetho\ dCallMissingTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMeth\ odCallMissingTest):   Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCallM\ issingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordState\ MethodCallMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethod\ CallMissingTest):     Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) ERROR org.easymock.tests.MockNameTest.testDefaultName(MockNameTest.java:16) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testReturnFloat(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testReturnDouble(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testThrowNull(org.easymock.tests.RecordStateInvalidDefaultThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidDefaultThrowableTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidDefaultThrow\ ableTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) testFailIfDefaultMatcherSetTwice(org.easymock.tests.DefaultMatcherTest): Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) testFailIfDefaultMatcherSetTooLate(org.easymock.tests.DefaultMatcherTest): Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testNullReturnValue(org.easymock.tests.UsageOverloadedMethodTest):    Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testMoreThanOneResultAndOpenCallCount(org.easymock.tests.UsageOverloadedMethodTe\ st):  Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testUnexpectedCallWithArray(org.easymock.tests.UsageStrictMockTest):  Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) testUnorderedCallsFailure(org.easymock.tests.UsageStrictMockTest):    Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) testMockWithNoExpectedCallsPassesWithNoCalls(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithNoExpectedCallsFailsAtFirstCall(org.easymock.tests.UsageCallCountTes\ t):   Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallFailsAtVerify(org.easymock.tests.UsageCallCountTest): Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallPassesWithOneCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallFailsAtSecondCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testNoUpperLimitWithoutCallCountSet(org.easymock.tests.UsageCallCountTest): Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testOverloading(org.easymock.tests.UsageOverloadedDefaultValueTest):  Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testDefaultThrowable(org.easymock.tests.UsageOverloadedDefaultValueTest): Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testSetInvalidDefaultBooleanReturnValue(org.easymock.tests.RecordStateInvalidDef\ aultReturnValueTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultLongReturnValue(org.easymock.tests.RecordStateInvalidDefaul\ tReturnValueTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultFloatReturnValue(org.easymock.tests.RecordStateInvalidDefau\ ltReturnValueTest):   Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultDoubleReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidObjectDefaultReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testExpectAndThrowObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageT\ est): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultMatcher(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetThrowableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetVoidCallableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR</body>
  </mail>
  <mail>
    <header>Re: java.lang.NoClassDefFoundError: junit/framework/AssertionFailedError</header>
    <body>Henri, Thank you for testing. If you have no problems, then the problem must be a configuration issue. So, what I will do is reinstall java, completely. Also, I will test from a different location (on a windows machine), see if that helps. This will take some time though, because the machine is not mine and I will have to get permission to install java, easymock etc. I suspect there is very little you can do. Any way, thanks for your help and advice. I will get back to you when I have solved this issue. Guus. message. testSetMatcherBeforeCallingMethods(org.easymock.tests.RecordStateInvalidMatcherT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetMatcherTwice2(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetSameMatcherTwice(org.easymock.tests.RecordStateInvalidMatcherTest): Caused an ERROR org.easymock.tests.RecordStateInvalidMatcherTest.setUp(RecordStateInvalidMatcher\ Test.java:16) testSetReturnValueWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetExpectedVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInva\ lidUsageTest):        Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testOpenVoidCallCountWithoutMethodCall(org.easymock.tests.RecordStateInvalidUsag\ eTest):       Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueBoolean(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueShort(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueChar(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueInt(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueLong(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueFloat(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueDouble(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testSetWrongReturnValueObject(org.easymock.tests.RecordStateInvalidUsageTest): Caused an ERROR org.easymock.tests.RecordStateInvalidUsageTest.setUp(RecordStateInvalidUsageTest\ .java:17) testEqualsBeforeActivation(org.easymock.tests.ObjectMethodsTest):     Caused an ERROR Caused an ERROR testHashCodeBeforeActivation(org.easymock.tests.ObjectMethodsTest):   Caused an ERROR testHashCodeAfterActivation(org.easymock.tests.ObjectMethodsTest):    Caused an ERROR testToStringBeforeActivation(org.easymock.tests.ObjectMethodsTest):   Caused an ERROR testToStringAfterActivation(org.easymock.tests.ObjectMethodsTest):    Caused an ERROR Caused an ERROR ERROR Caused an ERROR ERROR testActivateWithoutReturnValue(org.easymock.tests.RecordStateInvalidStateChangeT\ est): Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testVerifyWithoutActivation(org.easymock.tests.RecordStateInvalidStateChangeTest\ ):    Caused an ERROR org.easymock.tests.RecordStateInvalidStateChangeTest.setUp(RecordStateInvalidSta\ teChangeTest.java:16) testByteReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testShortReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVa\ lueTest):     Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testCharReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testIntReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnValu\ eTest):       Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testLongReturningValue(org.easymock.tests.NiceMockControlLongCompatibleReturnVal\ ueTest):      Caused an ERROR org.easymock.tests.NiceMockControlLongCompatibleReturnValueTest.setUp(NiceMockCo\ ntrolLongCompatibleReturnValueTest.java:17) testThrowNull(org.easymock.tests.RecordStateInvalidThrowableTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidThrowableTes\ t):   Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testThrowAfterThrowable(org.easymock.tests.RecordStateInvalidThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidThrowableTest.setUp(RecordStateInvalidThrow\ ableTest.java:22) testSetOpenCallCountTwice(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMinimumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetIllegalMaximumCount(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) testSetMinimumBiggerThanMaximum(org.easymock.tests.RecordStateInvalidRangeTest): Caused an ERROR org.easymock.tests.RecordStateInvalidRangeTest.setUp(RecordStateInvalidRangeTest\ .java:17) Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR Caused an ERROR ERROR ERROR testDefaultReturnValueBoolean(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueFloat(org.easymock.tests.NiceMockControlTest):  Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueDouble(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) testDefaultReturnValueObject(org.easymock.tests.NiceMockControlTest): Caused an ERROR org.easymock.tests.NiceMockControlTest.setUp(NiceMockControlTest.java:16) Caused an ERROR org.easymock.tests.LegacyBehaviorTests.testThrowAfterThrowable(LegacyBehaviorTes\ ts.java:18) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testSetBooleanReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodC\ allMissingTest):      Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCall\ MissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMis\ singTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCallMissin\ gTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMetho\ dCallMissingTest):    Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMeth\ odCallMissingTest):   Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectReturnValueCountWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetVoidCallableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCa\ llMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetThrowableCountWithoutMethodCall(org.easymock.tests.RecordStateMethodCallM\ issingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetBooleanDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordState\ MethodCallMissingTest):       Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetLongDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMet\ hodCallMissingTest):  Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetFloatDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateMe\ thodCallMissingTest): Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDoubleDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetObjectDefaultReturnValueWithoutMethodCall(org.easymock.tests.RecordStateM\ ethodCallMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultVoidCallableWithoutMethodCall(org.easymock.tests.RecordStateMethod\ CallMissingTest):     Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) testSetDefaultThrowableWithoutMethodCall(org.easymock.tests.RecordStateMethodCal\ lMissingTest):        Caused an ERROR org.easymock.tests.RecordStateMethodCallMissingTest.setUp(RecordStateMethodCallM\ issingTest.java:16) ERROR sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) testReturnFloat(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testReturnDouble(org.easymock.tests.UsageFloatingPointReturnValueTest): Caused an ERROR org.easymock.tests.UsageFloatingPointReturnValueTest.setUp(UsageFloatingPointRet\ urnValueTest.java:20) testThrowNull(org.easymock.tests.RecordStateInvalidDefaultThrowableTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowCheckedExceptionWhereNoCheckedExceptionIsThrown(org.easymock.tests.Reco\ rdStateInvalidDefaultThrowableTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) testThrowWrongCheckedException(org.easymock.tests.RecordStateInvalidDefaultThrow\ ableTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultThrowableTest.setUp(RecordStateInval\ idDefaultThrowableTest.java:21) Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) testFailIfDefaultMatcherSetTwice(org.easymock.tests.DefaultMatcherTest): Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) testFailIfDefaultMatcherSetTooLate(org.easymock.tests.DefaultMatcherTest): Caused an ERROR org.easymock.tests.DefaultMatcherTest.setUp(DefaultMatcherTest.java:22) Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testNullReturnValue(org.easymock.tests.UsageOverloadedMethodTest):    Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testMoreThanOneResultAndOpenCallCount(org.easymock.tests.UsageOverloadedMethodTe\ st):  Caused an ERROR org.easymock.tests.UsageOverloadedMethodTest.setUp(UsageOverloadedMethodTest.jav\ a:17) testUnexpectedCallWithArray(org.easymock.tests.UsageStrictMockTest):  Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) testUnorderedCallsFailure(org.easymock.tests.UsageStrictMockTest):    Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) Caused an ERROR org.easymock.tests.UsageStrictMockTest.setUp(UsageStrictMockTest.java:17) testMockWithNoExpectedCallsPassesWithNoCalls(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithNoExpectedCallsFailsAtFirstCall(org.easymock.tests.UsageCallCountTes\ t):   Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallFailsAtVerify(org.easymock.tests.UsageCallCountTest): Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallPassesWithOneCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testMockWithOneExpectedCallFailsAtSecondCall(org.easymock.tests.UsageCallCountTe\ st):  Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testNoUpperLimitWithoutCallCountSet(org.easymock.tests.UsageCallCountTest): Caused an ERROR org.easymock.tests.UsageCallCountTest.setUp(UsageCallCountTest.java:22) testOverloading(org.easymock.tests.UsageOverloadedDefaultValueTest):  Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testDefaultThrowable(org.easymock.tests.UsageOverloadedDefaultValueTest): Caused an ERROR org.easymock.tests.UsageOverloadedDefaultValueTest.setUp(UsageOverloadedDefaultV\ alueTest.java:16) testSetInvalidDefaultBooleanReturnValue(org.easymock.tests.RecordStateInvalidDef\ aultReturnValueTest): Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultLongReturnValue(org.easymock.tests.RecordStateInvalidDefaul\ tReturnValueTest):    Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultFloatReturnValue(org.easymock.tests.RecordStateInvalidDefau\ ltReturnValueTest):   Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidDefaultDoubleReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testSetInvalidObjectDefaultReturnValue(org.easymock.tests.RecordStateInvalidDefa\ ultReturnValueTest):  Caused an ERROR org.easymock.tests.RecordStateInvalidDefaultReturnValueTest.setUp(RecordStateInv\ alidDefaultReturnValueTest.java:16) testExpectAndThrowObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndThrowBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageT\ est): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithCount(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithCount(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithCount(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithCount(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObjectWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDoubleWithRange(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloatWithRange(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLongWithRange(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBooleanWithRange(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnLong(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testExpectAndReturnBoolean(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultMatcher(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueObjectWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueDoubleWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTes\ t):   Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueFloatWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest\ ):    Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueLongWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest)\ :     Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetReturnValueBooleanWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTe\ st):  Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetThrowableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetVoidCallableWithMinMax(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueObject(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueDouble(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR org.easymock.tests.ReplayStateInvalidUsageTest.setUp(ReplayStateInvalidUsageTest\ .java:22) testSetDefaultReturnValueFloat(org.easymock.tests.ReplayStateInvalidUsageTest): Caused an ERROR -- A.J. Bonnema, Leiden The Netherlands, user #328198 (Linux Counter</body>
  </mail>
  <mail>
    <header>Re: Checking the ordering of method calls between separate mocks</header>
    <body>Hello, sorry to take so long to respond, there did not seem to be any initial interest and I have not checked the messages in a while. I would be glad to give the source to EasyMock as a seed idea or to complete and refine. Otherwise I could just send it to anyone that has not found a simpler approach and still needs it. Just let me know. I needed it initially to handle a situation such as I use EasyMock almost daily and would be glad to contribute back in some small way. thanks, Jake different want to</body>
  </mail>
  <mail>
    <header>Calling verify</header>
    <body>In a test case I genereate a lot of mock objects calling a method that takes care of instantiating the mock. It could be something like this: Now after I have called the method under test I want to call verify on each object, but I do not have any reference to the objects. How do I solve that problem? Regards, Thomas</body>
  </mail>
  <mail>
    <header>Re: New file uploaded to easymock</header>
    <body>Am Dienstag, 04.01.05 um 21:35 Uhr schrieb Henri Tremblay: Yes, it is. EasyMock 1.2 will be released in two versions, one for Java 1.3.1 to 1.4.x and one for Java 5.0. - Tammo</body>
  </mail>
  <mail>
    <header>RE: Implementing custom stubs in EasyMock</header>
    <body>I'd probably prefer the former solution. It might not be as straightforward, but I think it would make for simpler code - both in making my testing code simpler and in decoupling my production code from a less than ideally designed thirdparty library. I had to be there to be sure, though - and your mileage may certainly vary. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Sudhakar Barua is out of the office.</header>
    <body>I will be out of the office starting  01/18/2005 and will not return until 02/01/2005. Please contact suma.raju@... for Whistler related work and avijit.chowdhuri@... for SCE related work. Please also cc: Girish.Kamath@... Regards, Sudhakar Barua</body>
  </mail>
  <mail>
    <header>Checking the ordering of method calls between separate mocks</header>
    <body>Is it currently possible to check the ordering of method calls between separate mocks? For example: // this is the required order // but this would still pass, does not check ordering between mocks // perform test</body>
  </mail>
  <mail>
    <header>Re: Checking the ordering of method calls between separate mocks</header>
    <body>Unfortunatly, it is not possible at this point no. The usual workaround is to have a test interface extending the tested one:</body>
  </mail>
  <mail>
    <header>Re: New file uploaded to easymock</header>
    <body>Currently, AOP is not considered. The reason is that I want easymock to be as easy to use as possible. With AOP, users need to add post compilation process to apply the aspect or JVM params when they launch their tests. I found this too intrusive but maybe I'll develop a version using it to let the choice later. But AOP is no silver bullet. But class extension 1.2 will be able to handle most limitations of the current 1.1 version. Cheers, Henri On Tue, 18 Jan 2005 10:43:50 +0800, Tang kun</body>
  </mail>
  <mail>
    <header>Re: Checking the ordering of method calls between separate mocks</header>
    <body>That is a good workaround that I had not thought of. Thanks. I wanted to use it with the interfaces java.sql.Connection and java.sql.PreparedStatement (and some of the other JDBC interfaces). Unfortunately, the interfaces contain the same method, but with different return types, so it did not work in this case. interface java.sql.Connection public DatabaseMetaData getMetaData() interface java.sql.PreparedStatement public ResultSetMetaData getMetaData() Last weekend I wrote an extension class that allows the combining of MockControls and it works for this case. If you would be interested, I would gladly contribute it. It works by splitting the proxy invocations, one to the original MockControl that keeps track of the method call ordering as usual, and one to the combined control that keeps track of the order of the proxies the calls originated from. Currently the extension implementation is very simple and does not support setting the expected call count. However, other functionality could be added by wrapping the MockControls that are created and listening to some of the methods that set the expected call counts, etc. (I plan on doing this as time allows, but I am sure that someone more familiar with the mock control internals could do it better/faster). The combined control would be very similar to the mock control internally but be concerned with which proxies the calls originate from and forwarding the calls to the original mock control to keep track of methods called. here is the usage: The workaround you gave is simpler and cleaner, and I would use it as a first resort, but this could be available when required.</body>
  </mail>
  <mail>
    <header>Problem using EasyMock Class Extension 1.1</header>
    <body>-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 I am trying to use the Class Extension, and am getting the following error: java.lang.NoClassDefFoundError: net/sf/cglib/proxy/Callback at org.easymock.classextension.MockClassControl.&amp;lt;init&amp;gt;(MockClassControl.j ava:356) at org.easymock.classextension.MockClassControl.&amp;lt;init&amp;gt;(MockClassControl.j ava:367) at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:216) at com.aptas.papyrus.DocumentBuilderTest.setUp (DocumentBuilderTest.java:82) at com.intellij.rt.execution.junit2.JUnitStarter.main (JUnitStarter.java:31) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:25) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:78) I have cglib-1.1-RC1.jar in my classpath, but there is no such class there.  I looked at cglib-1.0, and it is not there either. What do I need to do to make this work? - -- Jim McMaster mailto:jim.mcmaster@... -----BEGIN PGP SIGNATURE----- Version: PGP 8.1 iQA/AwUBQf+4r2aP5l7/atSJEQIxVgCeMnWiS4xiGq7nSShejjrjlIVWY8YAoNU4 GSNgl2HmYIfI86v2gDCvRlmn =gnWv -----END PGP SIGNATURE-----</body>
  </mail>
  <mail>
    <header>RE: Problem using EasyMock Class Extension 1.1</header>
    <body>-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 On Tuesday, February 01, 2005 10:29 AM, David Chelimsky Indeed it does.  I thought I was downloading the latest cglib from SourceForge, but I did not scroll down far enough.  I apologize (red-faced) for bothering you. - -- Jim McMaster mailto:jim.mcmaster@... -----BEGIN PGP SIGNATURE----- Version: PGP 8.1 iQA/AwUBQf/EoWaP5l7/atSJEQJ9IACfacljHbsG9jTSOqEDktTs+YLtRhsAoK7M qngU8Uf9cZjDoHVBUp0UMNjy =tZ3f -----END PGP SIGNATURE-----</body>
  </mail>
  <mail>
    <header>EasyMock 1.2 RC and EasyMock Class Extension 1.2 RC available</header>
    <body>Hello all, release candidates of EasyMock 1.2 are available on SourceForge:  - EasyMock is released in two versions: One for - stack traces are now only cut if the exception is thrown from EasyMock - convenience methods expectAndDefaultReturn() and expectAndDefaultThrow() - hashCode() implementation is changed for better performance - added Clover coverage reports A release candidate of Henri Tremblay's EasyMock Class Extension is available as well. - equals, hashCode and toString are now always   defaulted (not only when not overloaded from Object) - can mock any classes except final classes on Sun JVM - new simpler interface - fix of equals sometimes wrongly returning false when doing this.equals(this) - samples added - tests having 100% clover coverage added - documentation dedicated to the class extension - clean-up javadoc - Tammo Freese</body>
  </mail>
  <mail>
    <header>RE: EasyMock 1.2 RC and EasyMock Class Extension 1.2 RC available</header>
    <body>The 1.3+ version doesn't show up per default on sf, you need to click on the "View ALL project files" link. You might want to make them two separate packages... Regards, Ilja</body>
  </mail>
  <mail>
    <header>Easymock 1.2 requires clover?</header>
    <body>I downloaded the 1.2 release candidate to try it out, and I got the following error... Am I doing something wrong?  Is there a way I can run it without clover? Thanks [CLOVER] FATAL ERROR: Clover could not be initialised. Are you sure you have Clover in the runtime classpath? (class java.lang.NoClassDefFoundError:com_cenqua_clover/CloverVersionInfo) E.E.E.E Time: 0.621 There were 4 errors: 1) testCommandPerformed1(com.ibm.itim.ui.listener.LoginListenerTest) java.lang.NoClassDefFoundError: com_cenqua_clover/g at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:51) at com.ibm.itim.ui.listener.ListenerTest.setUp (ListenerTest.java:85) at com.ibm.itim.ui.listener.LoginListenerTest.setUp (LoginListenerTest.java:53) at com.ibm.itim.ui.listener.LoginListenerTest.main (LoginListenerTest.java:45) 2) testCommandPerformed2(com.ibm.itim.ui.listener.LoginListenerTest) java.lang.NoClassDefFoundError: com_cenqua_clover/g at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:51) at com.ibm.itim.ui.listener.ListenerTest.setUp (ListenerTest.java:85) at com.ibm.itim.ui.listener.LoginListenerTest.setUp (LoginListenerTest.java:53) at com.ibm.itim.ui.listener.LoginListenerTest.main (LoginListenerTest.java:45) 3) testCommandPerformed3(com.ibm.itim.ui.listener.LoginListenerTest) java.lang.NoClassDefFoundError: com_cenqua_clover/g at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:51) at com.ibm.itim.ui.listener.ListenerTest.setUp (ListenerTest.java:85) at com.ibm.itim.ui.listener.LoginListenerTest.setUp (LoginListenerTest.java:53) at com.ibm.itim.ui.listener.LoginListenerTest.main (LoginListenerTest.java:45) 4) testCommandPerformed4(com.ibm.itim.ui.listener.LoginListenerTest) java.lang.NoClassDefFoundError: com_cenqua_clover/g at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:51) at com.ibm.itim.ui.listener.ListenerTest.setUp (ListenerTest.java:85) at com.ibm.itim.ui.listener.LoginListenerTest.setUp (LoginListenerTest.java:53) at com.ibm.itim.ui.listener.LoginListenerTest.main (LoginListenerTest.java:45) FAILURES!!! Tests run: 4,  Failures: 0,  Errors: 4</body>
  </mail>
  <mail>
    <header>Re: Easymock 1.2 requires clover?</header>
    <body>Arg! It shouldn't! Unless I've did a terrible mistake in my build that mean the current RC is clover instrumentized... Which might be the case :-( Learning something the hard way here... If you're eager to use it, you can recompile the sources (src.zip) included in the version to get a correct jar. I'll try to fix that asap and see with Tammo when he can do the re-release (worst case I'll post it on the yahoo group). Really sorry about that, Henri</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. You can access this file at the URL:  To learn more about file sharing for your group, please visit:  Regards,</body>
  </mail>
  <mail>
    <header>Good question. I'd like to know, too.</header>
    <body>This is a good question. If you do this: you get this: java.lang.IllegalArgumentException: No visible constructors in class java.net.NetworkInterface In addition, are there implications with final classes in general? NetworkInterface, create</body>
  </mail>
  <mail>
    <header>Re: Good question. I'd like to know, too.</header>
    <body>It's not possible to mock final classes (even with version 1.2RC available on sourceforge). However it is to mock a class without visible constructor. With version 1.2RC and cglib-2.1-dev.</body>
  </mail>
  <mail>
    <header>Re: Checking the ordering of method calls between separate mocks</header>
    <body>Hi, I'm starting with TDD and I use easymock really often. I've just one problem that occurs often and I can't handle it with easymock. I think it is very similar to the one discussed here but in my case the mocks are of the same interface so this: doesn't work. I think the solution tms54x showed could handle my problem: Where can I get the discribed MockControlCombiner (tms54x, will you please mail it to me)? Or is there another way of handling the problem (checking the ordering of calls between seperate mocks of the same interface)? Please help me... As I am new to this stuff it is possible that I forgot about a simple solution - in this case sorry. thanks, Marco Domay</body>
  </mail>
  <mail>
    <header>Re: Re: Checking the ordering of method calls between separate mocks</header>
    <body>Just wondering: Did you consider something like: ? (A dynamic proxy can implement several interfaces, and I don't think Control needs to know which interface is currently being used) ~Johannes</body>
  </mail>
  <mail>
    <header>Re: Re: Checking the ordering of method calls between separate mocks</header>
    <body>We didn't so far, but not a bad idea. To put on the todo list from my point of view. Thanks for the feedback Tammo, what do you think? - Henri</body>
  </mail>
  <mail>
    <header>Re: Re: Checking the ordering of method calls between separate mocks</header>
    <body>Why doesn't it work? I just tried this: Works perfectly. And if I swap method1 and method2 during the replay, it fails as expected. I agree it's some kind of trick to create a new interface extending the others, but still from my point of view it's working perfectly. What is the issue? - Henri</body>
  </mail>
  <mail>
    <header>Re: Checking the ordering of method calls between separate mocks</header>
    <body>Thank you for the fast reply! I agree that your solution to the problem works if there are different interfaces A and B (with different methods), but in my case I want to test my object A that has three collaborators that implement the inteface IB. I want to check if A is calling the same method on its collaborators B1, B2, B3 in the correct order. Using hand-written mocks or better dummies I use the LogString pattern. I am now searching a solution for this problem using easymock. I hope my problem is clear now and I am thankful for tipps and hints. thanks Marco problem:</body>
  </mail>
  <mail>
    <header>Re: Re: Checking the ordering of method calls between separate mocks</header>
    <body>Yeah, that would be trickier. In that case, I think I would've resorted to either hand-coded mocks myself. Another option is jMock, though. It's dynamic and provides a (clumsy) mechanism for specifying order between different mocks. I still don't see why tms54x's solution wouldn't work, though: Did you try this? Or a variation of the same (I'm thinking "A a1 = combinedCtrl.createMock(A.class)"). ~Johannes</body>
  </mail>
  <mail>
    <header>Re: Re: Checking the ordering of method calls between separate mocks</header>
    <body>Indeed, I don't see how your problem can be currently solved with easymock. Since it's always the same interface, you can record all the calls in one interface. You will be sure that way that all the calls are done and in order. But you won't be able to know if they are done on the expected implementation (unless the arguments passed to each implementation are different). The MockControlCombiner is on my todo list. I think it can be useful in some collaboration cases like this one. But I have no idea when we could be able to develop it. - Henri</body>
  </mail>
  <mail>
    <header>An experiment in call recording</header>
    <body>Hello out there! I've implemented a first stab at a recorder for method calls on multiple objects. Calls and objects encountered as arguments and return values are stored and can be replayed (not re-executed). The only current replay Output writes out Java code that is intended to be suitable to prime EasyMock-generated mocks with expectations corresponding to the recorded calls. Please have a look at .html EasyMockOutput.html The best I can claim for now is that this stuff passes its tests. Whether it is sensible or even useful I can't say yet. Michael -- Michael Schuerig                           The more it stays the same, mailto:michael@...                        The less it changes!</body>
  </mail>
  <mail>
    <header>Re: Re: Nesting of Mocks?</header>
    <body>Yeah... It's a known bug. Easymock is providing a default behavior for equals, toString and hashCode methods. Both for interface and class extension. So the class extension have two bugs. First, there's a dumb one preventing these methods to work at all. This one is actually solved on sourceforge cvs. Then, the second one is more tricky. It doesn't work if these methods are overloaded on the mock base class. So if these methods are not the original ones from Object class, it doesn't work. That I talked a little about it with Tammo last week to modify easymock to allow to fix the class extension neatly. But since it's from my point of view a problem preventing to use the class extension in many cases, I think I'll provide a dirty fix early this week and we'll try to have it fix correctly in the next official easymock release. - Henri On Sat, 20 Nov 2004 03:43:53 -0000, Bruce Templeton</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. version (not 1.1b) You can access this file at the URL:  To learn more about file sharing for your group, please visit:  Regards,</body>
  </mail>
  <mail>
    <header>Re: Re: Nesting of Mocks?</header>
    <body>Ok, I've fixed it. It's not in cvs head and also I've put a complete build on yahoo (easymockclassextension-1.1.1)  I've tried it on your test case. It worked fine. Tell me how it goes, Henri On Sat, 20 Nov 2004 03:43:53 -0000, Bruce Templeton</body>
  </mail>
  <mail>
    <header>Re: Re: Nesting of Mocks?</header>
    <body>Doh... I meant: It's NOW in cvs head. On Tue, 23 Nov 2004 00:41:28 +0100, Henri Tremblay</body>
  </mail>
  <mail>
    <header>Re: Nesting of Mocks?</header>
    <body>Yes, it's fixed my problem.  Thanks for the fast fix! -Bruce</body>
  </mail>
  <mail>
    <header>Problem Creating Control</header>
    <body>Hi, I am facing a strange problem in choosing constructors at the time of creating a control. The Class I want to mock does not have a default constructor. The code to the constructor of the file to be mocked is as below: //Constructor Code System.out.println("Debug: Inside NumberAdder(int, System.out.println("Debug: Exiting NumberAdder(int, //Method called inside the constructor Now when the below line is executed in my JUnit file: MockControl control = MockClassControl.createControl I get the following exception: net.sf.cglib.core.CodeGenerationException: java.lang.NullPointerException--&amp;gt;null at net.sf.cglib.core.ReflectUtils.newInstance (ReflectUtils.java:235) at net.sf.cglib.core.ReflectUtils.newInstance (ReflectUtils.java:220) at net.sf.cglib.proxy.Enhancer.createUsingReflection (Enhancer.java:564) at net.sf.cglib.proxy.Enhancer.firstInstance (Enhancer.java:493) at net.sf.cglib.core.AbstractClassGenerator.create (AbstractClassGenerator.java:220) at net.sf.cglib.proxy.Enhancer.createHelper (Enhancer.java:368) at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:299) at org.easymock.classextension.MockClassControl$ClassProxyFactory.create Proxy(MockClassControl.java:81) at org.easymock.MockControl.&amp;lt;init&amp;gt;(MockControl.java:125) (MockClassControl.java:356) (MockClassControl.java:367) at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:177) at com.ba.cap.product.pricingmanager.domain.test.PricingManagerHelperTes t.testCheckMinimumConnectionTimes_CaseOK (PricingManagerHelperTest.java:120) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:324) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected (TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests (RemoteTestRunner.java:421) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run (RemoteTestRunner.java:305) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main (RemoteTestRunner.java:186) Caused by: java.lang.NullPointerException at org.easymock.internal.ObjectMethodsFilter.invoke (ObjectMethodsFilter.java:44) at org.easymock.classextension.MockClassControl$2.intercept (MockClassControl.java:67) at com.ba.cap.selling.sellinghelper.domain.SellingHelper$$EnhancerByCGLI B$$7363c4b8.testMethod(&amp;lt;generated&amp;gt;) at (SellingHelper.java:91) at com.ba.cap.selling.sellinghelper.domain.SellingHelper$$EnhancerByCGLI B$$7363c4b8.&amp;lt;init&amp;gt;(&amp;lt;generated&amp;gt;) at sun.reflect.NativeConstructorAccessorImpl.newInstance0 (Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance (NativeConstructorAccessorImpl.java:39) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance (DelegatingConstructorAccessorImpl.java:27) at java.lang.reflect.Constructor.newInstance (Constructor.java:274) at net.sf.cglib.core.ReflectUtils.newInstance (ReflectUtils.java:228) ... 27 more The System.out s are as follows: Debug: Inside SellingHelper(int, int) Just the first System.out is printed out, the rest never appear. The problem is that EasyMock is picking up the right constructor, but does not seem to like the method testMethod(int,int,int,int) which is being called in the constructor. It does not execute the method testMethod(int,int,int,int) at all. Can anyone guide me on this. Thanks a lot. Regards, Pai</body>
  </mail>
  <mail>
    <header>Re: Problem Creating Control</header>
    <body>This is in fact a known limitation. The thing is that when you mock a Class, what really happens is that the class is dynamically inherited. So, when the mock is instantiated, a constructor is called which then call the same constructor on the base class... which means the class you are mocking. When this constructor is pretty doesn't do much, it works fine. But when there's some code in it, things are getting ugly. You have the following cases: 1- There is direct code in the constructor... The only way to be able to mock is to pass nice parameters to the constructor. Yeah, it removes the fun of mocking a little. 2- There are private methods called... Solution is the same as in 1. 3- There are public and protected method called. The solution is to pass nice parameters and also to tell easymock what methods you really want to mock. The one in the constructor shouldn't be mocked. I agree, all this is not nice and I'm looking for a solution (just thought of something actually...) You also made me think about something. It's actually checked-in if you want to try. I'm now ignoring all public or protected mocked calls done in the constructor. It works fine with your example. However, in some cases, if the mocked method is returning a value needed in the constructor the class won't be mockable anymore. You can't do the trick explained in 3. So I'm not quite sure it's a good idea yet. To make myself clear lets see an example: I hope there explanations you help you to find a solution, Henri</body>
  </mail>
  <mail>
    <header>RE: conditional logic</header>
    <body>As far as I can tell, the above should work perfectly well. What runtime error do you get? Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: Problem Creating Control</header>
    <body>Thanks for the real quick fix Henri. I extracted the latest code from your CVS and it works fine for me now. Thanks again. Cheers, Pai --- In easymock@yahoogroups.com, Henri Tremblay mock a inherited. then class able 1. really calls in To mock time (int, org.easymock.classextension.MockClassControl$ClassProxyFactory.create org.easymock.classextension.MockClassControl.createControl com.ba.cap.product.pricingmanager.domain.test.PricingManagerHelperTes (TestResult.java:106) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run org.easymock.classextension.MockClassControl$2.intercept com.ba.cap.selling.sellinghelper.domain.SellingHelper$$EnhancerByCGLI com.ba.cap.selling.sellinghelper.domain.SellingHelper$$EnhancerByCGLI sun.reflect.DelegatingConstructorAccessorImpl.newInstance</body>
  </mail>
  <mail>
    <header>Mocking private constructors</header>
    <body>Hi! I'd like to mock classes with private constructors which results in a IllegalArgumentException: No visible constructors in class ... I've found a trail (in November) which explains, that getDeclaredConstructor() in MockClassControl.getConstructorToUse()) its parameters) So my question is: superconstructor also needs one for private ones? Thanks, Sebastian P.S. the following should work:</body>
  </mail>
  <mail>
    <header>Re: Mocking private constructors</header>
    <body>By batch, I'm guessing you mean patch. So here are your answers: a) In the current version, when there is no visible constructor, there is nothing you can do. Only classes with at least one public, default or protected scope can be mocked. Then some methods on MockClassControl allow you to pick a constructor to use if needed. b) The super contructor will be called as well. So the parameters you pass to the constructor must work also for the call to the super constructor c) Because protected constructors can be seen by a child class. That's not the case for private ones. What you propose won't work because I'm not directly instantiating the class to mock but one overloaded by cglib. But anyway, the good news are that the current version in CVS can now mock any kind of classes (except final ones) on Sun JVM. We are currently fine tuning and the goal is to pull out a release before the end of the year. So normally you won't have to play with constructors anymore. Cheers, Henri On Mon, 20 Dec 2004 09:43:22 -0000, Sebastian.Dietrich@...</body>
  </mail>
  <mail>
    <header>AW: Mocking private constructors</header>
    <body>Cool - thanks! Then I'm going to try the latest from CVS... -----UrsprÃ¼ngliche Nachricht----- Von: Henri Tremblay [mailto:henri.tremblay@...] Gesendet: Mo 20.12.2004 23:16 An: easymock@yahoogroups.com Cc: Betreff: Re: [easymock] Mocking private constructors</body>
  </mail>
  <mail>
    <header>RE: Implementing custom stubs in EasyMock</header>
    <body>I find that *most often*, when I feel the desire to have mock do more than return a value, that is a design smell. If I think hard enough about a design where that isn't necessary, that's often a good investment of time. Your example of testing what thread a method got called on might is an interesting example for which I currently don't see a way around, though. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>RE: Implementing custom stubs in EasyMock</header>
    <body>Hi Ilja, The problem is that sometimes you don't have the luxury of tweaking the design you want to mock that much, or at all. I remember in a previous job where I was writing a framework that would interface with a network access library developed by another company. I wanted to mock their classes to eliminate the dependency on having a live server while running my classes, but I couldn't change their code - I just had the libraries. One very common use case I had to deal with was assynchronous calls - I would make a call in their API to send a request, and the reply would come later in a callback. Yes I probably could build a layer on top of their code to facilitate my testing, but the ability to add behaviors to the mock would provide for a very simple and straightforward solution. Regards,</body>
  </mail>
  <mail>
    <header>Re: Implementing custom stubs in EasyMock</header>
    <body>I will say I agree. This is why I've start working on the class extension. Because sometime you cannot change the code you want to mock. I think some of your ideas are nice and should be investigated (I'm thinking the mock modifying the parameters). I'll try to see how it can be implemented. Thanks for the suggestions, Henri On Wed, 22 Dec 2004 14:22:51 -0500, Nascif Abousalh-Neto you want to mock that much, or at all. interface with a network access library developed by another company. I wanted to mock their classes to eliminate the dependency on having a live server while running my classes, but I couldn't change their code - I just had the libraries. One very common use case I had to deal with was assynchronous calls - I would make a call in their API to send a request, and the reply would come later in a callback. Yes I probably could build a layer on top of their code to facilitate my testing, but the ability to add behaviors to the mock would provide for a very simple and straightforward solution.</body>
  </mail>
  <mail>
    <header>Re: Need help understanding easymock</header>
    <body>You are lucky Christmas is close and I'm in holidays so I took some time to check your problem. Still, I will give you some hints on how to ask for help. 1- Give the error, exception of whatever... It's hard to guess 2- Give the complete code or better, a complete test case demonstration your issue But I managed to guess one or two things. So running your code I was getting a NullPointerException. To solve it I've added in the test and now my test pass succefully. So I don't have any issue. Dice was an interface in my code. On side of that, a fine grained test. For example a test of the Creature object on hit and attack methods. There is no need to use an Orc and Player to test a Creature. Also, the code would benefit from not having the System.out all over the place (printing combat feedback shouldn't be directly in the combat code). If I didn't answer your question... I guess I'm not that good at guessing. So I'll need more inputs :-) Cheers, Henri On Thu, 23 Dec 2004 08:47:32 +0000, Paul Hunnisett</body>
  </mail>
  <mail>
    <header>RE: Need help understanding easymock</header>
    <body>Thanks for your thoughts - all helpful.  I agree that the code is not as clean as it could be (System.outs etc...), but it was primarily to experiment with mock objects so I was not as fussy as I would normally be. Passing a die to the Orc was the key I think. It seems that my player had a mock die, but the Orc had a "concrete" die and that was where the unexpected results were coming from. Once I had passed a copy of the mock die to the Orc the tests also passed for me. So, all in all it was a pretty helpful exercise for me in understating mock objects (and easymock in particular) and seeing how they can be used. Thanks again - and Merry Christmas! -----Original Message----- From: Henri Tremblay [mailto:henri.tremblay@...] Sent: 23 December 2004 22:06 To: easymock@yahoogroups.com Subject: Re: [easymock] Need help understanding easymock You are lucky Christmas is close and I'm in holidays so I took some time to check your problem. Still, I will give you some hints on how to ask for help. 1- Give the error, exception of whatever... It's hard to guess 2- Give the complete code or better, a complete test case demonstration your issue But I managed to guess one or two things. So running your code I was getting a NullPointerException. To solve it I've added in the test and now my test pass succefully. So I don't have any issue. Dice was an interface in my code. On side of that, a fine grained test. For example a test of the Creature object on hit and attack methods. There is no need to use an Orc and Player to test a Creature. Also, the code would benefit from not having the System.out all over the place (printing combat feedback shouldn't be directly in the combat code). If I didn't answer your question... I guess I'm not that good at guessing. So I'll need more inputs :-) Cheers, Henri On Thu, 23 Dec 2004 08:47:32 +0000, Paul Hunnisett reading of a die roll to see every to feed detected Yahoo! Groups Links This incoming email to UWE has been independently scanned for viruses and any virus detected has been removed using McAfee anti-virus software This email has been independently scanned for viruses and any virus detected has been removed using McAfee anti-virus software</body>
  </mail>
  <mail>
    <header>RE: Implementing custom stubs in EasyMock</header>
    <body>Hi Henri, I think something using a chain of Java Dynamic Proxies would do the trick. EasyMock already uses them, just not in a chain; the idea would be to give the user the ability to insert customized proxies in it, that after executing their behavior [1]  would call the next proxy in the chain until the last one - the one from EasyMock, that either returns a value or throws an exception - is reached. Thanks for looking into this, [1] For example: checking the current thread, sleeping for X seconds, making a callback call, modifying a collection passed as an argument, etc...</body>
  </mail>
  <mail>
    <header>Re: Using abstract classes with MockClassControl</header>
    <body>Hi, The case you mention works perfectly well. It is possible to mock an abstract class using the class extension. And to provide a behavior for the abstract methods. Try the following test case: If your example if failing, I'm guessing that it's probably because of a constructor issue (see loads of mail from me about this in the archive). But since I don't have the stack trace and the constructors of your abstract class I cannot tell you the exact cause. Merry Christmas, Henri</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group.  You can access this file at the URL:  To learn more about file sharing for your group, please visit:  Regards,</body>
  </mail>
  <mail>
    <header>Re: New file uploaded to easymock</header>
    <body>Nice, in fact I just did the exact same thing some weeks ago (except that I kept the MockControl.createMockControl(), control.getMock() syntax). Seems I should have published it. I agree that the JDK5 version is pretty neet. I have casting. Now we just need to see if a JDK5 specific version is wanted. What everybody think? Tammo? Thanks for the upload, Henri P.S.: My personnel JDK5 test: On 3 Jan 2005 20:43:47 -0000, easymock@yahoogroups.com</body>
  </mail>
  <mail>
    <header>Re: New file uploaded to easymock</header>
    <body>Thanks Henri. I just noticed that in the java5 version I used mocks.newMock(...) instead of mocks.createControl(...). Didn't mean to do that. I'll put a out new version soon. -- barry kaplan groups1@...</body>
  </mail>
  <mail>
    <header>Re: Easy Mock for struts action classes with EJB</header>
    <body>It seems I was more busy after xmas then on xmas day... How do you retrieve your EJB remote interface? You play with the initial context to mock the home and remote interface? One way to "ignore" a call to a method is to use the Nice behavior (createNiceControl). The sad thing is that the behavior is for all the mock, not only for a given method (that could be any new feature idea while I'm thinking about it...). Then, usually I tend to wrap the way I'm retrieving the remote interface into some framework code to make it easier to mock. Some kind of ejb factory. Another trick would be to use a generic setUp method or a fixture where you define a default behavior  for an EJB. It will contain something like: mock.ejbCreate(...) The case of ejbCreate is trickier since it depends on the ejb you are working on. So I prefer my two first solutions to have something more generic. The idea to allow to register a hook to a mock control to bring more flexibility seems also an idea we should dig a little I think. Happy new year, Henri net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:220) org.easymock.classextension.MockClassControl$ClassProxyFactory.createProxy(MockC\ lassControl.java:81) org.easymock.classextension.MockClassControl.createStrictControl(MockClassContro\ l.java:245) com.dixons.rtm.rtmc.posOrderingSystem.implementation.test.AdministrationImplemen\ tationTest.setUp(AdministrationImplementationTest.java:55) The case you mention works perfectly well. It is possible to mock abstract class using the class extension. And to provide a behavior for Try the following test case: public class public static interface MyInterface public static abstract class BaseClass public MockControl ctrl = BaseClass mock = If your example if failing, I'm guessing that it's a constructor issue (see loads of mail from me about archive). But since I don't have the stack trace and the of your abstract class I cannot tell you the exact Merry Christmas, Henri On Fri, 24 Dec 2004 09:05:35 +0000, Guy When I use a MockControl I tend to combine multiple interfaces so validate the order that methods are called, i.e. interface interface MockWrapper extends Interface1, Interface2 MockControl mockWrapper mockWrapper.expectAndReturn(((Interface1)mockWrapper.getMock()).operation1(), mockWrapper.expectAndReturn(((Interface2)mockWrapper.getMock()).operation2(), mockWrapper.expectAndReturn(((Interface1)mockWrapper.getMock()).operation1(), This calls to Interface1.operation1(). It would be nice if I it were where you mix a concrete class stubs for the interface methods, to use abstract classes with abstract Interface2 The call below will fail: MockClassControl.createStrictControl(AbstractMockWrapper.class) I've this, Guy. Yahoo! Groups ADVERTISEMENT ________________________________ Yahoo! Groups To visit your group on the web, go  To unsubscribe from this easymock-unsubscribe@yahoogroups.com Your use of Yahoo! Groups Links easymock-unsubscribe@yahoogroups.com</body>
  </mail>
  <mail>
    <header>Re: Mocking HttpServletResponse</header>
    <body>You get a compilation error. This has nothing to do with easymock. Your attribute is typed HttpServletResponse and getContentType is called on it. Since we know getContentType exists in HttpServletResponse interface... It means you have another problem. Compilation problems or another HttpServletResponse class somewhere shadowing the real one. Cheers, Henri HelloWorld servlet. (HttpServletRequest.class) (HttpServletResponse.</body>
  </mail>
  <mail>
    <header>Re: Re: Mocking HttpServletResponse</header>
    <body>You see, getContentType() actually not a method from HttpServletResponse interface, but inherited from ServletResponse interface. The method call: responseMock.getContentType() where responseMock is mock casted as HttpServletResponse cause compilation problem. I am just guessing, may be the mock does not handle methods inherited from another interface. Aryanto --------------------------------------------------------------- --------------------------------------------------------------- --------------------------------------------------------------- ---------------------------------------------------------------  __________________________________________________ Do You Yahoo!? Log on to Messenger with your mobile phone!</body>
  </mail>
  <mail>
    <header>RE: Re: Mocking HttpServletResponse</header>
    <body>The compiler doesn't know that it's a mock. If you get a compilation problem, it's not a problem of EasyMock, but something more general. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>RE: Re: New features proposal submitted to your approbation</header>
    <body>If I imagine that, I instantly think "Interface Segregation Principle"... With other words, I wouldn't want to *have* a huge interface at all. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: Re: Mocking HttpServletResponse</header>
    <body>I know that. It doesn't matter. If the method is on a base interface, it's available in the extending interface. There is no such thing as implementing an interface but not the methods of the base interface. That is not possible in java. A class implementing an interface should always implements all methods. It doesn't matter is the class was dynamically created or not. If a class is dynamically created but doesn't correctly implement an interface you will get some java runtime error (I don't remember which). But in your case you use a TYPED interface and call a method on it. All this is static. Nothing at runtime here. It's the compiler that directly tell you that your interface doesn't contain this method. As I said it could only mean 2 things: 1- Compiler is confused 2- The interface really doesn't contain the method... so you might not be using the interface you think you are. _________________________________________________________________ The new MSN 8: smart spam protection and 2 months FREE*</body>
  </mail>
  <mail>
    <header>Re: Re: Mocking HttpServletResponse</header>
    <body>Check the API docs. getContentType() method is on ServletREQUEST, not ServletResponse. -joel shellman</body>
  </mail>
  <mail>
    <header>Re: Re: Mocking HttpServletResponse</header>
    <body>It was just added to ServletResponse in servlet spec 2.4. If you really did mean ServletResponse.getContentType(), then the problem probably is that you're compiling against a version 2.3 servlet.jar. -joel shellman</body>
  </mail>
  <mail>
    <header>How do I mock a DAO's method that alter's an object</header>
    <body>I'm using EasyMock to mock a DAO that I use to talk to Hibernate.  In the normal flow, the following method talks to Hibernate and Hibernate saves the object and assigns a primary key. Is it possible to mock this method so that a user object w/o an id gets assigned one? Thanks, Matt</body>
  </mail>
  <mail>
    <header>Re: NPE working with class extension</header>
    <body>Hi, has anybody made any progress on a long term solution? Thx, Rich --- In easymock@yahoogroups.com, "Henri Tremblay" constructor is following code: mocked but I doesn't exception: com/bnpparibas/grp/bv/cl/inx/repair/scanswer/TestMock$A$$EnhancerByCGL IB$$c62df3a1-2 com.bnpparibas.grp.bv.cl.inx.repair.scanswer.TestMock$A$$EnhancerByCGL IB$$c62df3a1-2.CGLIB$STATIC_HOOK(&amp;lt;generated&amp;gt;) com.bnpparibas.grp.bv.cl.inx.repair.scanswer.TestMock$A$$EnhancerByCGL IB$$c62df3a1-2.&amp;lt;clinit&amp;gt;(&amp;lt;generated&amp;gt;) idea... this I've ServletRequestDataBinder.html (ReflectUtils.java:273) (ReflectUtils.java:258) (Enhancer.java:585) (Enhancer.java:514) (AbstractClassGenerator.java:195) Proxy(MockClassControl.java:81) (MockClassControl.java:356) (MockClassControl.java:367) (MockClassControl.java:177) (BizNameDescControllerTest.java:75)</body>
  </mail>
  <mail>
    <header>MockEJB and EasyMock - Exceptions in ArgumentsMatchers</header>
    <body>Hiya, I've included an example file which exhibits curious and annoying behaviour.  When using the combination of EasyMock and MockEJB (both of which are amazing, I might add), bad things can happen if you have an exception thrown in your ArgumentsMatcher. Specifically, the stacktrace gives you few clues as to where the error occurred.  While there is the inclusion of the Exception and its message, the stacktrace is deceiving because there is no indication of the true place where the exception is thrown. So I guess this is maybe a warning to others who use this combination. (FYI, in EasyMock without the use of MockEJB it does properly return the correct location of the failure). This occurs on Windows XP, JDK 1.4.2 (and Java 5), in Eclipse, if it makes a difference. Later, j java.lang.RuntimeException at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:44) at $Proxy0.echoString(Unknown Source) at com.invidex.videolinx.common.orderingservice.model.TestEasyMock.testEastMock(Tes\ tEasyMock.java:73) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:324) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:573) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :339) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:204) /** * @author jlongman * */ public class TestEasyMock extends TestCase SessionBeanDescriptor(</body>
  </mail>
  <mail>
    <header>ArgumentsMatcher - expected and actual?</header>
    <body>This one's just an EasyMock one... It seems like the order of actual and expected in the ArgumentsMatcher is being reversed, this behaviour is very confusing... I'm not certain why the ArgumentsMatcher is called twice, once correct, once incorrectly.  Any idea? 19:02:36,570 DEBUG [TestEasyMock] actual: myExpected - expected: actual 19:02:36,586 DEBUG [TestEasyMock] actual: actual - expected: myExpected /** * @author jlongman * */ public class TestEasyMock extends TestCase</body>
  </mail>
  <mail>
    <header>Re: ArgumentsMatcher - expected and actual?</header>
    <body>easymock@yahoogroups.com schrieb am 15.09.04 01:06:30: There is no order guaranteed, the parameters are named inappropriate. The ArgumentsMatcher allows to define an equals()-like method for Objects that would not be equal due to their equals()-Method. The method is called in record mode to compare expectations, so that summaries for failures are more readable. If you call it is handled as if you call - Tammo</body>
  </mail>
  <mail>
    <header>Re: more mockObjects of same type</header>
    <body>Hi, It seems like, the more correct way is to have one MockControl for each MockObject. However using two MockControls does not seem to work either - in the code below currency is null, when addAmount is called the second time : MoneyBag class ... TestMoneyBag class.... seems be object.</body>
  </mail>
  <mail>
    <header>Re: Re: NPE working with class extension</header>
    <body>The issue is not as obvious as it seems. I'm currently trying to play with ASM and class loaders to be able to solve it. Unfortunatly it's progressing slowly because of lack of time. I have an ugly but working solution so far. So the answer is yes, someone is trying to find a solution. Slowly thought...</body>
  </mail>
  <mail>
    <header>DualMock - an easyMock extension</header>
    <body>When I have been using Mock Objects for testing I often find it helpful to intersperse expectations and test code, for example: Doing this with easyMock requires me to validate and reset the object frequently. I was thinking: What is stopping me from just calling doing this: Of course, the problem is that the object-under-test (in this case, the server) and the test-code uses the same mock object instance. This lead me to the following solution: Make two mock objects - one for the expectiations and one for the actual code. Thus the name DualMock. Here is a snippet of test code: The class currently only suggest strict ordering behaviour, which is what I find most useful for this kind of testing. The DualMockTest testcase has 10 testcases. I have a few questions to the group: 1) Is this a good idea? 2) How can it be improved? 3) Would y'all be interested in the full code for the extension? Thanks. ~Johannes</body>
  </mail>
  <mail>
    <header>Re: DualMock - an easyMock extension</header>
    <body>I am not sure to understand. How the mock is used by the tested server in your example? It's injected somewhere in the setUp? Assuming control is a MockControl instance, what is validate() ? You mean verify() ? Then, in your test, ain't you testing two things in the same test? Shouldn't it be better to have: (yes you can factorise that) I think I just got your idea. You have one mock for recording and one for replay so you can use the same recording twice (or more). If I got it right, no, I unfortunatly don't think it's a good idea. In your example I would have done two separate tests with two separate mocks. The only advantage I can see is that you don't need to call replay() anymore. But you need to keep two variables for your interface. But I need to think about it. Maybe there are some advantages of splitting the recording and replay. Cheers, Henri</body>
  </mail>
  <mail>
    <header>Problem Mocking out an Object</header>
    <body>Hi, I am facing a peculiar problem I am trying to mock out an object. However when I execute a method on the mocked object I get the following error. junit.framework.AssertionFailedError: ([com.ba.schema.validate.impl.WeightSegment1Impl@17f409c]): ([com.ba.schema.validate.impl.WeightSegment1Impl@17f409c]): expected: 0, actual: 1 ([com.ba.schema.validate.impl.WeightSegment1Impl@194d372]): expected: 1, actual: 0 at org.easymock.internal.ObjectMethodsFilter.invoke (ObjectMethodsFilter.java:44) at org.easymock.classextension.MockClassControl$2.intercept (MockClassControl.java:68) at cam.bc.cup.creating.creationhelper.domain.SellingHelper$$EnhancerByCG LIB$$7363c4b8.isMinimumThermalTimeOK(&amp;lt;generated&amp;gt;) at cam.bc.cup.product.WeightManager.domain.WeightManagerHelper.checkMini mumThermalTimes(WeightManagerHelper.java:1085) at cam.bc.cup.product.WeightManager.domain.test.WeightManagerHelperTest. testCheckMinimumThermalTimes(WeightManagerHelperTest.java:251) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:324) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected (TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests (RemoteTestRunner.java:397) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run (RemoteTestRunner.java:281) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main (RemoteTestRunner.java:173) I am sending the exact value on the mock object (before setReturnValue), that is being sent to the mock object in the code. Looks like both the input parameter's being List's, they appear as different types to Easy Mock. Can anyone help me out on this. Thanks a lot. Regards, Pai</body>
  </mail>
  <mail>
    <header>StackOverflowError when mocking class java.io.File</header>
    <body>This test case blows up with a StackOverflowError when running against J2SE 1.4.2_03.  I'm using EasyMock Class Extension 1.1 (slightly later than that, I think, but it still fails in 1.1). I traced through the code, and it looks like this is a general problem when a class constructor has a parameter of the same class, as the File class does. Funny, but a couple of my co-workers cannot reproduce this problem. I can reliably reproduce it. Anyone else have luck reproducing this issue? -eric // MockClassControlStackOverflowTest.java public class MockClassControlStackOverflowTest public static void main(String[] args) // either of these lines fails with StackOverflowError // TestClass.java public class TestClass public TestClass(TestClass other) This message and any attachment is intended for use only by the individual or entity to which the email is addressed and may contain information that is privileged, confidential and exempt from disclosure under applicable law. If the reader of this message is not the intended recipient, you are hereby notified that any retention, dissemination, distribution or copying of this communication or any attachment is strictly prohibited. If you have received this communication in error, please delete the e-mail and any attachment and notify Everstream, Inc. immediately by telephone at 440-498-8899.</body>
  </mail>
  <mail>
    <header>Re: StackOverflowError when mocking class java.io.File</header>
    <body>I was able to reproduce it. Yes you are right, got a stack overflow. The thing is that when you call MockClassControl.createControl without specifiying any constructor to use the algorithm is a follow: 1- Take the empty constructor is exist 2- Take the first one otherwise. The sad thing is that for File, the first constructor takes a File in parameter. And I try to mock each parameters.... but since it's the same class I then pick the same constructor and so on.... until the stack overflow. I can put a better error message but for you the real solution is the specified the constructor to use when calling createControl (there is two version of createControl). Cheers, Henri On Wed, 13 Oct 2004 16:22:43 -0400, Eric Williams 1.4.2_03.  I'm using EasyMock Class Extension 1.1 (slightly later than that, I think, but it still fails in 1.1). class constructor has a parameter of the same class, as the File class does. reliably reproduce it. entity to which the email is addressed and may contain information that is privileged, confidential and exempt from disclosure under applicable law. If the reader of this message is not the intended recipient, you are hereby notified that any retention, dissemination, distribution or copying of this communication or any attachment is strictly prohibited. If you have received this communication in error, please delete the e-mail and any attachment and notify Everstream, Inc. immediately by telephone at 440-498-8899.</body>
  </mail>
  <mail>
    <header>Re: Problem Mocking out an Object</header>
    <body>Hum, I don't think anyone ever answered this one. Sorry about that. The sad thing is that I will need more information to give a complete answer. I don't have any snippet of the test class or even the mocked method prototype so it's kind of hard to guess what happened... One thing is sure. Easymock think this method shouldn't have been called with the parameters it was called with. Parameters are compared with their equals() method if you didn't specify any special ArgumentMatcher. So just make sure that both are equals (I mean, try it). It's all I can do for you with the information you provided. Regards, Henri On Wed, 13 Oct 2004 19:30:15 -0000, Roshan</body>
  </mail>
  <mail>
    <header>RE: Problem Mocking out an Object</header>
    <body>Agreed. Take a closer look at the error message - the message got called with WeightSegment1Impl@17f409c, expected was WeightSegment1Impl@194d372. Seems WeightSegment1Impl doesn't implement equals correctly. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>conditional logic</header>
    <body>Hello, First-time poster here. I have been using EasyMock for a few months now, and it has been quite useful. I do have a suggestion, though. I have found it is very difficult to use conditional logic based upon the arguments passed to the method call and would like to see this improved.  For instance, I can't do this without getting a runtime error: The ZERO_OR_MORE is necessary because this mock class may be called from different systems under different circumstances multiple times, yet I want to design an object that behaves uniformly without writing a separate stub object. I have tried using custom matchers as well, and I run into similar problems, all which seem to be based around the fact that the method signature is stored independently of the arguments that it is passed. I can't seem to change matchers on successive method calls, either. This would also be useful. Thoughts? Am I going about this completely the wrong way? Thanks, Jonathan</body>
  </mail>
  <mail>
    <header>Nesting of Mocks?</header>
    <body>Hello: I have read various opinions on the wisdom (or lack thereof) of nesting mocks. In my case, I have a 3rd party set of classes that I need to mock. If I have ObjectA.getObjectB() that returns yet another of these 3rd party classes - I need to mock B. I know I can do a setReturnValue(), but then if ObjectB has a getValue() type of call that must return something, do I do something like What is the recommendation for this type of thing? Thanks</body>
  </mail>
  <mail>
    <header>Re: Nesting of Mocks?</header>
    <body>No, you just create and record the values of each mock. The returned value of ObjectA.getObjectB will be your mocked B. Something like this: Each mock is independant. So you don't need to order the recording of two mocks. And I don't see anything wrong in having a mock returning another one. I'm doing it frequently. One good example is a factory that returns a mock object. I'm mocking the factory to have it returns my mock object. The only recommandation I can make is try to order, comment, factorise your mocks to keep the test readable. And try to avoid huge graphs of mocks. It easily become a mess. - Henri</body>
  </mail>
  <mail>
    <header>Re: Nesting of Mocks?</header>
    <body>Hello, I'm having a problem trying to do something similar to this when using the class extension. I have situations where I am trying to mock multiple interacting classes.  Sometimes a class under test will pass one mock object as an argument to another mock object.  In the following example, both aObj and bObj are mocks: This works fine if both are interfaces and I'm using MockControl, but if one of them is a class and I'm using MockClassControl, I get errors. I've attached the following which demonstrates an interface-only test that works and one using a mix that fails, along with the error messages at the bottom.  I used the Collection classes for simplicity.  (List and Set are interfaces, ArrayList is a class.) I greatly appreciate any help anyone could provide. Thanks! p.s. I've just started using EasyMock and it has been fantastic (thanks for the great work!) ################################################# ################################################# Testsuite: CollectionTest Tests run: 2, Failures: 1, Errors: 0, Time elapsed: 1.693 sec Testcase: testIntfMocksOnly took 0.241 sec Testcase: testMixedMocks took 1.172 sec junit.framework.AssertionFailedError: (ObjectMethodsFilter.java:44) (NativeMethodAccessorImpl.java:39) (DelegatingMethodAccessorImpl.java:25) ################################################# If I change from createStrictControl to createNiceControl, I get the following error message. ################################################# Testsuite: CollectionTest Tests run: 2, Failures: 1, Errors: 0, Time elapsed: 1.604 sec Testcase: testIntfMocksOnly took 0.23 sec Testcase: testMixedMocks took 1.123 sec junit.framework.AssertionFailedError: (AbstractBehavior.java:63) (NativeMethodAccessorImpl.java:39) (DelegatingMethodAccessorImpl.java:25) of returns factorise of I another something like</body>
  </mail>
  <mail>
    <header>Re: A Matcher that matches arguments with the same class</header>
    <body>So Tammo, any more thoughts on the commutability and that easymock swaps the expected/actual values during setup? Barry Kaplan bkaplan@...</body>
  </mail>
  <mail>
    <header>mock static methods in class extension</header>
    <body>Am rather new to easy mock, am trying to mock a class with a static method but am unable to.  For example I've created a test (see code). The problem is that it seems that I cannot mock up the static method.  The mockProblemClass.getStaticData call results in a warning and subsequent calls to set return values results in an exception: java.lang.IllegalStateException: method call on the mock needed before setting return value at org.easymock.MockControl.setReturnValue(MockControl.java:269) at MyClassTest.testGetData(MyClassTest.java:53) .... Does anyone have any ideas on how this could be achieved without first wrapping the class and mocking the wrapper? Thanks for any help, Joshua. public class ProblemClassToTest -------- public class MyClass public MyClass() public void getData() -------- public class MyClassTest extends TestCase way...</body>
  </mail>
  <mail>
    <header>Re: A Matcher that matches arguments with the same class</header>
    <body>easymock@yahoogroups.com schrieb am 02.08.04 22:56:00: They are swapped when inserting in the HashMap. In fact, it depends on the implementation of HashMap in which order the comparison is done. I son't see any simple way to make this work for matcher usages that ignore the expected value and only use the actual value. - Tammo</body>
  </mail>
  <mail>
    <header>RE: mock static methods in class extension</header>
    <body>Static methods are not polymorphic - in fact they are resolved at compile time. So it's inherently impossible to mock them. You simply need to rethink your design. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>RE: A Matcher that matches arguments with the same class</header>
    <body>Yes, this occured to me when I read the rest of the lists traffic... :o I actually too find it confusing when expected and actual get swapped. I suspect that some of my current Matchers might be able to fail because of this, too... Cheers, Ilja</body>
  </mail>
  <mail>
    <header>RE: A Matcher that matches arguments with the same class</header>
    <body>Then it sounds as if using a Map is somewhat inappropriate? Perhaps using something like JDK1.4's LinkedHashMap would help? There might also be something in a Jakarta Commons package... Cheers, Ilja</body>
  </mail>
  <mail>
    <header>RE: Re: EasyMock 1.1 feedback - mock objects with more than one interface</header>
    <body>You could also think about an alternative design using delegation instead of inheritance - for example using the Role Object pattern... Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.1 feedback - mock objects with more than one interface</header>
    <body>pattern... That is what I am doing. Actually a combination of inheritance and delegation. Classes with delegates have to implement the delegate's interface or an interface that extends the delegates interface. My situation was wanting to avoid having an interface for every combination of delegate interfaces. For testing using EasyMock I need to do this.</body>
  </mail>
  <mail>
    <header>RE: Re: EasyMock 1.1 feedback - mock objects with more than one interface</header>
    <body>As far as I can tell, using the Role Object Pattern, you wouldn't need to combine interfaces. Are you sure you are using that pattern? Cheers, Ilja</body>
  </mail>
  <mail>
    <header>RE: Re: New features proposal submitted to your approbation</header>
    <body>No, sorry, you don't. :p What you do need is a separation of responsibilities - one class for processing the list of transactions and one for actually summing up the values. If you test them seperately, it very much simplifies the tests, I'd think. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>easymock.net with .Net framework v2.0</header>
    <body>Hi there, I'm new to easymock. I want use easymock.net with .Net framework v2.0, but the current .net "EasyMockInstaller.msi" I found at sourceforge requires .Net framework v1.1.4322. Any one knows any up- to-date easymock.net? Where to get the source files if I can compile it myself? Appreciate your inputs!</body>
  </mail>
  <mail>
    <header>mocking interfaces - new to easymock</header>
    <body>I am trying to understand exactly how it is that easymock works. Here's what I am trying to accomplish. I have a class that I want to test called ApTypeServiceImpl. This class has a reference to another class: I have a getter and a setter for this member variable. The reason is that I am also using a framework called Spring. Some of you might already be familiar with it. What I am trying to do is to test this class. I want to use a mock object for the DAO declared above (yes the dao is an interface) so that I can bypass the real DAO implementation which uses spring, hibernate and it's a completely different can of worms. My first stab at this (which worked just fine) was to just create a mock DAO that implemented ApTypeDAO. So in this mock, one of the method that gets called is this: So in my test I did the following: //do the assert But what I really want to do is avoid having to create all these mock objects and I would prefer to use a framework like easymock. So my question is after getting a mock from the MockControl class, how can I use that mock object in my test class so that when the methods the class that is being tested calls the methods on that mock object, I can return verifiable data/objects to assert against. The idea is that the class that I am testing uses a DAO and that DAO gets set through a setter defined in the class. This way, I can pass in whatever implementation I want of that DAO to the class being tested. But the problem is that if I pass in a mock, how can I call methods on the mock that will return anything useful since the mock is just a proxy (I think) with nothing implemented. I am new to this, so please forgive me for the length of this message, but I wanted to be very clear about what I wanted to do. Any help would be greatly appreciated. Thanks, Juan</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.1 feedback - mock objects with more than one interface</header>
    <body>interfaces, delegation pattern... interface or need Thanks Ilja, for your highlighting this pattern. No, it seems I am not using the Role Object Pattern. As a relative newbie, and coming into OOP from an odd angle I have not been fortunate so far to become as well aquanted with object patterns as I should be. This project has now moved on into production. If I get to work on this application again in the future and if business deadlines allow, I will refactor the application to this pattern. Thanks again.</body>
  </mail>
  <mail>
    <header>'.equals()' Vs '==' problem</header>
    <body>Hi, I have a piece of code that had a specific class to be mocked out. Attached below is the code. OLD CODE is that one without Easy Mock, NEW CODE is the one with Easy Mock. The idea was to mock out the MainInfo class in the old code. However when this is done here, the .equals method on one of the getters is not working and return false. However the '==' is working and returning true. This is really surprising. I have mocked out many a classes in various tests and there the same methodology seems to work fine. '.equals' returns true in those cases. Only here the problem seems to be occuring. Can anyone help me out on this. NEW CODE WITH THE MainInfo CLASS MOCKED OUT: control = MockClassControl.createControl //setMainInfo is just a simple setter // getMainInfo is just a simple getter. //The below line "==" returns true. The assertTrue is successful. assertTrue("Get value doesn't return the value that //The below line's ".equals" returns false. This is where the problem is. The assertTrue fails here. assertTrue("Get value doesn't return the value that OLD CODE WITHOUT MOCK OBJECTS: MainInfo testMainInfo = new MainInfo //Here the .equals returns true. assertTrue("Get value doesn't return the value that Thanks. Regards, Pai</body>
  </mail>
  <mail>
    <header>Re: '.equals()' Vs '==' problem</header>
    <body>You just found a terrible bug actually. In MockClassControl. Line 68 of my code (which is 1.1b) should have been Silly mistake that breaks the equals... Tammo, can you add this fix in a future release? I don't see any workaround except using == instead (which is what equals between two mocks is doing anyway). But that won't work if your tested code is using equals... Sorry about that, Henri working same</body>
  </mail>
  <mail>
    <header>Re: Re: New features proposal submitted to your approbation</header>
    <body>I think I'll need a demonstration here because I can't see what you mean. Let's see an example. It's a calculator that is initialized from a list of transactions and that returns different calculations on them. How would you code it to remove the ugly Map I need in my test class. -------------------- --------------------- -------------------- qty */ ---------------------- This will really help me to see what's wrong with my design. Please don't forget you're in front of a simplified example. Cheers, Henri ----- Original Message ----- Sent: Thursday, August 05, 2004 4:09 PM Subject: RE: [easymock] Re: New features proposal submitted to your approbation</body>
  </mail>
  <mail>
    <header>Problem in Creating a Control. (With a funny workaround)</header>
    <body>Hi, Firstly thanks a lot Henri for the prompt reply to my previous query. I am trying to mock out a class MyWallet and here I am facing a problem. When I issue a to create the control, the constructor of MyWallet is invoked, this throws a NullPointerException and hence the above statement throws an exception.(Stack Trace is attached below) createControl() seems to be invoking the constructor of MyWallet with the least number of arguments. However this constructor has some processing and is throwing a null pointer exception, which inturn causes the createControl() call to fail. Hence I am not able to mock out the MyWallet class. The constructor code for class MyWallet (which is invoked when I try to create the control) is as follows: (The it.hasNext() in the below code throws the Exception.) public MyWallet(ArrayList aList) //The below 'it.hasNext()' throws a null pointer exception //blah blah The only workaround that I have found is as follows: I have added a new constructor to the MyWallet class as follows: //Empty. No processing to avoid a NullPointerException When this constructor is added to MyWallet, this is the one (MyWallet ()) that gets invoked and not the MyWallet(ArrayList alist) one. The control gets created successfully in this case. Can anyone help me out on this as I would not like to alter the MyWallet class to get the JUnit test to run. Please forgive me if Yahoo messes up the alignment. Thanks, Regards, Pai The Stack Trace is a follows: net.sf.cglib.core.CodeGenerationException: java.lang.NullPointerException--&amp;gt;null at net.sf.cglib.core.ReflectUtils.newInstance (ReflectUtils.java:235) at net.sf.cglib.core.ReflectUtils.newInstance (ReflectUtils.java:220) at net.sf.cglib.proxy.Enhancer.createUsingReflection (Enhancer.java:564) at net.sf.cglib.proxy.Enhancer.firstInstance (Enhancer.java:493) at net.sf.cglib.core.AbstractClassGenerator.create (AbstractClassGenerator.java:220) at net.sf.cglib.proxy.Enhancer.createHelper (Enhancer.java:368) at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:299) net.sf.cglib.core.CodeGenerationException: java.lang.NullPointerException--&amp;gt;null at org.easymock.classextension.MockClassControl$ClassProxyFactory.create Proxy(MockClassControl.java:81) at org.easymock.MockControl.&amp;lt;init&amp;gt;(MockControl.java:125) (MockClassControl.java:356) (MockClassControl.java:367) at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:216) at com.ba.cap.customer.corebusiness.test.CustomerInfoTest.testSetAndGetM yWallet(CustomerInfoTest.java:120) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:324) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected (TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests (RemoteTestRunner.java:397) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run (RemoteTestRunner.java:281) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main (RemoteTestRunner.java:173) Caused by: java.lang.NullPointerException (MyWallet.java:72) at com.ba.cap.customer.corebusiness.MyWallet$$EnhancerByCGLIB$$bf5f3a66. at sun.reflect.NativeConstructorAccessorImpl.newInstance0 (Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance (NativeConstructorAccessorImpl.java:39) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance (DelegatingConstructorAccessorImpl.java:27) at java.lang.reflect.Constructor.newInstance (Constructor.java:274) at net.sf.cglib.core.ReflectUtils.newInstance (ReflectUtils.java:228) ... 27 more</body>
  </mail>
  <mail>
    <header>RE: Problem in Creating a Control. (With a funny workaround)</header>
    <body>You're welcome, And here's today's answer. MockClassControl.createControl is indeed guessing the contructor to use. The algorithm should be documented on easymock documentation page but it's currently not done. Here's how it goes: Using noargs constructor, if it doesn't exists, use the first other one found and mock the parameters (primitive types are defaulted, others are mocked with easymock). So this method might crash. The real solution is to use MockClassControl.createControl(Class classToMock, Class[] constructorTypes, Object[] constructorArgs) which allow you to specify the contructor and the args you like. So in your case you could have done: And yes, a base class constructor will always be called when mocking since the mock is extending the mocked class. _________________________________________________________________ Tired of spam? Get advanced junk mail protection with MSN 8.</body>
  </mail>
  <mail>
    <header>Re: Problem in Creating a Control. (With a funny workaround)</header>
    <body>Thanks Henri. Doing as has been said below has closed the issue. Regards, Pai --- In easymock@yahoogroups.com, "Henri Tremblay" to use. The it's other one others are constructorTypes, ArrayList.class mocking since query. this null try (MyWallet The e M .</body>
  </mail>
  <mail>
    <header>RE: Re: New features proposal submitted to your approbation</header>
    <body>Ah, in this case I wouldn't use mocks at all - just simple dummy implementations: EasyMock is a nice tool, but it doesn't apply to *all* testing situations... ;) Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Mocking HttpServletResponse</header>
    <body>Hi, I am trying to use easymock to test servlets. I cannot find any example of easymock example for various HelloWorld programs, so I decide to write them and stuck with HelloWorld servlet. I cannot even pass compile, getting this: --------------------------------------------------------------- PROMPT&amp;gt;javac -d ..\build TestHelloServlet.java TestHelloServlet.java:34: cannot resolve symbol symbol  : method getContentType () location: interface javax.servlet.http.HttpServletResponse 1 error --------------------------------------------------------------- Source Code: --------------------------------------------------------------- public class HelloServletTest extends TestCase protected void setup() requestControl = MockControl.createControl(HttpServletRequest.class) responseControl = MockControl.createControl(HttpServletResponse. public void tearDown() public void testDoGet() ... --------------------------------------------------------------- The method getContentType() is actually inherited by HttpServletResponse from its super: ServletResponse. Is that causing this problem (can EasyMock deal with interface extending another interface? Any work-around?) Anybody has example of various HelloWorld with EasyMock JUnit test? I am not asking complete set from one person. I am happy to gather whatever the group throw at me :) TIA. aryanto</body>
  </mail>
  <mail>
    <header>RE: Mocking HttpServletResponse</header>
    <body>Hi Aryanto, I don't have a direct answer to your question - just wanted to say that EasyMock probably is not the perfect tool for testing servlets. The interfaces of the serlvet API are just too intertwined. I'd rather go with HttpUnit's SerlvetUnit or the predefined mock objects from mockobjects.com Cheers, Ilja</body>
  </mail>
  <mail>
    <header>RE: Mocking HttpServletResponse</header>
    <body>Thanks for clearing it up Ilja.. I am being confused by some people who posted example of combined usage of easymock and mockobjects on some website. regards, Aryanto  __________________________________________________ Do You Yahoo!? Log on to Messenger with your mobile phone!</body>
  </mail>
  <mail>
    <header>Re: Mocking HttpServletResponse</header>
    <body>Unlike you, I only needed a mock HttpServletRequest to pass as input to a method (and return a value I specified when one of its attributes was accessed), but here's an excerpt of what I did anyway. Al Documentation.html page. HttpServletRequest.class ) ; // 1 mockHttpServletRequest_control.getMock() ; // 2 mockHttpServletRequest.getAttribute( "P" ), null, minCalls, maxCalls ) ; // 3 ===== Albert Davidson Chou</body>
  </mail>
  <mail>
    <header>IllegalState problem</header>
    <body>Hi, I've been going a bit batty today over this problem.  I have just gotten started using easymock.  I modelled my test after the example: (Amongst other things).  However, on the testBrowseVariable, I consistently get the following error: java.lang.IllegalStateException: missing behavior definition for last method call on the mock edu.uchicago.ucmap.server.explorer.DefaultExplorerProviderTest.testBrowseVariabl\ e(DefaultExplorerProviderTest.java:39) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner\ .java:421) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java\ :305) org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.jav\ a:186) I'm quite confused about this, because I do call control.replay().  Can anyone give me any insight as to what I'm doing wrong? Thanks so much in advance. -Tom ************************ Software Developer Social Science Computing Services University of Chicago ************************ _________________________________________________________________ Dont just search. Find. Check out the new MSN Search!</body>
  </mail>
  <mail>
    <header>Re: IllegalState problem</header>
    <body>Hello Tom, edu.uchicago.ucmap.server.explorer.DefaultExplorerProviderTest.testBrowseVariabl\ e(DefaultExplorerProviderTest.java:39) , you have specified that you expect this call in replay mode. However, the behavior definition for this method call is missing: Which value should the method call return? Or should it throw an exception? Let us assume that the method returns String objects, and that you would like to return "ABC". The code for that is or as a one-liner: - Tammo</body>
  </mail>
  <mail>
    <header>Re: IllegalState problem</header>
    <body>Thank you so much.  I was rather going crazy. -Tom le(DefaultExplorerProviderTest.java:39) _________________________________________________________________ Get ready for school! Find articles, homework help and more in the Back to School Guide!</body>
  </mail>
  <mail>
    <header>Re: New features proposal submitted to your approbation</header>
    <body>I don't completly agree. My example was a simplified one. You must imagine a huge Transaction interface. So you will have to build a big DummyTransaction. Possibly a basic one that you then extend for a lot of test. And then the Calculator might have method using more than one interface method, and so on... The transaction might also aggregate some other objects And anyway, I rarely use static mock objects, they are harder to maintain from my point of view. Cheers, Henri</body>
  </mail>
  <mail>
    <header>RE: EasyMock 1.1 feedback - mock objects with more than one interface</header>
    <body>What would you need this for??? Curious, Ilja</body>
  </mail>
  <mail>
    <header>Re: request: Ability to specify matchers per call</header>
    <body>And what makes this even more diffucult, is that matcher subclasses don't even know the method name. Thus they have to try infer the context by the parameters (always sloppy, verbose, and hard to maintain -- often not even possible). I have no problem attempt this modification. Maintainers, do you have an opinion on this feature? Or advise on how you would like to see it implemented? -bk</body>
  </mail>
  <mail>
    <header>Re: New features proposal submitted to your approbation</header>
    <body>I would love to see this capability in the standard distribution. Often when working with methods that take collections of objects (of which the contents must be mocked) I use setup methods to create the collections. However, if certain tests need to define extra expectations for those mocks, they cannot have access to controls; The setup method returns the collection to used as an argument to the MUT. Yes, I could have the setup method return a complex object that contains the collection for the MUT and a Map&amp;lt;Mock, MockControl&amp;gt;, but, well, thats a lot of busy work. -bk</body>
  </mail>
  <mail>
    <header>Why does invoke() to a e.FillInStackTrace()?</header>
    <body>ObjectMethodsFilter.invoke() contains: Why the fillInStackTrace()? This looses all context of where the exception actaully occured. Often, when a mock is not setup correctly easymock will throw a NPE. But because of the fillInStackTrace() the location of exactly where is lost, and hense it requires a dubugging session with lots step-ins to find out what is wrong.</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.1 feedback - mock objects with more than one interface</header>
    <body>more than a &amp;gt;single interface? Just create an interface extending the interfaces you would like to mock, then create a mock for this interface. Maybe this interface is useful in your application, too. If the interfaces belong together in the test, they may belong together in the application. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Why does invoke() to a e.FillInStackTrace()?</header>
    <body>easymock@yahoogroups.com schrieb am 29.07.04 17:26:08: The first users complained that the stack traces are disturbing, because they show a path deeply into the internal EasyMock classes. There should be an explaining error message. Would you provide an example where the exception's message does not give a hint for the failure reason? - Tammo</body>
  </mail>
  <mail>
    <header>Test defined matches used in record mode cause problems</header>
    <body>We just [attempted] to upgrade to 1.1. One of the problems we ran into was that matches registered with MockControl.setMatcher(myMatcher) are used during record to mode by ResultListMap.addExecpted(..). One specific problem we have found is that we have defined a 'non-null-argument' argument that only checks that the specified argument to the method is non-null. Consider: During the setVoidCallable() nonNullMatcher invoked by ResultListMap.addExecpted(..):35 to get the ResultList from its field resultListMap. But the arguments in MatchableArguments are null, and nonNullMatcher will thus return false. Resulting in a null list returned from resultListMap.get(matchable). (This is so even though in the same method that very same MatchableArguments instance was just added to the map with a newly created ResultList). Below is a modification to MatchableArgumentsComparisonTest.java that illustrates this issue concretely. When you run this test first assertion fails with: junit.framework.AssertionFailedError: -- This is just a very simple example of why using the matchers during record mode causes the problems. In this case I could avoid the problem by simply passing a dummy object (instead of null) to the mock method. But for other matchers that do more sophisiticated matching there will be no simple workaround. This is especially accute since only one matcher instance can be assigned to an entire control (vs. per call). To get around this we have several matchers that are aware of the order they will be called so they can match appropriatly. But now that they are called in record mode all bets are off. If the matches were assignable on a per-call basis, they could be fully stateless and should not problems being invoked during record mode. I guess I will start looking into making matchers optionally settable per-call, unless others have a better approach. -- MatchableArgumentsComparisonTest.java --</body>
  </mail>
  <mail>
    <header>Re: Why does invoke() to a e.FillInStackTrace()?</header>
    <body>I'll add a concrete example soon. But anytime a NullPointerException is thrown (or any other type of runtime-exception that is /not/ explicity thrown by easymock) there is no message at all. I see the intent of reducing the stack trace was to hide internal details of why /easymock/ decided to throw an exception, since it added an explaining message to the exception. But in the case of errors in easymock or (more commonly) use of easymock, the runtimes provide no clues, and hence the long debug session.</body>
  </mail>
  <mail>
    <header>Re: Why does invoke() to a e.FillInStackTrace()?</header>
    <body>Ok, here's a concrete example. I'm sure its something in our test framework that is no longer compatible with 1.1. But I now have to debug to see where in easymock the NPE was actually generated. java.lang.NullPointerException at org.easymock.MockControl.replay(MockControl.java:174) at test.support.easymock.EasymockHelper$1.execute(EasymockHelper.java:37) at test.support.easymock.EasymockHelper.applyGlobalControls(EasymockHelper.java:83) at test.support.easymock.EasymockHelper.apply(EasymockHelper.java:59) at test.support.easymock.EasymockHelper.replay(EasymockHelper.java:35) at test.support.AbstractTestCase.replay(AbstractTestCase.java:63) at com.its.fixgate.TestFixGateway.testSimpleLogin(TestFixGateway.java:366)</body>
  </mail>
  <mail>
    <header>Re: Test defined matches used in record mode cause problems</header>
    <body>Matchers are there to allow Objects to be recognized as a match although they are not equal in the sense of equals. If you would like to match different objects, setting the expectations with subsequent calls should work fine. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Test defined matches used in record mode cause problems</header>
    <body>Tammo, I appreciate your help, but I'm not sure I see how your comment relates to my problem. Yes, that is what a matcher is for. That is what we use them for - to match objects that are not equals via their equals() methods. But easymock is also using the matchers to lookup the MatchableArguments from the list maintained by ResultListMap. In addExpected(), even though line 06 is executed, line 09 can return a null 'list' (in the same method call!) due to the use of the test-defined matcher in looking up the MatchableArguments from the TreeMap. 03     MatchableArguments matchable = ... 04 08 Do you not see this as a problem? -bk</body>
  </mail>
  <mail>
    <header>Re: Re: Test defined matches used in record mode cause problems</header>
    <body>After re-reading your post, I hope to understand the problem now. I think it is related to a missing piece of information in the documentation. If you would like your mock object to match only non-null values for a method, you need to 1) Define a matcher that regards all non-null values as equal, 2) Call the method with a non-null value in behavior definition. 1) (using the convenience methods of AbstractMatcher) 2) This may happen if the matches() method of the Matcher is not commutative. Then MatchableArguments (more exact: Arguments used by MatchableArguments) violate the equals() contract, and therefore the list is not found in line 09 although it has been added three lines earlier. To prevent the NPE in line 10, I'll add a guard clause in the next EasyMock release, warning that the Matcher's matches() method has to be commutative. Thanks for your feedback! - Tammo</body>
  </mail>
  <mail>
    <header>RE: Re: New features proposal submitted to your approbation</header>
    <body>With all due respect, this sounds really complicated - much to complicated for a test, in my opinion. What exactly are you testing that you need to mock whole collections? Perhaps you could benefit from a refactoring? Cheers, Ilja</body>
  </mail>
  <mail>
    <header>RE: Re: request: Ability to specify matchers per call</header>
    <body>Isn't MockControl.setMatcher doing exactly that? /** * Sets the ParameterMatcher for the last method called on the mock object. * The matcher must be set before any behavior for the method is defined. * * @throws IllegalStateException *             if called in replay state, or if no method was called on the *             mock object before. */ Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.1 feedback - mock objects with more than one interface</header>
    <body>that implement more than a &amp;gt;single interface? to mock, interfaces application. I have a set of objects and a set of behaviours. Object W, X, Y &amp;amp; Z. Behaviours years, positions &amp;amp; bd W has years, bd &amp;amp; positions X has years &amp;amp; bd Y has years Z has years &amp;amp; positions If an object has Years (instanceof years) then I may do a getYears() on it. if an object has bd then I may do a getBd() on it. if an object has positions I may do a getPositions() on it. I could create an interface for each of these combinations (yuk) (extending behavour gets messy ...) ie: years-bd-positions which extends years bd positions But the mock object generated from years-bd-positions does not come out as an instanceof years or bd or positions ... only instanceof years-bd-positions. My application is traversing a set of objects and doing different operations on them depending on what behaviour they exhibit.</body>
  </mail>
  <mail>
    <header>Re: New features proposal submitted to your approbation</header>
    <body>The method under test is not complicated at all. It has a signature of the form: In this particular case the repsonsibility of the method is to generate a multi-line master/child record for inclusion in a report sent to an external system. We have no control over the format; it is imposed by the external system. The master/child record is not simply a text formatting of the data in the objects -- there are business rules that must be applied in the generation of both the master and child records, even how many of the executions get included as children). Again, these business rules are imposed by the external system. The method above performs most of its work by delegation, but it does perform the selection criteria on the list of executions. There are quite a few test specific to this method, each varying the behavior of the mock executions in small ways. The majority of the mock setup is common. So, what I want is to create a setup method of the form: But the caller of this setup method then needs to add just a few more expectations for its particular test. (Does this make things more clear so far?) Sure I can return a struct with two arrays, or a Map&amp;lt;Execution, MockControl&amp;gt;, or whatever. But if could get to the control from the control via: It would require less work, and test setup code would much smaller and clearer. -bk</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.1 feedback - mock objects with more than one interface</header>
    <body>that implement more than a &amp;gt;single interface? to mock, interfaces application. OOPs, Bugga ... too many late nights. It works when I use an extended interface. Must have been something else wrong with me code that I fixed while I was sleeping. (Damn those elves)... Not so nice though when I have to create combination interfaces, just for testing so it's not so bad maybe.</body>
  </mail>
  <mail>
    <header>Re: request: Ability to specify matchers per call</header>
    <body>It defines a matcher for a "method", not for a single "method call". For example, I would like to: Where 'customerMatcher' applies to just that invocation. Of course, this is a /rare/ situation. But its use would optional, keeping with the philosophy of "simple things are simple to implement, complicated things are possible". -bk</body>
  </mail>
  <mail>
    <header>Re: Test defined matches used in record mode cause problems</header>
    <body>Hmm. I'll have to look at our matchers and see if any violate this. I believe they may. For example, we have matchers that ensure the argument is of a specific [sub]class, so I don't see commutability will ever be possible (nor desirable). In this case, there is no concept of an concrete expected argument in the record mode -- the matcher defines the expected argument, the specific Class. The value passed to the mock method invocation during record is just to setup the expectation that the /method/ be invoked. But, I do not believe this is the case with the non-null matcher. Ok, that is what I had (like your example 2). But: Also resulted in a call to the matcher with a null argument. Which the non-null matcher said did not match. Which caused the ResultList to not be found. Which triggered the NPE. This guard will not I believe address the issue. Certainly. easymock is simply great, and I truely appreciate the work you put into it. With over 7000 unit tests based on easymock, I'm eager to help and improve it. And of course, I'm eager to not to have to sweep thru all those tests to upgrade to 1.1 ;-) -bk PS!! I think see what the problem was with our non-null matcher. I just added a unit test to DefaultMatcherTest (maybe the not right place, but I was just spiking) and could not reproduce the problem I saw in our system. Then I noticed that my non-null matcher in that test extended AbstractMatcher. But all of the matchers in our system simply implement Parameter/ArgumentsMatcher (or our own abstract matcher implementation). AbstractMatcher has a few guards that seem to mask the non-matcher problem: I'll give the conversion another shot, modifying our matchers to use AbstractMatcher and see if that solves the other problems as well (Class matchers, etc).</body>
  </mail>
  <mail>
    <header>Re: Test defined matches used in record mode cause problems</header>
    <body>I ran into something. Consider this test snippet (why does yahoo have to kill all the formatting!!?): On the actual invocation of the mock (the last line of the test), when the matcher is invoked, 'actual' is the value "string 1" -- /not/ the "new Objec()" instance. Ok, I see now why commutability is required. But I don't agree. It makes this kind of matcher impossible. Are you are saying that the matcher is limited to: actual.getClass().equals(expected.getClass()) Which is not the intent of the matcher. Doing an intanceof test is /not/ commutable. And this type of matcher is both valuable and reasonable. No? -bk</body>
  </mail>
  <mail>
    <header>A Matcher that matches arguments with the same class</header>
    <body>Hello memelet, if you would like use a matcher that regards expected and actual arguments as equal if and only if they have the same class, the matcher may look like this: So an expectation of will match every call to aMethod with a String argument. - Tammo</body>
  </mail>
  <mail>
    <header>Re: A Matcher that matches arguments with the same class</header>
    <body>I don't want 'equals' however, but 'instanceof'. Its ok for the callers to pass in subclasses of the expected class. -barry /S=1705007181:HM/EXP=1091293171/A=2128215/R=0/SIG=10se96mf6/*http://companion.ya\ hoo.com -- Barry Kaplan bkaplan@...</body>
  </mail>
  <mail>
    <header>Re: Class extension and non-public constructors</header>
    <body>sorry for this late answer... Microsft just decided that it would be nice to enable a junk mail filter without telling me and then to filter most of the mailing lists I'm subscribing to... I just discovered that and so here the answer: No, it's not yet since Tammo didn't release any version above the original 1.1 one. However the 1.1b version available was created using the same ant task used for official releases. So it's fully usable as is and backward compatible. And I can't see any reason of why this fix should not be included a future official release. regular but it which all constructors in private protected protected it's not my constructor, so I public if individual information that applicable law. are hereby of this received attachment and 6/D=gr oups/S=1705007181:HM/EXP=1090461362/A=2128215/R=0/SIG=10se96mf6/*http: //comp M=295196.4901138.6071305.3001176/D=groups/S= Service</body>
  </mail>
  <mail>
    <header>Re: Why does invoke() to a e.FillInStackTrace()?</header>
    <body>I also noticed this kind of problem. And sometimes it's not really easymock's fault. For example, sometime easymock is calling equals() on argument passed to mocked methods. And sometime this equal crashes (because the param wasn't initialised correctly). And then you have not clue of what happened so you debug. Here's a test case showing what I mean: -------------------------- ---------------------------- And the stack trace: java.lang.Error at org.easymock.internal.ObjectMethodsFilter.invoke (ObjectMethodsFilter.java:44) at $Proxy0.foo(Unknown Source) at testeasymock.TestEasymock.testError(TestEasymock.java:34) As you can see, the stack trace is starting from the fillStackTrace and so you have no clue of why it really crashed. I agree that when it crashes in easymock because of bad caller usage, it should return meaningful explanations as much as possible. But if it doesn't, the best thing to do from my point of view is to return the longest stack trace possible. (EasymockHelper.java:37) (EasymockHelper.java:83) (EasymockHelper.java:59) (EasymockHelper.java:35) (AbstractTestCase.java:63) (TestFixGateway.java:366)</body>
  </mail>
  <mail>
    <header>Re: New features proposal submitted to your approbation</header>
    <body>Thanks memelet for your support. And I don't think your code need refactoring. It's an usual case. Lets say you have a method taking a list of transactions and that sums up their values. You will pass something like a list of two transactions and make sure the returned result is ok. And to do this you need a list of mocked transactions. But then you notice that creating a list of transactions is something you do a lot in your tests, so you create a fixture returning a nice list of transactions an use it everywhere. But then you don't have the MockControls anymore and you do something sad like the Map proposed by memelet. Or you return a list of MockControl and then create a list of Mocks from it copy pasting this in all your tests which is just as sad. I really think we are in front of a useful and reasonable feature here. Cheers, Henri collections?</body>
  </mail>
  <mail>
    <header>RE: A Matcher that matches arguments with the same class</header>
    <body>Then use isAssignableFrom instead of equals. Cheers, Ilja</body>
  </mail>
  <mail>
    <header>Re: A Matcher that matches arguments with the same class</header>
    <body>isAssignableFrom() is /not/ commutable. The way the matchers are called (ie, where the expected and actual get swapped) will cause the matcher to fail/succeed when it should not. -bk</body>
  </mail>
  <mail>
    <header>Getting a Mock for HttpURLConnection object or URL object</header>
    <body>Hello All: I am using the EasyMock1.1 and also EasyMock Class Extension 1.1. One of my methods requires me to pass a Mock HttpURLConnection object into one of the methods. I cannot mock java.net.HttpURLConnection since it does not have a visible ctor. I tried to mock the java.net.URL object.  However since URL is a final class I cannot do that I understand that I can extend the HttpURLConnection class, say MyHttpURLConnection, and then go ahead and create a Mock of MyHttpURLConnection. Is this the only way to get around this issue? All feedback is below.  Thank you. Gowtham.</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock 1.1 and EasyMock Class Extension 1.1 are available</header>
    <body>I wasn't aware it was hosted on sourceforge - there's not a link (that I see) on the EasyMock site. Also, the download link on SourceForge is outdated (1.0).  That's pretty confusing - I would think that if Tammo is hosting the downloads on easymock.org, the SF File Releases section should be empty (no public releases).</body>
  </mail>
  <mail>
    <header>Re: Getting a Mock for HttpURLConnection object or URL object</header>
    <body>Thank you for the pointer.  I will try this out. Gowtham. at for unit constructor and URL object groups companio of</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock 1.1 and EasyMock Class Extension 1.1 are available</header>
    <body>You're right, it is not really in use. Bug reports should be sent to the EasyMock YahooGroup. - Tammo</body>
  </mail>
  <mail>
    <header>NPE working with class extension</header>
    <body>Hello, I've looked into the code, and can't seem to find the source of this error. I'm using easymock 1.1 w/ class extension, and cglib 2.0.1. This line: MockClassControl.createControl(ServletRequestDataBinder.class, Generates a NPE.  That is the only constructor on that object.  I've included the stack trace below. Any ideas on what could be happening?  I've tried this with a class with a noarg constructor, and it works great. BTW, the javadoc page for the class I'm trying to mock is  estDataBinder.html Thanks very much for your help! Seth net.sf.cglib.core.CodeGenerationException: java.lang.NullPointerException--&amp;gt;null at net.sf.cglib.core.ReflectUtils.newInstance(ReflectUtils.java:273) at net.sf.cglib.core.ReflectUtils.newInstance(ReflectUtils.java:258) at net.sf.cglib.proxy.Enhancer.createUsingReflection(Enhancer.java:585) at net.sf.cglib.proxy.Enhancer.firstInstance(Enhancer.java:514) at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:195) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:406) at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:337) at org.easymock.classextension.MockClassControl$ClassProxyFactory.createProxy(MockC\ lassControl.java:81) at org.easymock.MockControl.&amp;lt;init&amp;gt;(MockControl.java:125) at org.easymock.classextension.MockClassControl.&amp;lt;init&amp;gt;(MockClassControl.java:356) at org.easymock.classextension.MockClassControl.&amp;lt;init&amp;gt;(MockClassControl.java:367) at org.easymock.classextension.MockClassControl.createControl(MockClassControl.java\ :177) at com.hic.eboss.web.BizNameDescControllerTest.testInitBinder(BizNameDescController\ Test.java:75)</body>
  </mail>
  <mail>
    <header>RE: NPE working with class extension</header>
    <body>I'll check deeper tonight. The problem is probably that the constructor is calling a mocked method. I managed to reproduce it with the following code: public class TestMock extends TestCase The problem is that normally I solve that by excluding from the mocked methods the ones called by the constructor. I don't quite like that but I didn't thought of something better yet. However, in this case it doesn't seem to work. testSuccess() is also failing. With the following exception: Caused by: java.lang.ClassNotFoundException: com/bnpparibas/grp/bv/cl/inx/repair/scanswer/TestMock$A$$EnhancerByCGLIB$$c62df3\ a1-2 at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:141) at com.bnpparibas.grp.bv.cl.inx.repair.scanswer.TestMock$A$$EnhancerByCGLIB$$c62df3\ a1-2.CGLIB$STATIC_HOOK(&amp;lt;generated&amp;gt;) at com.bnpparibas.grp.bv.cl.inx.repair.scanswer.TestMock$A$$EnhancerByCGLIB$$c62df3\ a1-2.&amp;lt;clinit&amp;gt;(&amp;lt;generated&amp;gt;) ... 30 more This is the part I need to investigate... If anybody has have an idea... uestDataBinder.html ) ClassControl.java:81) a:177) rTest.java:75) _________________________________________________________________ The new MSN 8: smart spam protection and 2 months FREE*</body>
  </mail>
  <mail>
    <header>Easymock group - host on gmane</header>
    <body>Is it possible to subscribe this group on gmane.org, so we can read the newsgroup through a newsreader? Omair</body>
  </mail>
  <mail>
    <header>Understanding setThrowable()</header>
    <body>Ok, This is probably a REALLY dumb question. But is the purpose of setThrowable(): 1. to set the expected behavior of the method call given the parameters and verify, or 2. is it to specify that the method should in fact throw that Exception when called and throw it? The reason I ask is that I'm trying to tell one of my mocks to fail in order to test the error handling code in my business object. I want to test that it handles a communication failure to the database, for instance, correctly. It doesn't seem to be throwing the exception I've specified. So either I'm doing something wrong, or it's the former scenario. Thanks, Michael</body>
  </mail>
  <mail>
    <header>Re: Understanding setThrowable()</header>
    <body>Ah, hiding the documentation in the Javadocs. Tricky.   :) Kidding. Anyways, yeah, that's pretty clear. Thanks. Michael so the latter scenario is what you should expect. Dig deeper and you should find the cause to your mystery (I've experienced the same too). fail database, ---------- Service.</body>
  </mail>
  <mail>
    <header>Re: Understanding setThrowable()</header>
    <body>Ok, In case anybody is searching the archives for the solution to the problem, here's what I found. The order of the calls is very important. If you are using setThrowable with setMatcher() and setReturnValue(), it has to be done in this order: 1. Mock method call 2. setMatcher() - must be done first 3. setThrowable() 4. setReturnValue() Reading the Javadocs helped. I'm so used to people writing crappy javadocs ... ok, that's not a good excuse. Hope this helps somebody else. Michael so the latter scenario is what you should expect. Dig deeper and you should find the cause to your mystery (I've experienced the same too). fail database, ---------- Service.</body>
  </mail>
  <mail>
    <header>Re: Understanding setThrowable()</header>
    <body>There's a bug in my approach below. Calling setThrowable AND setReturnValue implies TWO calls to the Mock method at step 1. you too). I -- of</body>
  </mail>
  <mail>
    <header>Re: Re: Understanding setThrowable()</header>
    <body>Am Freitag, 04.06.04 um 17:13 Uhr schrieb Michael Schaefer: Hello Micheal, That is correct behavior. If a method throws an exception, it won't return a value. The fourth call is not needed. Greetings from XP2004, Tammo - Tammo</body>
  </mail>
  <mail>
    <header>request: Ability to specify matchers per call</header>
    <body>Sometimes we see the need to specify a matcher for each all to a method. Not being able to do this causes two problems: 1. Its makes the matcher implementation unecessarily complex and open to multiple concerns. 2. It makes the test setup more complex. If expectations are setup in seperate methods each method must be aware that another method may have setup a matcher and be sure not to it again. This is a problem even when the same matcher implementation is used.</body>
  </mail>
  <mail>
    <header>New features proposal submitted to your approbation</header>
    <body>Hello, I just added two zip files to this group (easymock and easymockclassextension 1.1a... it's not an official version even if it looks like... I just couldn't find a better name). These files are containing a modified version of easymock from easymock cvs head (which is basically version 1.1). They contain two new features that I find useful and so I just want to see what you think of it. I will really appreciate some feekback, positive of not. First feature is an IMock interface (something I talked about a long time ago) implemented by all created mocks. It allow you to have a back pointer to the MockControl class. It basically goes like this: I'm using that to build mock objects' tree. There is a test class and a sample added to the source code to show how it goes. Second, I've added a bunch of expectAndDefaultReturn / expectAndDefaultThrow to MockControl. It's the exact same as calling. I'm using this a lot because I tend not to know how many some methods are called (especially getters). The zip files are including the usual easymock packaging made with ant plus a cvs diff and internal change comments. I've also updated the news.txt in the documentation to explain what has changed (which is more or less what I just explained above). There are tests for everything that changed and old tests are still successful (duh...). Next step on my todo list, have class extension working with constructor calling internal methods... I should have something soon. Until then, have fun, Henri</body>
  </mail>
  <mail>
    <header>Race condition in ResultListMap causes NullPointerException during verify() ?</header>
    <body>I'm seeing weirdness when using EasyMock 1.1. I'm running tests in a single TestCase, and sometimes one of them fails. I can run just the test, and it'll pass first time, then fail the next time I run it. This is happening both when I run the test in IntelliJ, and when I run it from a command-line Ant build. This is on Windows XP. The stack trace I have, after adding a bit of debug, is the following: Caught runtime exception: java.lang.NullPointerException java.lang.NullPointerException at org.easymock.internal.ResultListMap.verify(ResultListMap.java:96) at org.easymock.internal.UnorderedBehavior.doVerify(UnorderedBehavior.java:63) at org.easymock.internal.AbstractBehavior.verify(AbstractBehavior.java:61) at org.easymock.internal.ReplayState.verify(ReplayState.java:25) at org.easymock.MockControl.verify(MockControl.java:189) at com.xyz.xyzTestCase.testXYZ(xyzTestCase.java:694) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:324) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at junit.textui.TestRunner.doRun(TestRunner.java:116) at com.intellij.rt.execution.junit2.IdeaJUnitAgent.doRun(Unknown Source) at junit.textui.TestRunner.start(TestRunner.java:172) at com.intellij.rt.execution.junit.TextTestRunner2.startRunnerWithArgs(Unknown Source) at com.intellij.rt.execution.junit2.JUnitStarter.prepareStreamsAndStart(Unknown Source) at com.intellij.rt.execution.junit2.JUnitStarter.main(Unknown Source) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.jav\ a:25) at java.lang.reflect.Method.invoke(Method.java:324) at com.intellij.rt.execution.application.AppMain.main(Unknown Source) The corresponding code fragment is this: So it looks like 'list' is null sometimes. I can't seem to figure out why this is. I wrapped 'resultListMap' with a synchronized map and that didn't help the situation. Any ideas why this might happen? Could my test code be holding onto something it shouldn't, and causing the EasyMock code to fall over? Cheers, Mike.</body>
  </mail>
  <mail>
    <header>Important Information for easymock Members</header>
    <body>I had really high interest rates on my home loan. I saved thousands of dollars on home payments. And you can too. Interest rates are as low as can be, And Yes Even you can take advantage of this. This is how. Stop in and fill out this thirty-second form, to Begin the money saving process.  Get a 100% free custom quote even If you have bad credit. Our specialists will Work with you exclusively to save you the most money possible. This email was sent because you joined our group. If you do not wish to recieve any emails, unsubscribe. by sending a mail here easymock-unsubscribe@yahoogroups.com</body>
  </mail>
  <mail>
    <header>Re: Race condition in ResultListMap causes NullPointerException during verify() ?</header>
    <body>easymock@yahoogroups.com schrieb am 29.06.04 21:21:15: This is the first report on this issue. Could you come up with a simple test case that still sometimes falls and sometimes passes? It would be a big help to find the source of the problem. - Tammo</body>
  </mail>
  <mail>
    <header>wanted: setDefaultVoidCallable() + verify number of calls</header>
    <body>Hi, all, I'm quite new to EasyMock and turned up only a partial answer to this question in the list archive, so forgive me if it's been answered before. I realize what I'm asking for may not be feasible, but in my test code I'm doing the following: The reason I'm using setDefaultVoidCallable() is that the values in thisCookie are GUID's and thus guaranteed to be different on every call.  I therefore don't care what the value is, but I do happen to care to know that addCookie() is called exactly three times by the code under test.  Is it possible to do that in EasyMock (or extend EasyMock with this capability)? Al ===== Albert Davidson Chou</body>
  </mail>
  <mail>
    <header>Re: wanted: setDefaultVoidCallable() + verify number of calls</header>
    <body>You need to set a matcher that doesn't care about the param passed, i.e. the MockControl.ALWAYS_MATCHER See Argument Matchers section in the documentation. You will be able to do something like this: It should do what you want. Henri ----- Original Message ----- Sent: Monday, July 12, 2004 10:51 PM Subject: [easymock] wanted: setDefaultVoidCallable() + verify number of calls question thisCookie addCookie() do</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.1 and EasyMock Class Extension 1.1 are available</header>
    <body>Hi, I was just wondering, are there other jar file dependencies that you need to have to use the Class Extension API? I'm getting a NoClassDefError looking for "net/sf/cglib/proxy/Callback". I saw somone mentioning something about cglib and I can google for that. But I was wondering: 1. Why this isn't mentioned anywhere (maybe I missed it), and 2. What version this has been tested with. Thanks, Michael org.easymock.internal :-) Tremblay</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.1 and EasyMock Class Extension 1.1 are available</header>
    <body>Ok, for anyone who should happen along and fall into the same pit, here's your way out. Include the following jars in your classpath: 1. CGLIB ( 2. ObjectWeb ASM ( I'm using cglib-2.0.2.jar with asm-1.4.3.jar and it seems to work ok. Michael you the</body>
  </mail>
  <mail>
    <header>RE: Re: EasyMock 1.1 and EasyMock Class Extension 1.1 are available</header>
    <body>Sorry, I wasn't quick enough to prevent you from searching but that's exactly the dependencies you need. You can also use cglib-full-2.0.2 that includes asm. (and in fact you can use any 2.0 version). You also need JDK 1.4 (because I'm using the new Exception framework). _________________________________________________________________ STOP MORE SPAM with the new MSN 8 and get 2 months FREE*</body>
  </mail>
  <mail>
    <header>Class extension and non-public constructors</header>
    <body>I searched the archive, and couldn't find an answer for this.... but it ought to be pretty simple. I can't get the class extension to create a mock for a class in which all constructors are non-public. I get the error "No visible constructors in class ..."  I realize of course that this will never work with private constructors... but wouldn't it be possible to make it work with protected constructors? The generated class would be allowed to invoke a protected constructor. The class I'm trying to mock is a singleton (I know, I know... it's not my code). I don't want to open it up with a public default constructor, so I was hoping to make it protected rather than public.  I'll make it public if I have to, but I'm reluctant. -eric This message and any attachment is intended for use only by the individual or entity to which the email is addressed and may contain information that is privileged, confidential and exempt from disclosure under applicable law. If the reader of this message is not the intended recipient, you are hereby notified that any retention, dissemination, distribution or copying of this communication or any attachment is strictly prohibited. If you have received this communication in error, please delete the e-mail and any attachment and notify Everstream, Inc. immediately by telephone at 440-498-8899.</body>
  </mail>
  <mail>
    <header>Re: Class extension and non-public constructors</header>
    <body>Mmm, I underestimate my code actually. When the constructor is found by easymock, yes indeed, protected ones are not found. That's what I'll fix. However, if you explicitly specify the constructor to use, it works perfectly well. So you just have to do something like this: MockControl ctrl = MockClassControl.createControl(MyClass.class, new to call a no-args protected constructor for example. Hope it helps, Henri ----- Original Message ----- Sent: Monday, July 19, 2004 6:12 PM Subject: [easymock] Class extension and non-public constructors ought to be pretty simple. constructors are non-public. I get the error "No visible constructors in class ..."  I realize of course that this will never work with private constructors... but wouldn't it be possible to make it work with protected constructors? The generated class would be allowed to invoke a protected constructor. code). I don't want to open it up with a public default constructor, so I was hoping to make it protected rather than public.  I'll make it public if I have to, but I'm reluctant. or entity to which the email is addressed and may contain information that is privileged, confidential and exempt from disclosure under applicable law. If the reader of this message is not the intended recipient, you are hereby notified that any retention, dissemination, distribution or copying of this communication or any attachment is strictly prohibited. If you have received this communication in error, please delete the e-mail and any attachment and notify Everstream, Inc. immediately by telephone at 440-498-8899.</body>
  </mail>
  <mail>
    <header>Re: Class extension and non-public constructors</header>
    <body>That's my fault actually. I'm only looking at the public constructors when doing the mock. I'll try to fix that (should be easy except one little trick about getDeclaredConstructors() ). Meanwhile, you need to have it public yes. Henri ----- Original Message ----- Sent: Monday, July 19, 2004 6:12 PM Subject: [easymock] Class extension and non-public constructors ought to be pretty simple. constructors are non-public. I get the error "No visible constructors in class ..."  I realize of course that this will never work with private constructors... but wouldn't it be possible to make it work with protected constructors? The generated class would be allowed to invoke a protected constructor. code). I don't want to open it up with a public default constructor, so I was hoping to make it protected rather than public.  I'll make it public if I have to, but I'm reluctant. or entity to which the email is addressed and may contain information that is privileged, confidential and exempt from disclosure under applicable law. If the reader of this message is not the intended recipient, you are hereby notified that any retention, dissemination, distribution or copying of this communication or any attachment is strictly prohibited. If you have received this communication in error, please delete the e-mail and any attachment and notify Everstream, Inc. immediately by telephone at 440-498-8899.</body>
  </mail>
  <mail>
    <header>Class extension and non-public constructors fix available</header>
    <body>Hello everyone, I just uploaded a new easymock packaging (that I called 1.1b). It contains the fix of the issue encounter by Eric Williams which was that the easymock class extension doesn't guess the constructor to use correctly when this constructor is protected (or package scope). The algorithm is now the following: 1- Find a new args constructor 2- Find the first not private constructor and return it 3- If none are found, throw an IllegalArgumentException The packaging contains - The tests (also the 1.1a ones, I think they were missing in 1.1a packaging) - Comments about what internally changed - A diff towards the 1.1a version (sorry, it's the version I've got locally) - All usual stuff your used to find in an easymock packaging Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: MockClassControl fails with only default constructor</header>
    <body>The example you used had a private constructor. And cglib will never then be able to create the instance. But in my scenario the class had no explicitly defined constructor, which means the compiler created a public default constructor. It was for that case my patch/hack was targeted. And for that case it did indeed work. (Eeek. I just looked at my post and see that all code formatting was lost. Sorry about that.) The cglib call 'enhancer.create()' will work for a default constructor. But I thought to make it cleaner a bit of refactoring would be required so if's would not be required in more than one place.</body>
  </mail>
  <mail>
    <header>RE: Re: MockClassControl fails with only default constructor</header>
    <body>If you have no constructor defined explicitly, getConstructor(new Class[0]) will still find the default constructor. I have a test checking that. I can have another look but from as far as I know, the java reflection consider the bytecode, not the source. So it will find a constructor whether it's the compiler or user that added it. _________________________________________________________________ MSN 8 with e-mail virus protection service: 2 months FREE*</body>
  </mail>
  <mail>
    <header>Re: MockClassControl fails with only default constructor</header>
    <body>Hmm. That is exactly the situation in which I was getting the array out of bounds exception, and what the code I added worked around. Could you post the test that you are using? --- In easymock@yahoogroups.com, "Henri Tremblay" Class[0]) that. I can consider it's the</body>
  </mail>
  <mail>
    <header>Re: MockClassControl fails with only default constructor</header>
    <body>Looks good to me. I'll have to dig deeper to see why my class with no declared constructor got the array-out-bounds exception. Thanks for the help Henri.</body>
  </mail>
  <mail>
    <header>Re: MockClassControl fails with only default constructor</header>
    <body>Ok, I found out what was the problem. The class was package scope. If I make it public scope, then your implementation works. But if its package scope, only my implementation works. I also see similar behavior with regular MockControl -- it has trouble returning a mock result of a package scope interface. I'm going to need to look into that some more also, because I don't always want to make an interface public.</body>
  </mail>
  <mail>
    <header>Question regarding mocking something with a wildcard parameter</header>
    <body>Is there a way I can mock a object and call a parameter that takes anything (like a wildcard) and returns the value I want? For example: A = (ClassA) control.getMock() in which XXX is unknown because it is buried deep down, and is called somehow when a Set or TreeSet is iterated. So is there a way to define the mock object so that it will return the values I want regardless of the parameter?</body>
  </mail>
  <mail>
    <header>Re: Question regarding mocking something with a wildcard parameter</header>
    <body>You can try MockControl.createNiceControl(), and/or setDefaultReturnValue().</body>
  </mail>
  <mail>
    <header>Re: Question regarding mocking something with a wildcard parameter</header>
    <body>Thanks. I actually figured that out with the passing nulls and calling setDefaultReturnValue(). I also tried the NiceControl but I recommend not using it because it is too "nice". It ignores all the possible errors and sometimes changes the testing result. setDefaultReturnValue().</body>
  </mail>
  <mail>
    <header>Error mocking concret class</header>
    <body>When I upgrade to the MockClassControl v2.1, with EasyMock v1.0.1b, and CGLIB v2.01; I am unable to mock a concret class which does not have a default construct, but only 1 parameterized constructor. This line of code worked just fine with easymock 1.0, cglib 1.0 and the old patch for mocking class. * Here is the code line (I changed to use MockClassControl) pcsResultHandlerMockControl= MockClassControl.createControl * the Parameters.class is an interface, and the parameters object is an instance of an implementation class of Parameters.class * Here is the error I am getting when running JUnit: net.sf.cglib.core.CodeGenerationException: at net.sf.cglib.core.ReflectUtils.getConstructor (ReflectUtils.java:286) at net.sf.cglib.core.ReflectUtils.newInstance (ReflectUtils.java:258) at net.sf.cglib.proxy.Enhancer.createUsingReflection (Enhancer.java:585) at net.sf.cglib.proxy.Enhancer.firstInstance (Enhancer.java:514) at net.sf.cglib.core.AbstractClassGenerator.create (AbstractClassGenerator.java:195) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:406) at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:337) at org.easymock.classextension.MockClassControl$ClassProxyFactory.createP roxy(MockClassControl.java:74) at org.easymock.MockControl.&amp;lt;init&amp;gt;(MockControl.java:119) (MockClassControl.java:325) (MockClassControl.java:333) at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:193) at com.stpaul.pcs.xml.test.DSFResultProcessorTest.setUp (DSFResultProcessorTest.java:148) at junit.framework.TestCase.runBare(TestCase.java:125) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected (TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests (RemoteTestRunner.java:329) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run (RemoteTestRunner.java:218) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main (RemoteTestRunner.java:151)</body>
  </mail>
  <mail>
    <header>build a jar</header>
    <body>Hi, I just joined this group recently so I am kinda lost in all the messages. It looks like there has been some enhancements to make easymock able to mock any classes and interfaces. I would like to use it, but I don't know where I can get a jar or build one. Could some one guide me a little. I have the source of easymock 1.0, Ant, jdk and a typical development environment. What else do I need? Has there been any thoughts to move this project to sourceforge where a CVS repository is available? Thanks Daniel</body>
  </mail>
  <mail>
    <header>Re: Error mocking concret class - More Info</header>
    <body>1. Mocking class with the default constructor works just fine 2. The class that I'm mocking there has 3 super classes. The immediate two super classes have the same format constructor, but the topmost class only has the default constructor. As illustrated below: Object() 3. I have not tried to mock classes that have the same format constructor in the entire hearchy, but I suspect that mocking in that scenario should work fine. So I believe that the problem is just with this scenario. 4. While debugging, I believe that the proxying process is working for Class3 and Class2, but blows up when it reaches class1() because it doesn't find a Class1(Parameters) constructor. Can someone explain to me how to make this work? thanks.</body>
  </mail>
  <mail>
    <header>Re: build a jar</header>
    <body>I packaged the "initial" version of the class-mocking patch as a jar, and it is available in the "files" section of the group. Since then, there have been some modifications to the patch, but I have not had the time or need to get them and package a new jar.  It is very easy to do, if anyone already has it packaged as a patch maybe they could stick it in the files section also. As for moving to a host with a CVS repository or making these "patches" somewhat official, I'm all for that... On a related note, if you are looking for another dynamic-proxy-based mock solution that is in active development, check out jmock.org. -- Chad</body>
  </mail>
  <mail>
    <header>Help</header>
    <body>Can someone help me with what I am doing wrong in this test? I am using EasyMock v1.0.1b, CG Lib v2.01, MockClassControl v2.1, JUnit 3.8.1 Here is the test class ====================== new Class[0], new Object[0], ("setCollection", new Class[0]) ================= Here is the ouput when I run it: ================= Begin --- java.lang.NoSuchMethodException: setCollection at java.lang.Class.getMethod0(Native Method) at java.lang.Class.getMethod(Class.java:928) at com.stpaul.pcs.test.EasyMockTest.main(EasyMockTest.java:52) java.lang.NullPointerException at org.easymock.classextension.MockClassControl$1.intercept (MockClassControl.java:60) at com.stpaul.pcs.test.Testing$$EnhancerByCGLIB$$339e85b6.setCollection (&amp;lt;generated&amp;gt;) at com.stpaul.pcs.test.Testing.&amp;lt;init&amp;gt;(EasyMockTest.java:32) at (&amp;lt;generated&amp;gt;) at com.stpaul.pcs.test.Testing$$EnhancerByCGLIB$$339e85b6.newInstance (&amp;lt;generated&amp;gt;) at net.sf.cglib.proxy.Enhancer.nextInstance(Enhancer.java:529) at net.sf.cglib.core.AbstractClassGenerator.create (AbstractClassGenerator.java:208) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:406) at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:337) at org.easymock.classextension.MockClassControl$ClassProxyFactory.createP roxy(MockClassControl.java:79) at org.easymock.MockControl.&amp;lt;init&amp;gt;(MockControl.java:133) (MockClassControl.java:328) (MockClassControl.java:334) at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:193) at com.stpaul.pcs.test.EasyMockTest.main(EasyMockTest.java:69) at org.easymock.classextension.MockClassControl.createControl (MockClassControl.java:193) at com.stpaul.pcs.test.EasyMockTest.main(EasyMockTest.java:69) Exception in thread "main" ======= I can't seem to mock any class that using their parameterized constructor(s).</body>
  </mail>
  <mail>
    <header>Re: Help</header>
    <body>There was an error in test #2: replacing 'new class[0]' with new class However this is really the same as test #1. After some more digging, I believe the problem is that the constructor calls a method which has not yet been mocked, hence triggering the NullPointerException. It is possible to enhance MockClassControl in such a way that it creates mocked methods before the call to the constructor? The reason being that when mocking classes, it is not always possible to change the target class' constructor and re-code it to remove method calls. The problem also occurs if I were to change the default constructor to call method like the following:</body>
  </mail>
  <mail>
    <header>Re: Re: Help</header>
    <body>Look at the mailing list archive on jmock.org, at the thread titled: "Using CGLib with a class that makes a method call in the default constructor".  It discusses this exact problem.</body>
  </mail>
  <mail>
    <header>Re: build a jar</header>
    <body>I used to think that, but I changed my mind :). The only drawback of jMock is the requirement to hardcode the method name in jMock (and losing some automated refactoring and code completion support). However, it turns out in practice to be MUCH less verbose, more concise, and more readable than the multiple expressions required with a record-playback approach such as EasyMock.  In practice, I believe the tradeoff is worth it, and the jMock crew have the right idea.  Your mileage may vary. Only Tammo can answer this :) Good Luck, Chad</body>
  </mail>
  <mail>
    <header>EasyMock 1.1 and EasyMock Class Extension 1.1 are available</header>
    <body>Hello all, I have just uploaded - EasyMock 1.1, containing a few bug fixes, some refactorings - EasyMock Class Extension 1.1, a slightly modified version of the latest Yahoo!Group. All the best, - Tammo</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.1 and EasyMock Class Extension 1.1 are available</header>
    <body>Woohoo - you go! .. and thanks to you too! -- Chad</body>
  </mail>
  <mail>
    <header>Re: Help</header>
    <body>Here is the actual problem: I'm writing a JUnit test for a class in my application called 'UploadProcessBean'. Within its inner working code, it uses another class called 'PCSResultBean', which subclasses a class 'ResultBean' provided by our corporate framework group. That class in turn is a subclass of an IBM-provided framework. When using MockClassControl to mock the 'PCSResultBean', I am encountering an Exception thrown by either EasyMock itself when I mock the default constructor, or by CGLIB itself when I try to mock the constructor with an argument. It is while trying to figure out why I'm getting these exceptions that I used the sample test class from my original post. This helped me to pinpoint the issue as being caused by the constructors within the IBM's code calling a setter method. From the sample test, it looks like that if the IBM did not called the setter method, but just initialized the variable then the neither exceptions would occur. I can't change anything with either frameworks as the only thing that I control is within my application code. How can I successfully mock the 'PCSResultBean' class given that regardless of which constructor I choose to use with MockClassControl.createControl() it blows up.</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.1 and EasyMock Class Extension 1.1 are available</header>
    <body>Two observations about the Extension: 1. The EasyMock documentation states "EasyMock does only work with Java 2, 1.3.1 and above". However the extension only work with JDK 1.4 and above due to the way it chains exception. It would be great to have both softwares adopt the same requirement. 2. EasyMock includes its JUnit tests as part of the download. It would be great to have the JUnit test for the extension bundled as well.</body>
  </mail>
  <mail>
    <header>Re: Help</header>
    <body>I tried Henri' solution to use partial mocking, and it is allowing the code to get past the creation of the mock control. However I see 2 limitations of this: 1. I have to explicitely list all the methods that I want to mock. This is practical only if there are a handfull that I need to mock, but can get long quickly in complex classes. Perhaps an enhancement to MockClassControl to create a control by listing method(s) that one doesn't want to mock would help in this case. 2. By omitting the method(s) that are called inside the constructors, I am no longer able to set their behaviors. This is all right if these methods happen to not be used outside of the constructors, otherwise I will need to be able to set a return value and hence still need to mock them. Maybe I am tackling this whole thing the wrong way, please let me know. thanks.</body>
  </mail>
  <mail>
    <header>Re: Re: EasyMock 1.1 and EasyMock Class Extension 1.1 are available</header>
    <body>Tammo, Would it be possible to make the EasyMock codebase available via public CVS?  That way, people could submit patches for things like this.  I'm NOT proposing you open up commit access to other people - just allow them to submit patches that you can then apply if you approve them. Just an idea, Chad</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.1 and EasyMock Class Extension 1.1 are available</header>
    <body>In fact it's on sourceforge. So there's a bug tracker and CVS. But I don't know if the bug tracker is really used. Tammo, can we use that to propose patches and improvement? Or you prefer us to only work with the yahoo group (mixed with sourceforge cvs). About the two points below, 1- I always forgot about that. I think we should propose something that handle both 1.3 and 1.4. It's only the new Error(e) that breaks it all. 2- I don't think it's necessary since you need easymock base jar to use the class extension. My little 5 cents, Henri public I'm allow great ------</body>
  </mail>
  <mail>
    <header>Re: Help</header>
    <body>see one In fact I though about that when I did this feature. I ended by concluding that usually there are less methods called (and so that need to be mocked) so it did it this way. Maybe I could allow both ways. One thing to remember is that if you want to mock a method, you will record something for it. So having the list of mocked methods is easier. The only problem is that currently, if you forget to mock something which is called, it gives and assertion error. In case of partial mocking, it you forget to specify a method to mock, it will silently call the real method. I'm not sure my partial mocking thing is quite mature yet. It's useful but I think it can be improved. I need to think about it when I'll have two minutes. And I'm open to any proposal. constructors, Maybe the best way is to do what I proposed earlier today, to just skip any method call in the constructor. So it will build an empty object will all public methods mocked. Or maybe be able to provided a list of method to skip.</body>
  </mail>
  <mail>
    <header>Re: Please help</header>
    <body>I think he may be trying to verify the data that the Value Object parameter contains.  To do this, you could write a custom ParameterMatcher. However, a better approach would probably be to abstract out the creation of the value object to a separate class, and test that in isolation.  This would avoid the need for a mock. Thanks, Chad file=ny_ts_splash.html file=ny_ts_splash.html</body>
  </mail>
  <mail>
    <header>Need to get the Control of a Mock</header>
    <body>Hi, You are using Easymock at work and yesterday I felt on a problem. I'm having a fixture containing an object with some other aggregated objects. Something like: My goal was to do a mock for every B that I will put in bList. This will be created in a fixture used by my test class. Like this: The problem is that there is no way I can retrieve the MockControls created anymore in the calling method of getMockedA. So I've start thinking it will be nice to have such a possibility. And here's the solution I've implemented. I would like to have your opinion and if it sounds great to add it in the easymock next release. The idea was to have an interface that every mock will implement. I called it IEasyMock. It currently only has one method: getMockControl. So to retrieve the control from a mock, you do the following: Nice and clean. And it's now possible to add other useful methods on the interface. Here's the code: IEasyMock class: /** * Interface implemented by every mocks created by EasyMock. */ IEasyMockTest class: Diff of JavaProxyFactory: 11,12d11 18c16 --- Diff of MockControl: 124,127d124 method on IEasyMock Cheers, Henri</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.0.1 available</header>
    <body>Agreed, that would be great. extension 1.0.1. copy of it</body>
  </mail>
  <mail>
    <header>Re: Need to get the Control of a Mock</header>
    <body>I pretty much agree that merging Mock and Control is a little bit extreme. It's not what I propose. I just offer a back pointer from the mock to the control. This back pointer is accessible from a generic interface implemented by every mock Easymock is creating. I know Easymock is extensible and I could have done my own MockControl extension and its dedicated JavaProxyFactory. However, since I think this change will benefit everyone, it will be a lot nicer to have it integrated directly in Easymock I think. Am I the only one who have this need? If yes, what are you doing instead people? Henri P.S: I didn't understood the 3 interfaces thing. If MockControl and Mock were merge, the mock would implement 2 interfaces: The mocked one and MockControl. I don't see anything else. P.P.S: Changing subjet, does somebody knows if the ability to mock classes (Joe Schelman patch) will finally be integrated in easymock or not? months requirement instead of more</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. that had a constructor with parameters that are interfaces. You can access this file at the URL  To learn more about file sharing for your group, please visit  Regards,</body>
  </mail>
  <mail>
    <header>Where to get the latest easymock.jar</header>
    <body>Hi, has the pathch included for creating mock for Class as well as Interfaces. Or do I have to recreate the jar file. Thanks Sal</body>
  </mail>
  <mail>
    <header>Re: Where to get the latest easymock.jar</header>
    <body>Hi, The jar is in the files section of the mailing list on yahoo - I posted it there.  However, it looks like it should be rebuilt with the patch that Joel just submitted. FYI - I also patched the jar to run under JDK 1.3, I don't know if Joel made this change in the source for his latest patch. I'll make a new jar and post it if nobody beats me to it :). Tammo, are you going to make a release with this functionality?  I've heard a few people ask for it, it seems to be pretty popular, and it has been very stable for me.  Only problem I've had is some incompatibilities with other bytecode-manipulation tools (AspectWerks), but apparently this is an issue in BCEL that is going to be fixed. Only other complaint is that the message is pretty cryptic if you forget to specify arguments for a constructor with arguments.  It would be nice if it told you exactly what you did wrong. Thanks, Chad</body>
  </mail>
  <mail>
    <header>Re: Where to get the latest easymock.jar</header>
    <body>Why not move the code to use cglib2? It uses ASM now exclusively, which is much smaller and faster, compared to BCEL normally used by cglib1...</body>
  </mail>
  <mail>
    <header>Re: Where to get the latest easymock.jar</header>
    <body>Oops, it does use cglib, not BCEL.  My bad, I was confused.</body>
  </mail>
  <mail>
    <header>RE: automatic replay/verify</header>
    <body>I think this may be overkill.  This approach forces you to do all of your init in the setUp method, which a lot of people, myself included, arent big fans of since it makes the test harder to follow.   You also have to inherit from an abstract TestCase.  Again, not something you want to do unless you have to. But, if youre OK with all of that, one alternative is to use some sort of MockFactory to create all of your mocks.  Then you can add a replayAll and a verifyAll to the factory and call those in your AbstractTestCase.  I use my own simple factory for just this case, so at least if I add another mock to a test case, I know that I dont have to add another verify/replay pair. If you want to get really fancy with the factory (and this would need some additional methods on the MockControl), you could have a method such as myFactory.checkMocks that calls wasVerifyCalled and wasReplayCalled or something along those lines.  Simply call checkMocks in the tearDown and then at least you would know that you forgot to put a replayAll and verifyAll around your test.  (tearDown gets called even if theres an error in the test, right?  I can never remember.) Rex Madden www.fetchaflick.com rex@... -----Original Message----- From: Casey Huang [mailto:casey@...] Sent: Wednesday, January 21, 2004 5:10 PM To: easymock@yahoogroups.com Subject: [easymock] automatic replay/verify I just started using easymock for writing unit tests. I like its ease of use compared to static MockObject but I also found that the replay()/verify() to be a bit irritating since whenever we add a new mock object, we have to add a corresponding replay() and verify() and oftentimes we forget to add and the tests would fail/err. Although it usually doesn't take too long to figure out why the tests fail/err, notheless it's time lost not doing productive work. In order to ease the pain, I added two methods replay() and verify() in the base class that extends TestCase so it can reflectively discover the MockControl fields and call its replay() and verify(). This way, we no longer need to remember to add replay() and verify() for each and every mock object we add. Here is the example.   Example 1. (before introducing replay()/verify())                       // setup code omitted     // assertion omitted       // setup code omitted     // assertion omitted       // setup code omitted     // assertion omitted       Suppose in our new test case, we need another mock object so we add the following two lines of code to the declaration and setUp():     mockOrderGeneratorControl =   Then we also have to add the following code in replay()/verify() respectively (this is where we sometimes forget).   Because of that, I decided to add replay() and verify() in base class AbstractTestCase so it can automatically discover MockControl fields and call replay() and verify(). Here is the code:                   List allFields =         Collection mockControlFields = CollectionUtils.select(allFields,                 return ((Field)                                 MockControl mockControlInstance = (MockControl)   With these two methods, we no longer need the two private replay() and verify() methods in our test class and we no longer have to worry about adding new replay()/verify() when we add a new mock object.   Actually, these two methods can be added to MockControl class as a static methods so we can conveniently use it to replay and verify like this: Where "this" is the test class (TestExchangeOrderManager in my example).   If we look at the resulting code after refactoring, we notice that we surround our test code with replay() and verify() in each test case. This is tedious, too. Therefore if we could somehow automatically insert replay()/verify() before/after the test code, it could save us some tedious work and time. Intercept and dynamic proxy come to the rescue.   Here is what it looks like after adding dynamic proxy to intercept the test code and do the reply()/verify() for us.   Example 2. (After introducing dynamic proxy/Interceptor pattern)                   exchangeOrderManager = (ExchagneOrderManager ) DynamicProxy.getProxy(new ExchangeOrderManager(...),         // setup code omitted     // assertion omitted       // setup code omitted     // assertion omitted       // setup code omitted     // assertion omitted   And here is the DynamicProxy class.                   public static Object getProxy(Object delegate, Class interfaceName,         return Proxy.newProxyInstance(delegate.getClass().getClassLoader(), new Class[]       public Object invoke(Object proxy, Method method, Object[] args)   Again, this can be implemented in easymock so we can use easymock in the setUp() method like this :   exchangeOrderManager = (ExchagneOrderManager ) MockControl.getProxy(new   Then all the replay()/verify() would be done by easymock automatically and we don't even have to know replay/verify is being done as long as we set up our test case properly. For the time being, though, you can use the code above to achieve the same thing. Thanks!   Casey Huang   casey@...   Yahoo! Groups Links  To visit your group on the web, go to:     To unsubscribe from this group, send an email to: easymock-unsubscribe@yahoogroups.com    Your use of Yahoo! Groups is subject to the Yahoo! Terms of Service.</body>
  </mail>
  <mail>
    <header>ID liochtc... thanks</header>
    <body>Yours ID cgvqrmcsd -- Thank</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. constructor "guessing" algorithm (see javadoc). Tested on a JUnit test class that can be provided if requested. You can access this file at the URL  To learn more about file sharing for your group, please visit  Regards,</body>
  </mail>
  <mail>
    <header>Re: New file uploaded to easymock</header>
    <body>Ha! Great. Kind of ironic that I just upgraded it to use cglib2 yesterday as well. That's okay, you've probably had more time to think it through than I have, so I'll grab yours. Thanks! -joel shellman the constructor "guessing" algorithm (see javadoc). Tested on a JUnit test class that can be provided if requested.</body>
  </mail>
  <mail>
    <header>Be able to do a partial class mock</header>
    <body>Hello, I'm just having an idea and I would like to know what you guys think of it and if you can help me solving it. When testing, it occurs sometime that you are testing a method calling other methods in the same class. You would like to mock them to make the test easier. What I'm doing so far is a manual mock overloading my class and overiding the methods I want to mock but leaving the tested one as is. What I was thinking is since we are now having a nice MockClassControl, would it be possible to create a class mock with it that will mock everything except, lets say, one method? It will mean that the mock will work as usual in easymock except for one method where the mock will call the method on the superclass instead of returning recorded data. What do you think? Will it be possible? How can we do that with cglib? Thanks for your feedback, Henri</body>
  </mail>
  <mail>
    <header>How to handel equals()?</header>
    <body>Hi there. Suggest the following test: In this test I have the need to use the equals()-method on a mock, because I know that MyCollection uses the equal()-method in its contain()-method, too. When I try this approach above it gives me the following message: before setting return value So, what's my problem here? Am I testing something in the wrong way? Do I use mocks where I shouldn't? And if so: how could I solve my problem? How should I handle test stuff with regard to the equals()-Method (or other inherited methods from object, such as hashCode() or getClass())? Any hints about that? Best regards, Bernd</body>
  </mail>
  <mail>
    <header>&lt;i&gt;&#xD;
        (No subject)&#xD;
      &lt;/i&gt;</header>
    <body>Yes, you are right, it is really in the documentation. But I would recommend the following paragraph from  docu as well: Ok, everything you wrote is right, but that was just an example about what I meant to explain. CharSequence was the first public interface which came into my mind when I was writing this posting ;-) In fact there were real occasions for me to use equal() on mocks. Now I'll try to deal succesfully with mocks taking this new informations into account :-) Thanks for your help, Bernd</body>
  </mail>
  <mail>
    <header>Re: (unknown)</header>
    <body>in the jmock world, we're working on allowing overrides for those methods, largely because it pushes the design in the right direction. Not sure it's a good idea, though ;-) S.</body>
  </mail>
  <mail>
    <header>MockClassControl fails with only default constructor</header>
    <body>If a class has no delcared constructors MockClassControl will fail to create the instance. The problem starts in 'Constructor getConstructorToUse(Class clazz)' which will attempt to execute 'clazz.getConstructors()[0]' resulting in an array out of bounds exception. I hacked it up to work, but it is really an ugly hack. But here it is anyway (sorry about the formatting): constructor found.</body>
  </mail>
  <mail>
    <header>Re: MockClassControl fails with only default constructor</header>
    <body>Whoops. My hack did not even work fully. This line in createProxy(...): Needs to be: Really, a cleaner solution is needed. If I get the time I'll post it.</body>
  </mail>
  <mail>
    <header>Re: Be able to do a partial class mock</header>
    <body>I don't think it is a very good idea to try to mock methods on the class under test.  You should strive to test your class as a self-contained unit.  If you start mucking with it's internal functionality via your unit test, you may get unexpected results, and inadvertently invalidate your tests (get false positives). I would instead use the Extract Class refactoring, to pull out the method to it's very own class, and then mock the entire class.  This works OK for me. Now, if you were talking about mocking a single method on a class OTHER than your class under test, then that is a very interesting concept.  I think this could be useful - to let certain specified methods "fall through" the mock to the real class, while intercepting and mocking others.  I think this could be useful in some situations, although I'm not sure I can think of any clear examples... -- Chad</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. of an ArrayOutOfBoundException when no constructor are available in the mocked class You can access this file at the URL  To learn more about file sharing for your group, please visit  Regards,</body>
  </mail>
  <mail>
    <header>Re: Be able to do a partial class mock</header>
    <body>In fact it wasn't hard after all... Sounds silly to ask for help and to find the solution by reading cglib doc 5 minutes. And it's also great to have a little time to work seriously. So I've just submitted a new version (2.1) that is implementing the partial mocking. You use it like this: (PartialMockingClass.class, new Class[0], new Object[0], Class[0]) Any suggestion, feeback or improvement is welcome, Henri</body>
  </mail>
  <mail>
    <header>RE: [OT] Constructors throwing Exceptions</header>
    <body>I don't follow you here. Why shouldn't a constructor throw an exception? Is there any article online I should read about this? Curious, Ilja -- ++ Business Intelligence: disy Cadenza Web - drei Klicks zum Ergebnis ++ ++ disy Conference: Telefonkonferenz mit ++ integrierter Datenkonferenz ++ disy: Kosteneinsparungen durch Optimierung Ihrer IuK-Prozesse ++</body>
  </mail>
  <mail>
    <header>Re: [OT] Constructors throwing Exceptions</header>
    <body>Hmmm, I'm not an article online but I try to explain may ideas. Please please, comment on. Throwing exception from constructors/destructors is regarded as a bad design because If your constructor 'need' to throws exception chances that one of the following is true: 1 - object construction is too much complicated null return value substitutes the exception raising and you'll probably 2 - you are exposing third-party inner working (e.g. JDBC) to your application and you are let it command your code 3 - you hold property on some resources you'll better to don't hold (e.g. a JDBC connection) 4 - ... The power of simple constructors is leveraged by JavaBeans. The Spring framework (www.springframework.org) is proably on of the best example of this old good 'java standard' taken to the max. It seems to be the very very good framework (latu sensu) Federico Spinazzi</body>
  </mail>
  <mail>
    <header>RE: Re: Mocking classes instead of interfaces</header>
    <body>EasyMock refers to something about intercepting constructors in the javadoc. I haven't looked into it, though. Apparently CGLIB extends the class (ie. you can't mock a final class). So... in order to instantiate an object, it has to call a constructor. I wouldn't worry that much about constructors blowing up. It really shouldn't happen, and if it does, just pass in the correct arguments so it doesn't. Unless we do what you suggested and auto choose a constructor. And again, if the code is going to change, that means you're controlling it, and means that hopefully you wouldn't throw exceptions in the constructor. In general, it should be rather rare that it would be a problem. -joel __________________________________ Do you Yahoo!? The New Yahoo! Shopping - with improved product search</body>
  </mail>
  <mail>
    <header>EasyMock 1.0.1 available</header>
    <body>Hello all, I have uploaded EasyMock 1.0.1. Changes: - convenience methods expectAndReturn() and expectAndThrow() - numerous refactorings to open up EasyMock for extensions Please let me know whether you like the new convenience methods or not. - Tammo PS I have done a short exploration to port the EasyMock class extension (which Joel Shellman provided on the file section) to EasyMock 1.0.1. If anyone is interested, please let me know.</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.0.1 available</header>
    <body>I'm interested.  Can you post it in the files section? Thanks, Chad</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. 1.0.1 You can access this file at the URL  To learn more about file sharing for your group, please visit  Regards,</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.0.1 available</header>
    <body>I also prefer "Impl".  Whatever I am using most (which is usually the interface) should have the "real" name. Of course, this may not be backward compatible for existing framework classes, so that's a whole other issue.  In this case, you can use a new non-interface adapter class (MockControl) which implements the interface (for example, MockControlManager) and simply wraps the real implementation (MockControlManagerImpl, which used to be MockControl). Thanks, Chad</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.0.1 available</header>
    <body>Any chance you get this uploaded to the maven repository? ewan not. extension 1.0.1.</body>
  </mail>
  <mail>
    <header>Re: EasyMock 1.0.1 available</header>
    <body>Tammo, I think this could be very interesting. I've compiled it into my copy of easymock, and tried to use it, but I think it would be fine to have it in the origial distribution. Thanks, Federico</body>
  </mail>
  <mail>
    <header>verify(long millis)?</header>
    <body>First: Hi! I've found mockobjects.com and easymock.org from reading 'Pragmatic Unit Testing', which has a chapter on Mock Objects. They look like a very valuable tool, and would have been very useful on my current project if I'd found them a few weeks ago: I've ended up writing lots of 'dummy' (i.e. 'mock') implementations that EasyMock could have written for me. Except: I'm doing client/server networked programming (multi-player games), and in many of my tests one end sends a message and I need to verify that the other end received it. The problem would be that 'verify()' assumes that the callbacks to the mock objects happen before the method being tested returns. In my case, I would need a 'verify(long millis)' that would allow up to 'millis' milliseconds for the callbacks to be made. So that it didn't slow down my tests unnecessarily, I'd want it to return when the callbacks were made, rather than waiting 'millis' milliseconds anyway. Here's the class my own mock objects extend to get this capability: My mock objects' reset() methods call 'setReady(false)'; their mock method implementations finish by calling 'setReady(true)' and my equivalent of 'verify(delay)' calls 'waitForReady(delay)' then checks 'isReady()'. I can only handle waiting for one callback. I don't have time right now to contribute such a modification to EasyMock, so if you think this would be useful, please go ahead and use this idea/code yourselves. Otherwise, maybe I'll have time to try it myself early next year... Regards, David</body>
  </mail>
  <mail>
    <header>Re: verify(long millis)?</header>
    <body>I would make a suggestion. Isolate the network layer to an absolute minimum--preferrably one single class that takes care of the socket level stuff. That is then the only class that you have to worry about maybe being slow to test. And you can isolate your "slow" tests if you like so they run at a different granularity (ie. you don't have to run all your slow tests every time you run all your tests during the quick TDD iterations). All the rest of your classes can be tested without any access to the network and so can go very fast as we would like. Oh, and as for testing the socket layer boundary class. You don't need to do that EasyMock stuff I would think. You can just put in a wait in your test case and check to ensure you got the result you want. I've done that for multithreaded tests in the past. -joel</body>
  </mail>
  <mail>
    <header>Re: verify(long millis)?</header>
    <body>I do that. I actually have a simple multi-layered architecture, with each layer of the stack depending on the one below but not on the one above. I've been using JUnit and my own mock objects to test communications between corresponding layers on the client and server stacks. I know how to use more interfaces to remove the remaining inter-layer dependencies, but I'd rather not go so far down that route. It's not slow to test, because during the tests the client and server run on the same PC, and my mock objects' 'verify(delay)' equivalent returns immediately when the callback is called. It only waits for of network operations in less than a second. It seems to me that the concept of 'verify(millis)' would extend EasyMock's scope to cover a broad range of asynchronous programs where calls to collaborating objects happen quickly but not instantaneously. The addition to the API is minimal and compatible, and the implementation is simple (in theory :-) ). The use of 'wait(millis)' as you describe is less widely useful, because it always waits that long even if the callback happens very quickly (or has already happened).</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. cglib) You can access this file at the URL  To learn more about file sharing for your group, please visit  Regards,</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. You can access this file at the URL  To learn more about file sharing for your group, please visit  Regards,</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. 1.3 You can access this file at the URL  To learn more about file sharing for your group, please visit  Regards,</body>
  </mail>
  <mail>
    <header>Packed classfile-mocking patch in jar, and modified to work under JDK 1.3</header>
    <body>Hi, I compiled and packed up the source for the classfile-mocking patch, and also made a small change so that it is JDK 1.3 compatible. All you need to do is put this in your classpath before EasyMock 1.0 jar and the classfile mocking should work.  I am using this on a couple of projects now, and it seems to work fine. One thing I've found - if you don't have a no-arg constructor defined, you have to explicitly pass the arguments types and values in when creating the control. Thanks, Chad M/A=1853618/R=0/SIG=11ts59qjv/*http://www.netflix.com/Default?mqso=60178338∂\ id=4116730</body>
  </mail>
  <mail>
    <header>Cannot override default matcher</header>
    <body>I have code that looks like: But this fails because when adding the expected call getMatcher() is called which does: Now the a matcher is defined for the method, and setMatcher() throws an exception if a matcher is already set. I would expect that the default could be overriden at any time prior to replay(). So, now I have to do something messy like:</body>
  </mail>
  <mail>
    <header>Re: Cannot override default matcher</header>
    <body>Hello memelet, I assume you meant control.setMatcher(myMatcher) ? Overriding the matcher is a potential error in the setup code for the Mock Object, so it should be reported by EasyMock. Setting the matcher that early is a restriction in EasyMock. You are right. That *is* messy. A workaround: If your matcher implementation is applicable to all the methods on the Mock Object, you may use setDefaultMatcher() directly after mock object creation: ... The next version of EasyMock will allow setting the *same* matcher for a method again and again. So the following code will work then: Thanks for your feedback, - Tammo</body>
  </mail>
  <mail>
    <header>Re: Cannot override default matcher</header>
    <body>Perfect. Thanks Tammo. -barry</body>
  </mail>
  <mail>
    <header>New file uploaded to easymock</header>
    <body>Hello, This email message is a notification to let you know that a file has been uploaded to the Files area of the easymock group. classes transparently (It's a terrible nuisance to have to change everything when you switch from interface to class or vice versa). You do not have to specify constructor types/args now--it will try to use the first one it finds for you (as someone suggested on the mailing list). I also changed the name because it was too confusing to me to have the same name. Hope this is useful. You can access this file at the URL  To learn more about file sharing for your group, please visit  Regards,</body>
  </mail>
  <mail>
    <header>I have a circular test problem</header>
    <body>Hi, I have a class (MyClass) that requires and uses my mock object in its constructor. How can I check that MyClass calls my mock correctly, without actually creating the class? The problem I have is that when setting up the mock, I have to enter the name of a method with a parameter that hasn't been created yet. If I create the object used as a parameter (an instance of MyClass) it calls the mock's method. SO I'll get an error because it is called before I have time to set it up. Is this clear? Maybe an example: How can I test that MyClass.update(MyInterface ...) is called correctly. Thanks, L -- GLYME'S FORMULA FOR SUCCESS</body>
  </mail>
  <mail>
    <header>Re: I have a circular test problem</header>
    <body>Laurent, I'm having trouble understanding what you are trying to test.  If you are still having problems with this, post the source for your unit test also, and I'll try to help out if I can. Thanks, Chad</body>
  </mail>
  <mail>
    <header>MockControl implementing an interface</header>
    <body>Hi, I was wondering if it were possible for MockControl to be an interface. The reason I ask is that I want to create a simple Mock interface that extends the interface I'm trying to mock as well as the mock control. This way, I would be able to deal with only one object. For example, I'd like to be able to do something like this: TestCase: So now I'm only dealing with 2 objects instead of 4.  Is something like this even possible?  I haven't really dug into the code yet, but was just wondering.  My first impression is that EasyMock is terrific, but when dealing with 2 or more mock instances, it can start to get a little confusing - anything that could reduce the clutter would help. Thanks, Rex Madden</body>
  </mail>
  <mail>
    <header>Re: MockControl implementing an interface</header>
    <body>Rex, This sounds like a great idea.  I wonder how difficult it would be.  It seems that if the mock that is created could be made to extend MockControl, and MockControl was pulled out to an interface, this would accomplish the goal.  I wonder if it could be easily done... -- Chad M/A=1754451/R=0/SIG=11tkldm5d/*http://www.netflix.com/Default?mqso=60178323∂\ id=3856299</body>
  </mail>
  <mail>
    <header>Re: MockControl implementing an interface</header>
    <body>Well, I hacked into the code and got something similar working. Basically, I created a new interface SelfReliantMock which has a single method getMockControl().  You then create an interface that extends both the SelfReliantMock interface and the interface you want to mock.  I then created my own version of MockControl that will make the mock and insert itself into SelfReliantMock. Unfortunately, MockControl is very difficult to subclass because of all the package friendly classes and interfaces, such as the Behaviors and the ObjectMethodsFilter.  So I just copied the necessary classes and renamed them, modified them to suit my needs and rebuilt. be.  It would interface. that control. something like was terrific, but little 05007181:HM/A=1754451/R=0/SIG=11tkldm5d/* Service</body>
  </mail>
  <mail>
    <header>Extending EasyMock</header>
    <body>I am officially addicted to Mock Objects, Endo Testing and EasyMock.  However, I wish EasyMock were a little more extensible. I would gladly help refactor it so that it would be possible to create custom MockControl implementations.  Is anyone else interested? For anyone who is curious, my goal is to make a MockControl that acts more like DynaMock in its compactness of syntax, so that I could do something like this: cart.expectAndReturn(cart.getCartItem(0), fourDollarProduct) cart.expectAndReturn(cart.getCartItem(1), sixDollarProduct) Well, the example may not make total sense, but you get the idea.  I think it's much easier to read this way since there are a lot fewer lines and fewer objects.</body>
  </mail>
  <mail>
    <header>Re: Extending EasyMock</header>
    <body>I think this is a good idea.  I wonder where Tammo is, haven't heard from him in a long time... M/A=1595054/R=0/SIG=124ukap9t/*http://ashnin.com/clk/muryutaitakenattogyo?YH=370\ 7890&amp;amp;yhad=1595054</body>
  </mail>
  <mail>
    <header>Re: Extending EasyMock</header>
    <body>[...] Hello Rex, While I see your point in combining Mock and Control in one object, please let me explain why I chose to split them in the development of EasyMock. In one of the earliest versions, the mock and the control were the same object. The problem here is that you have to cast between these two interfaces, again and again, so I introduced two variables which pointed to the same object, but were used to access the features of MockController (the old name for MockControl), and the interface of the mock itself. Due to Java's strong type checking, I saw only one way to use only one object: To combine them both in one interface, in the style of one of your earlier mails (at the cost of implementing a combining interface for each "mocked" interface). But this has a serious drawback, especially for TDD: If you add a method to the mock in TDD (using it before it exists), the method looks like it should be added to the combination interface. Today, both Eclipse and IntelliJ would generate it there (please correct me if I am wrong), instead of adding it to the "mocked" interface instead. This destroys one of EasyMocks main benefits, its usefulness in TDD. This code snippet looks really nice, and I tried something similar in EasyMock: controller.setReturnValue(mock.getCartItem(0), fourDollarProduct) I have not followed this path because it led to inconsistencies. To set a Throwable in the same style, the code would have to look like But due to Java's strong type checking, this only works for methods with a non-void return type! - Tammo</body>
  </mail>
  <mail>
    <header>Re: Extending EasyMock</header>
    <body>Hi Tammo, Thanks for the background - and of course, thanks for the wonderful tool. I agree, it is annoying when IntelliJ puts the method on the Mock version of an object, but that's one annoyance I'm willing to live with.  It requires me to use the Pull Members Up refactoring, but it's not too bad.  I've never used Eclipse, so I can't speak for it. As for exceptions, I never thought of that, probably because I haven't played around with setException at all yet.  But again, if that's the only problem (and I'm sure there are more) I could live with that one as well.  The way I look at it, 90% of my test code is going to be like I showed before, so if I can make that 90% of my test code MUCH more readable, I'll make a few sacrifices elsewhere. But this all goes back to why I'd like to make the framework more extensible.  Some people probably wouldn't like my style, and some people would.  I just think they should have the option to use whatever style they choose, and create new ones if they want to suit they're needs. Rex same same itself. one of for for method instead. in set with</body>
  </mail>
  <mail>
    <header>Re: Extending EasyMock</header>
    <body>Couldn't you provide both approaches, and throw an IllegalArgumentException anytime the user tries to specify a return value for a void method?  It seems like this would be the most flexible approach.</body>
  </mail>
  <mail>
    <header>Re: Extending EasyMock</header>
    <body>I understand now.  This method could still be supported, even though the user would have to understand it that they must use the two-line approach for recording void method calls.  However, this would be more confusing and brittle to refactoring, and I'm not sure if it would be justified. Incidentally, the reason this compact approach works for DynaMock (from mockobjects.com) and not EasyMock is that DynaMock requires you to specify the expected method names as strings.  It doesn't have the "recording" concept like EasyMock.  This means that in DynaMock the methods aren't checked at compile-time.  You probably knew this, but I think it's useful to know for people who aren't familiar with DynaMocks. So, in this case, one of EasyMock's best features (ease of refactoring) work against it.  However, I still think the value of this feature far outweighs the small inconvenience of having two separate lines required when recording mock calls.</body>
  </mail>
  <mail>
    <header>RE: Extending EasyMock</header>
    <body>Your almost there!  Normal void calls can still work on a single line - for example, this works fine: But, if you wanted to throw an exception for those two calls, you would have to do: So, for setting exceptions for void calls, you MUST use 2 lines. Everything else, you're OK (that right, Tammo?)  For me, that's good enough, but I imagine for a lot of people, it's not.  But again, all I'm trying to do is make the framework extensible enough to support another type of MockControl interface.  Seems like a worthy enough goal - once I can find some time to do it. Rex Madden www.fetchaflick.com rex@... -----Original Message----- From: Chad Woolley [mailto:lists@...] Sent: Tuesday, September 30, 2003 9:57 PM To: easymock@yahoogroups.com Subject: Re: [easymock] Extending EasyMock I understand now.  This method could still be supported, even though the user would have to understand it that they must use the two-line approach for recording void method calls.  However, this would be more confusing and brittle to refactoring, and I'm not sure if it would be justified. Incidentally, the reason this compact approach works for DynaMock (from mockobjects.com) and not EasyMock is that DynaMock requires you to specify the expected method names as strings.  It doesn't have the "recording" concept like EasyMock.  This means that in DynaMock the methods aren't checked at compile-time.  You probably knew this, but I think it's useful to know for people who aren't familiar with DynaMocks. So, in this case, one of EasyMock's best features (ease of refactoring) work against it.  However, I still think the value of this feature far outweighs the small inconvenience of having two separate lines required when recording mock calls. in set with flexible could in To unsubscribe from this group, send an email to: easymock-unsubscribe@yahoogroups.com Your use of Yahoo! Groups is subject to</body>
  </mail>
  <mail>
    <header>Assertions about domain objects in the mocks</header>
    <body>I was re-reading the original Mock Objects paper this morning and I came across a section about assertions in their mocks.  It said that one of the benefits of using mocks is that you can put assertions in the calls on the mock to alert you if a mock is being used incorrectly.  For example, if I have a MockShoppingCart, I could put an assertion in the mockCart.addProduct(x) function that checks to make sure that x isn't null, and complains with "addProduct should never be called with a null object".  This way, all users of that MockShoppingCart object get the benefit of checking that assertion. Obviously, this isn't possible in EasyMock, at least not in its current state.  I'm not sure how big a deal this is, because I never really played with static mocks that much, but it is something to keep in mind as a possible drawback to EasyMock. Rex</body>
  </mail>
  <mail>
    <header>Re: Assertions about domain objects in the mocks</header>
    <body>Am Donnerstag, 02.10.03 um 20:19 Uhr schrieb Rex Madden: Hello Rex, as far as I understand your requirement, I think it is possible with EasyMock. If you do not set a behavior for the null argument, EasyMock will complain. If you would like a Mock object that returns silently for every call except a null object, you may try control.setThrowable(new AssertionFailedError("should never be called or you may define a ParameterMatcher that matches for every argument except null, and set it for the addProduct() method. - Tammo</body>
  </mail>
  <mail>
    <header>Re: can't setReturnValue() for toString () ?!</header>
    <body>It mentions that you can't override toString, equals and hashcode in the documentation.  Here's the thread where Tammo explains why:  method but</body>
  </mail>
  <mail>
    <header>Re: Re: can't setReturnValue() for toString () ?!</header>
    <body>I read Tammo's reason, and I still find the solution is worse than the problem. I can live without the equals(), and hashCode() returning a constant is correct, but toString() is a basic layer in TDD, because of assertEquals(a,b). This limitation forced me to write an assertEqualsMock(), and a static toStringMock(x). I can think of other cases where you would lose more than convenience. Request: -------- Improve the behaviour this way : - If the user bothers to set a return value for equals(), toString() or hashCode(), use it. - Otherwise, keep the current behaviour. Alain Ravet</body>
  </mail>
  <mail>
    <header>RE: Re: can't setReturnValue() for toString () ?!</header>
    <body>I'm not sure that I follow.  Where would toString get called in assertEquals(a,b)? And if you have other cases in mind, please share.  That being said, I think I could live with your proposal.  Tammo? Rex Madden www.fetchaflick.com rex@... -----Original Message----- From: Alain Ravet [mailto:alain.ravet.list@...] Sent: Tuesday, October 14, 2003 3:38 AM To: easymock@yahoogroups.com Subject: Re: [easymock] Re: can't setReturnValue() for toString () ?! I read Tammo's reason, and I still find the solution is worse than the problem. I can live without the equals(), and hashCode() returning a constant is correct, but toString() is a basic layer in TDD, because of assertEquals(a,b). This limitation forced me to write an assertEqualsMock(), and a static toStringMock(x). I can think of other cases where you would lose more than convenience. Request: -------- Improve the behaviour this way : - If the user bothers to set a return value for equals(), toString() or hashCode(), use it. - Otherwise, keep the current behaviour. Alain Ravet Yahoo! Groups Sponsor ADVERTISEMENT To unsubscribe from this group, send an email to: easymock-unsubscribe@yahoogroups.com Your use of Yahoo! Groups is subject to the Yahoo! Terms of Service.</body>
  </mail>
  <mail>
    <header>Re: Re: can't setReturnValue() for toString () ?!</header>
    <body>In the error message : "Expected xxxx, but found yyy". Alain Ravet</body>
  </mail>
  <mail>
    <header>Re: can't setReturnValue() for toString () ?!</header>
    <body>Oh, I see.  You're talking about the junit message, not the test for equality itself.  I assume your problem is that if it says "Expected EasyMock for IFoo, but found EasyMock for IFoo", you have no idea which mock it's talking about. Yeah, it can be kind of annoying when you have more than one mock of the same class.  But having to override toString for that case every time seems a bit excessive.  I'm sure there are better solutions for that problem. One that comes to mind is to use a MockFactory to instantiate mocks instead of static calls.  Then the factory can assign a sequence # to each mock, and the message could look like: "Expected EasyMock for IFoo #1, but found EasyMock for IFoo #3" Just a thought.  I'm sure there are others. Rex</body>
  </mail>
  <mail>
    <header>Re: Re: can't setReturnValue() for toString () ?!</header>
    <body>Rex Exactly. Too complex; all I need is just a plain and informative toString() implementation: Example : ------- In my tests, I use a simple mock object factory. So, I replace by with /* */ All I need is to be allowed to uncomment the toString() in the code above (and for EasyMock to use the info properly). Alain Ravet</body>
  </mail>
  <mail>
    <header>Mocking classes instead of interfaces</header>
    <body>I saw somewhere on the site about a TODO to use cglib to mock classes as well as interfaces. Well... I found that a big nuisance to not be able to mock classes easily, so... I spent about half an hour this morning and hooked cglib up to EasyMock and it seems to work great. I haven't tested it much yet, but the change is nearly trivial to MockControl.java to make it work. All you have to do is replace the private constructor in MockControl.java with the code below (sorry about formatting). I don't know what the process if for updating EasyMock codebase, but I would think many people would find this a very useful enhancement. Thanks! -joel shellman private void setupMockForInterface(Class interfaceToMock) this.mock = Proxy .newProxyInstance( loader, new ObjectMethodsFilter(new public Object invoke(Object proxy, Method method, return MockControl.this.invoke(proxy, method, private void setupMockForClass(Class classToMock) MethodInterceptor interceptor = new MethodInterceptor public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable return MockControl.this.invoke(proxy, this.mock = Enhancer.enhance(classToMock, null, Oh, and here's a really basic test case that worked (so you know how little I've tested it so far). public void testClass() MockControl mockObject = MockControl.createNiceControl assertEquals("Class proxy didn't work", "blue",</body>
  </mail>
  <mail>
    <header>Re: Mocking classes instead of interfaces</header>
    <body>I had to make some additional modifications to MockControl.java in order to mock classes that do not have default constructors. It might not be the ideal strategy, but it was quick, easy, and it works. I've uploaded the new MockControl.java as a file in the Yahoo EasyMock group. Also, you'll need the CGLIB jar to use it.  -joel __________________________________ Do you Yahoo!? The New Yahoo! Shopping - with improved product search</body>
  </mail>
  <mail>
    <header>RE: Re: Mocking classes instead of interfaces</header>
    <body>You're right, the MockControl code could arbitrarily choose a constructor. I thought about that, but: 1) Didn't want to spend the time doing it 2) There would be a LOT of cases where things would blow up and so you have to at least support passing in the constructors. So, adding in that function sounds cool, but it's an addition, not a replacement. -joel 007181:HM/A=1595055/R=0/SIG=124j83ehr/*http:/ashnin.com/clk/muryutaitake __________________________________ Do you Yahoo!? The New Yahoo! Shopping - with improved product search</body>
  </mail>
  <mail>
    <header>RE: Re: Mocking classes instead of interfaces</header>
    <body>Hmmm... I suppose you're right. Now that I actually think about it (I was sort of hurried this morning when I did it), the only time it would blow up is if the constructor throws an exception. So... That's when it would blow up. And so long as people build constructors the way they should: ie. don't throw exceptions from constructors (cause it gets wrapped or something and tricky to track down sometimes), then it should work just fine. Cool. And since you can getConstructors() on a class and just grab the first one, shouldn't be hard to do, either. -joel 007181:HM/A=1595055/R=0/SIG=124j83ehr/*http:/ashnin.com/clk/muryutaitake 007181:HM/A=1524963/R=0/SIG=12o885gmo/*http:/hits.411web.com/cgi-bin/aut __________________________________ Do you Yahoo!? The New Yahoo! Shopping - with improved product search</body>
  </mail>
  <mail>
    <header>RE: Re: Mocking classes instead of interfaces</header>
    <body>Oh, I see. I was assuming the constructors would get intercepted by the CGLIB stuff, too, but I guess that it only allows you to intercept regular methods, right?  In that case, a constructor could obviously blow up.  Too bad.  It would be nice if there was a work-around for this. This all makes me a little gun-shy about using real classes instead of interfaces, then.  I could see a bunch of tests starting to blow up just because a constructor's arguments changed.  Or because the innards of a constructor changed.  It's certainly not as refactoring-proof as using interfaces, which was obviously Tammo's goal of the whole thing in the first place.  Still, it could be a nice add-on. Rex Madden www.fetchaflick.com rex@... -----Original Message----- From: Joel Shellman [mailto:joel@...] Sent: Thursday, October 16, 2003 6:15 PM To: easymock@yahoogroups.com Subject: RE: [easymock] Re: Mocking classes instead of interfaces Hmmm... I suppose you're right. Now that I actually think about it (I was sort of hurried this morning when I did it), the only time it would blow up is if the constructor throws an exception. So... That's when it would blow up. And so long as people build constructors the way they should: ie. don't throw exceptions from constructors (cause it gets wrapped or something and tricky to track down sometimes), then it should work just fine. Cool. And since you can getConstructors() on a class and just grab the first one, shouldn't be hard to do, either. -joel 007181:HM/A=1595055/R=0/SIG=124j83ehr/*http:/ashnin.com/clk/muryutaitake 007181:HM/A=1524963/R=0/SIG=12o885gmo/*http:/hits.411web.com/cgi-bin/aut __________________________________ Do you Yahoo!? The New Yahoo! Shopping - with improved product search  To unsubscribe from this group, send an email to: easymock-unsubscribe@yahoogroups.com Your use of Yahoo! Groups is subject to</body>
  </mail>
  <mail>
    <header>Re: Mocking classes instead of interfaces</header>
    <body>Hi, Chris from CGLIB here. CGLIB generates subclasses at runtime, so only non-final classes and methods may be intercepted. Because you must call "super(something)" as the first thing in a constructor (even if it just the implicit "super()") there is really no opportunity for intercepting constructors w/o bytecode enhancement. There are plenty of interesting classes that have null constructors, though (for example InputStream) and could benefit from being mocked, IMHO. Also, depending on how you use CGLIB you can get a significant performance boost over dynamic proxies. Regards, Chris</body>
  </mail>
  <mail>
    <header>RE: Re: Mocking classes instead of interfaces</header>
    <body>I think if you can introduce an interface, you should do so, yes. I guess there are *some* instances where your can't, for example when writing learning tests for third party code. In this case, being able to mock real classes could still be better than having to use the real ones... Take care, Ilja -- ++ Business Intelligence: disy Cadenza Web - drei Klicks zum Ergebnis ++ ++ disy Conference: Telefonkonferenz mit ++ integrierter Datenkonferenz ++ disy: Kosteneinsparungen durch Optimierung Ihrer IuK-Prozesse ++</body>
  </mail>
  <mail>
    <header>Parameter Matcher????</header>
    <body>The preview 3 documentation in news.txt states the following: I don't understand lines 1 and 3... why wouldn't it look like this instead? How does it know to use the parameter matcher for parameter 2 and not parameter 1.  What if I want to set a parameter matcher for each parameter in my method? Also I tried this out and created my own parameter matcher and set it using setMatcher() and it doesn't get called...  Please advise on how the parameter matcher works. Thanks, Brian</body>
  </mail>
  <mail>
    <header>Can we set the default Pattern Matcher?</header>
    <body>Is their a way to set the default Pattern Matcher?  Right now it defaults to MockControl.EQUALS_MATCHER Thanks, Brian</body>
  </mail>
  <mail>
    <header>Re: easy mock 1.0 documentation</header>
    <body>easymock@yahoogroups.com schrieb am 23.06.03 16:40:41:</body>
  </mail>
  <mail>
    <header>Re: easy mock 1.0 documentation</header>
    <body>easymock@yahoogroups.com schrieb am 23.06.03 16:40:41: First of all, sorry for the empty answer. I hope to release documentation at the end of this month. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Parameter Matcher????</header>
    <body>easymock@yahoogroups.com schrieb am 23.06.03 17:29:59: In fact, both should work, generating the same result. I wonder if I have a test case for that. Sorry, the tests are a mess. I is not directly supported by EasyMock. I have not included that since it leads to ugly errors when refactoring (reordering parameters). And EasyMock's strong side is stability when refactoring. If this is not an issue for you, just write a subclass for ParameterMatcher that provides the missing functionality. ? It *should* get a call. There is an example in one of the tests. Would you provide a test case with your expectation? - Tammo</body>
  </mail>
  <mail>
    <header>Re: Can we set the default Pattern Matcher?</header>
    <body>easymock@yahoogroups.com schrieb am 23.06.03 18:46:39: There is none at the moment, but it sounds like a good idea. I'll schedule that for 1.0, unless someone comes up with a good reason not to support it. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Parameter Matcher????</header>
    <body>this mess. not Your right - it would be a pain if your parameter order changed. ParameterMatcher set it how Sorry about that - I had an issue not related to easymock causing me problems, it is resolved and the setMatcher() works great.  Thanks for the offering to help out.</body>
  </mail>
  <mail>
    <header>Re: Can we set the default Pattern Matcher?</header>
    <body>That would be great, because by default we would like to use the ARRAY_MATCHER. Thanks, Brian</body>
  </mail>
  <mail>
    <header>setVoidCallable is not automatically assumed with using ALWAYS_MATCHER</header>
    <body>Hello, I am trying out the new 1.0 previous 3 release.  I think I have found a bug. On my control, I call "control.setMatcher (MockControl.ALWAYS_MATCHER)" after recording a method with two parameters and a void return type (it's a method on an EJB).  This should make the call accept any parameters. However, when I ran the test, I kept getting an "Unexpected parameters..." exception. Then, I added the call "control.setVoidCallable", and my test passed. This doesn't seem to be correct behavior, since the easymock 0.7 release notes state "setVoidCallable() is automatically assumed if missing". Let me know if this is a bug, or if I am doing something wrong.  If you cannot recreate this problem, please let me know and I'll try to come up with a simple test case that recreates it. Thanks, Chad</body>
  </mail>
  <mail>
    <header>Recorded call which throws an exception is not counted as an actual call</header>
    <body>Hi, I am using 1.0 preview 3.  I am recording two subsequent calls to the same method, with a different parameter each time.  On the second call, I am specifying an exception to be thrown. The problem is that the second call isn't getting recorded by EasyMock as an "actual" call.  Even though I can trace and see both of the methods get called (and the exception get thrown on the second one), I get the following failure: method validateAddress(...) expected: 2, actual: 1 Is this a bug, or am I doing something wrong?  I can provide more details if needed. Thanks, Chad</body>
  </mail>
  <mail>
    <header>Re: Recorded call which throws an exception is not counted as an actual call</header>
    <body>Am Freitag, 11.07.03 um 07:54 Uhr schrieb Chad Woolley: Sounds like a bug. Would you provide a test case? - Tammo</body>
  </mail>
  <mail>
    <header>Re: setVoidCallable is not automatically assumed with using ALWAYS_MATCHER</header>
    <body>Am Mittwoch, 09.07.03 um 04:09 Uhr schrieb thewoolleyman: It is a bug. It will be fixed in the next version. Thanks for your feedback, - Tammo</body>
  </mail>
  <mail>
    <header>EasyMock 1.0 Release Candidate available</header>
    <body>Hello all, I have uploaded EasyMock 1.0 Release Candidate. Changes: - complete documentation - complete JavaDoc - better messages when expectations fail - default parameter matchers - bug fixes It is available at If you find a bug, please report it as soon as possible, as I would like to release 1.0 end of this month. - Tammo</body>
  </mail>
  <mail>
    <header>RE: EasyMock 1.0 Release Candidate available</header>
    <body>Hallo Tammo, weil's mir grade einfallt: Ich habe mal versucht, die toString() Methode auf einem Mock aufzurufen. Die wird aber anscheinend nicht registriert, auch dann nicht, wenn sie im Interface explizit angegeben wird. Folge: der Controller beschwert sich, dass ich die Methode vor dem replay() nicht registriert hatte. Mach' ich da was falsch? Brauchst du ein Beispiel? gruss Mittie P.S. Ich find' EasyMock einfach geil!</body>
  </mail>
  <mail>
    <header>Re: RE: EasyMock 1.0 Release Candidate available</header>
    <body>Dierk wrote (21.07.03 10:55:00): Hello Dierk, the object methods toString(), equals() and hashCode() cannot be redefined for EasyMock mock objects. In earlier versions of EasyMock, this has been possible. It lead to ugly errors. Some examples: - A Mock Object is added to a HashSet - an error message is generated using toString() on the mock In the new version, calls to the Object methods work in record as well as in replay state, so that it is possible to use them in sets and so on before activation. hashCode()  returns toString().hashCode() equals() is object identity. Thanks for your feedback, - Tammo</body>
  </mail>
  <mail>
    <header>RE: RE: EasyMock 1.0 Release Candidate available</header>
    <body>Hi Tammo, thanx for the quick reply. I think I understand your point. I'm left with the following problem: I have a mock that I would like to throw an Exception as soon as its toString() method is called. This is to verify my method's exception handling. Is there a way to do this with EasyMock? cheers Mittie BTW: maybe a more specific error message would be helpful, when using the Object methods inappropriately. mymethod(IX x)</body>
  </mail>
  <mail>
    <header>Re: RE: RE: EasyMock 1.0 Release Candidate available</header>
    <body>easymock@yahoogroups.com schrieb am 21.07.03 14:25:41: No, there is none. EasyMock does not allow to specify behavior for hashCode(), equals(Object) and toString(), even if they are part of an interface. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Recorded call which throws an exception is not counted as an actual call</header>
    <body>Tammo, I found the root of this problem.  It occurs when you try to record a return value AND also record an exception to be thrown. This obviously shouldn't be done, but the error it gives is very misleading, and hard to debug. I think it would be much more intuitive if EasyMock threw some sort of exception (IllegalStateException?) immediately if you tried to record both a return value and an exception for the same call. Is this possible to get into the 1.0 release? Thanks, Chad M/A=1595054/R=0/SIG=124f8kfa7/*http://ashnin.com/clk/muryutaitakenattogyo?YH=351\ 2152&amp;amp;yhad=1595054</body>
  </mail>
  <mail>
    <header>Re: Re: Recorded call which throws an exception is not counted as an actual call</header>
    <body>Chad wrote (23.07.03 23:02:06): Hello Chad, I have changed most of the error messages in EasyMock 1.0RC. Is the error message better now? It's not a bug, it's a feature. EasyMock allows you to record expected method calls and reactions to them. For example: the first call will be answered by returing "the return value" and the second call will be answered by throwing the provided IOException. Would you provide an example what you would like to test and what you would like to configure the Mock Object to check? Thanks for your feedback, Tammo</body>
  </mail>
  <mail>
    <header>Re: Recorded call which throws an exception is not counted as an actual call</header>
    <body>Tammo, Thanks for the response.  I wasn't aware of that behavior.  I thought you had to record another call on the mock to record a different return type/exception. So, I'd like to make sure I understand. Do the following two sequences result in the same two identical calls being recorded? 1) 2) Thanks, Chad M/A=1652964/R=0/SIG=11t2ts2ch/*http://www.netflix.com/Default?mqso=60178276∂\ id=3170658</body>
  </mail>
  <mail>
    <header>Re: Recorded call which throws an exception is not counted as an actual call</header>
    <body>That's right. - Tammo</body>
  </mail>
  <mail>
    <header>setReturnValue doesn't work if mock?</header>
    <body>If I do something like: ... commandControl.setReturnValue(mockCommand); // this blows up! Apparently I can't set a return value that is a mock because the call uses the JDK's Class.isAssignableFrom(), which requires the class, not an interface. Boo hoo! Has anyone come across this and is there a work-around?  If I find one before hearing anything I will post it. Thanks in advance. -Nick B</body>
  </mail>
  <mail>
    <header>Re: setReturnValue doesn't work if mock?</header>
    <body>This should work just fine.  I regularly return mock EJB objects from mock EJBHome objects (which come out of a TestInitialContext that is returned from a TestNamingFactory). Does your mock object satisfy the return type of your getABC() method? What kind of blow up message do you get? You should upgrade to the latest.  It is well worth the pain of fixing your existing test code base. Do I know you? tc call</body>
  </mail>
  <mail>
    <header>Re: Re: setReturnValue doesn't work if mock?</header>
    <body>We are using an old version of EasyMock which we have twisted to our own evil purposes. (In fact I think you did this when you used to work here, damn you, Tom, you blackguard, you have become the company scapegoat, you realize. And of all the nefariousness, you even have the abjurant cheek to answer this posting!!!) Seriously, though, upgrading might help especially if the new version's verify lets us do special things with the equals() method... does it? Apparently the version we have right now gets checked against java.lang.Class.isAssignableTo() which seems to try and scrape the interface away from the Proxy, which blows. So it's been fixed? And yeah this is the Nicktionary you know and shun, how's the wife &amp;amp; kid, Tom? Coffee this weekend? __________________________________ Do you Yahoo!? Yahoo! SiteBuilder - Free, easy-to-use web site design software</body>
  </mail>
  <mail>
    <header>Re: setReturnValue doesn't work if mock?</header>
    <body>I don't think you can twist EasyMock to nefarious purposes.  Oh, then there's that project you're on . . . Upgrade, upgrade, upgrade.  New version allows you to give the control object a custom ParameterMatcher to match the parameters any fancy or nefarious way you like.  There are a couple free ones - like an ArrayMatcher, but you can very easily extend the AbstractMatcher or implement the ParameterMatcher. You'll have some deprecation issues, but you can clean those up as you go.  On your project you will have to put on your Rational Rose camoflage and commando crawl beneath documentation whizzing over your head (though its probably more like oozing than whizzing), but I'm sure you'll do fine. Keep telling them the world is round. I had to post this twice, so if two messages come out of this, please forgive me.</body>
  </mail>
  <mail>
    <header>Re: Re: setReturnValue doesn't work if mock?</header>
    <body>I'm on a project? Oh, THAT. That's not a project, it's a prototype! Exactly what was missing. All that's going on several foxholes away. Back here where only a few UML ricochets are heard pranging off the walls, I play penuchle with my 3 wary comrades, writing actual code on the FU branch, eXtreme as that may sound. The world is round? Oh THAT world. Right. I get mixed up sometimes. __________________________________ Do you Yahoo!? Yahoo! SiteBuilder - Free, easy-to-use web site design software</body>
  </mail>
  <mail>
    <header>Problems with ParameterMatcher.parameterMatches()</header>
    <body>Hi, My team has found some apparent bugs while implementing custom ParameterMatchers with the parameterMatches() method. The details of the bugs are reported on SourceForge, at the link below:  tid=567837 I have attached a sample unit test and code to to the bug report. Thanks, Chad</body>
  </mail>
  <mail>
    <header>Why is only one ParameterMatcher per method signature allowed?</header>
    <body>Hello, I am wondering why there is a restriction on only one ParameterMatcher per method signature?  For example, the following fails with an IllegalStateException: I would think could be valid reasons to use a different matcher for subsequent calls to the same method. Would this be a change that could be expected in a future version of EasyMock? Thanks, Chad</body>
  </mail>
  <mail>
    <header>Re: Why is only one ParameterMatcher per method signature allowed?</header>
    <body>Am Donnerstag, 14.08.03 um 04:45 Uhr schrieb Chad Woolley: The parameter matcher is a way to provide another algorith to compare expected and actual parameters than the default of EasyMock (compare all paramterers with equals()). As it is a kind of a custom equals() version for parameters, and so it is only set once for each method. Typically it is not the matcher that changes, but the expected parameters. - Tammo</body>
  </mail>
  <mail>
    <header>Re: Problems with ParameterMatcher.parameterMatches()</header>
    <body>Hi, I've reopened 788459 ( 37 I do believe this is a bug, and have included a new test case as well as expected and actual (incorrect) test output. Thanks, Chad  tid=567837 atid=567837</body>
  </mail>
  <mail>
    <header>newbie question about default return values.</header>
    <body>hi..im using easymock ver0.8,here is the problem i face. say i have an interface X public interface X where Foobar is another interface. now what i really want to do is: ------------------ -------------------------- now i dont have an implementation of foobar handy, so i cant put statement &amp;lt;2&amp;gt; ,but i want to set the default return value as in statement &amp;lt;3&amp;gt;.Is there a way how i can do it ? Im tempted to create a mock implementation of interface X ,but aside from that  i wanted to know if setting a default value can be achieved with easymock. I could use "EasyMock.niceControlFor()" ,but i need to return a valid ComplexObject. ciao</body>
  </mail>
  <mail>
    <header>Re: newbie question about default return values.</header>
    <body>[...] Try - Tammo</body>
  </mail>
  <mail>
    <header>Test - please ignore</header>
    <body>Test 123</body>
  </mail>
  <mail>
    <header>want a method never called in a method.</header>
    <body>hi,all. I am trying to write a testcase using easymock. In the setUp method of the testcase,I build up some "fixture",that will be used across multiple tests I mocked several method of a interface,but a single test won't use all those methods. I tried to write something like this: when I run the test,It throws failure said that the "insert" method of mockBusinessObjectDAO are expected to be called at least once,but never called in method testGetList() ........... in fact the mockBusinessObjectDAO will be used even across serveral testcases,so I want to define it's behavior in a central position. how can I achieve this?</body>
  </mail>
  <mail>
    <header>RE: want a method never called in a method.</header>
    <body>If I undestood you correctly, - you want to define a number of allowed method calls, and - not all of your test cases use all of these method calls. Then just do not call verify(). Whether a method call was set as expected is checked immediately for every method call on the mock object. verify() only checks that there is no unused expected behavior left. Hope that helps, Tammo ________________________________________ Online Fotoalben - jetzt kostenlos bei</body>
  </mail>
  <mail>
    <header>EasyMock 1.0 preview 1 available</header>
    <body>Hi all, the first preview of EasyMock 1.0 is available (see There are a couple of requested features implemented, like - order checking. Just use EasyMock.strictMockControlFor() - call count ranges. To specify 3 to 6 expected calls to - ParameterComparators may be set for each Method. However, it is incompatible to the previous version. There are some renamings, but the biggest change is for non-specified call counts. In EasyMock 0.8, specified that the method call is expected one or more times, each time returning "Test". Now the same code specifies that the method call is expected exactly once. If you would like to discuss the new features, please drop me an e-mail, or post an answer to this list. - Tammo</body>
  </mail>
  <mail>
    <header>Mock methods that should alter a parameter</header>
    <body>In the object I wish to mock, there is a method that alters one of the parameters it accepts and returns nothing.  How can I make my mock object alter the parameter in the same way? The code is: // aParameter is now altered, e.g., it is a Map and an entry has been added. Thanks</body>
  </mail>
  <mail>
    <header>IllegalAccessError with o.em.Ranges</header>
    <body>Just trying out EasyMock for the first time. Using a constant for the number of values to return as listed in the distribution's 'news.txt' gives me an Error: testRank(com.optiron.readi.DebitDateRankCriterionTest)java.lang.IllegalAccessErr\ or: tried to access class org.easymock.Ranges from class com.optiron.readi.DebitDateRankCriterionTest ... The relevant line is: It seems that the constant ONE_OR_MORE is from org.easymock.Ranges, but since it's not a public interface I don't have access to it. (The same problem will probably exist with org.easymock.Range.) FWIW, I get the same error when I run org.easymock.tests.UsageTest. I can easily get around the problem by just using "1, 1000" in setReturnValue() (where 1000 is just SomeBigNumber), but I thought you should know. Thanks! Chris</body>
  </mail>
  <mail>
    <header>Re: Mock methods that should alter a parameter</header>
    <body>Am Mittwoch, 23.04.03 um 15:57 Uhr schrieb anonymousfu240: This is not possible using EasyMock. Kind regards, - Tammo</body>
  </mail>
  <mail>
    <header>Re: IllegalAccessError with o.em.Ranges</header>
    <body>Hello Chris, thanks for your feedback. This bug only occurs when using the jar file in the test, instead of single .class files. It will be fixed in the next preview. Kind regards, - Tammo</body>
  </mail>
  <mail>
    <header>Re: Mock methods that should alter a parameter</header>
    <body>can you post an example of your code? It sounds like the structure of the test (or maybe even the code) is not quite right. S.</body>
  </mail>
  <mail>
    <header>EasyMock 1.0 Preview 3 available</header>
    <body>Hi all, EasyMock 1.0 Preview 3 is available. It restores compatibility with Java 1.3.1 and fixes two other bugs. - Tammo</body>
  </mail>
  <mail>
    <header>Class support</header>
    <body>I found EasyMock really easy to use, however, it could be even better to have class support. I know it is very difficult because dynamic proxy do not support class. I have an idea might useful. Apache BCEL can create a java class on the fly. I used it to create an interface having all public non-static methods of the class I want to create proxy for. The problem is that I have to load the generated class, either by a customized class loader, or directly by the default class loader. The first method can create the proxy object with no problem, but since the class loader for the object differs from the default class loader, I can not cast the proxy object to the target class type. The second method is dump the class file to the system class path, and let the default class loader load it into memory. It works, but I hate to write the class file to disk. Probably you can have better idea when you try BCEL. Best regards, Yunfeng Hou</body>
  </mail>
  <mail>
    <header>How to verify two sequential calls with different arguments?</header>
    <body>Hi, First, thanks for the great tool.  Now for my question: I am calling the same method twice (void return type) with different arguments.  How can I verify that the second argument is passed correctly? If I do this: everything passes, even though I passed a different value ("BBB") on the second call. Any ideas? Thanks, -- Chad</body>
  </mail>
  <mail>
    <header>easy mock 1.0 documentation</header>
    <body>Any idea when the documentation will be up-to-date? Thanks, Brian</body>
  </mail>
</mails>

