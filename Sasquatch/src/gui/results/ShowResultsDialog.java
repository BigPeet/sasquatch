/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package gui.results;

import javax.swing.table.DefaultTableModel;

import manager.systems.SoftwareSystem;
import analyzer.interfaces.IAnalysisResult;
import analyzer.polarity.sentiwordnet.Aspect;
import analyzer.polarity.sentiwordnet.AspectPolarityResult;

/**
 *
 * @author Peter Wolf
 */
public class ShowResultsDialog extends javax.swing.JDialog {

	private static final int SYSTEM_NAME_COLUMN = 0;
	private static final int POSITIVE_COLUMN = 1;
	private static final int NEGATIVE_COLUMN = 2;
	private static final int NEUTRAL_COLUMN = 3;
	private static final int NOT_USED_COLUMN = 4;
	private static final int ASPECT_COLUMN_START = 5;
	private static final int ASPECT_COLUMN_END = 12;
	private SoftwareSystem[] systems;
	private IAnalysisResult[] results;

	/**
	 * Creates new form ShowResultsDialog
	 */
	public ShowResultsDialog(java.awt.Frame parent, boolean modal) {
		super(parent, modal);
		initComponents();
	}

	public ShowResultsDialog(java.awt.Frame parent, boolean modal, SoftwareSystem[] systems, IAnalysisResult[] results) {
		super(parent, modal);
		initComponents();
		setTable(systems, results);
	}

	public void run() {
		this.setLocationRelativeTo(getParent());
		this.setVisible(true);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		jTabbedPane1 = new javax.swing.JTabbedPane();
		jPanel1 = new javax.swing.JPanel();
		jScrollPane1 = new javax.swing.JScrollPane();
		jTable1 = new javax.swing.JTable();

		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

		jTable1.setModel(new javax.swing.table.DefaultTableModel(
				new Object [][] {

				},
				new String [] {
						"Software System", "Positive", "Negative", "Neutral", "Not Used", "Documentation", "Leightweight", "Interface", "Usability", "Flexibility", "Reliability", "Effectiveness"
				}
				) {
			Class[] types = new Class [] {
					java.lang.String.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
			};
			boolean[] canEdit = new boolean [] {
					false, false, false, false, false, false, false, false, false, false, false, false
			};

			public Class getColumnClass(int columnIndex) {
				return types [columnIndex];
			}

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit [columnIndex];
			}
		});
		jScrollPane1.setViewportView(jTable1);

		javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
		jPanel1.setLayout(jPanel1Layout);
		jPanel1Layout.setHorizontalGroup(
				jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGap(0, 734, Short.MAX_VALUE)
				.addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(jPanel1Layout.createSequentialGroup()
								.addContainerGap()
								.addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 714, Short.MAX_VALUE)
								.addContainerGap()))
				);
		jPanel1Layout.setVerticalGroup(
				jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGap(0, 297, Short.MAX_VALUE)
				.addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(jPanel1Layout.createSequentialGroup()
								.addContainerGap()
								.addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 275, javax.swing.GroupLayout.PREFERRED_SIZE)
								.addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
				);

		jTabbedPane1.addTab("All", jPanel1);

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(layout.createSequentialGroup()
						.addContainerGap()
						.addComponent(jTabbedPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 739, Short.MAX_VALUE)
						.addContainerGap())
				);
		layout.setVerticalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(layout.createSequentialGroup()
						.addContainerGap()
						.addComponent(jTabbedPane1)
						.addContainerGap())
				);

		pack();
	}// </editor-fold>//GEN-END:initComponents

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JPanel jPanel1;
	private javax.swing.JScrollPane jScrollPane1;
	private javax.swing.JTabbedPane jTabbedPane1;
	private javax.swing.JTable jTable1;
	// End of variables declaration//GEN-END:variables

	/**
	 * @return the systems
	 */
	public SoftwareSystem[] getSystems() {
		return systems;
	}

	/**
	 * @return the results
	 */
	public IAnalysisResult[] getResults() {
		return results;
	}

	public void setTable(SoftwareSystem[] systems, IAnalysisResult[] results) {
		if (systems.length == results.length) {
			DefaultTableModel model = (DefaultTableModel) jTable1.getModel();
			if (model.getRowCount() > 0) {
				for (int i = 0; i < model.getRowCount(); i++) {
					model.removeRow(i);
				}
			}
			for (int i = 0; i < systems.length; i++) {
				fillColumn(i, model, systems[i], results[i]);
			}
		}
	}

	private void fillColumn(int row, DefaultTableModel model,
			SoftwareSystem ss, IAnalysisResult res) {
		model.addRow(new Object[model.getColumnCount()]);
		model.setValueAt(ss.getName(), row, SYSTEM_NAME_COLUMN);
		if (res instanceof AspectPolarityResult) {
			AspectPolarityResult result = (AspectPolarityResult) res;
			model.setValueAt(result.getPositive(), row, POSITIVE_COLUMN);
			model.setValueAt(result.getNegative(), row, NEGATIVE_COLUMN);
			model.setValueAt(result.getNeutral(), row, NEUTRAL_COLUMN);
			model.setValueAt(result.getNotUsed(), row, NOT_USED_COLUMN);
			Aspect[] aspects = result.getAspects();
			for (int i = ASPECT_COLUMN_START; i < ASPECT_COLUMN_END; i++) {
				Aspect a = aspects[i - ASPECT_COLUMN_START];
				model.setValueAt(getRepresentation(a), row, i);
			}
		}
	}
	
	private String getRepresentation(Aspect a) {
		return a.getPositive() + " / " + a.getNegative();
	}


}